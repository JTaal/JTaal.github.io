<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Convolutional Filter Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #111827;
            color: #e5e7eb;
        }
        .ui-panel {
            position: absolute;
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(8px);
            padding: 1.25rem;
            border: 1px solid rgba(55, 65, 81, 0.7);
            transition: all 0.5s ease-in-out;
            z-index: 10;
        }
        .hidden { display: none !important; }
        #info-panel {
            top: 80px;
            left: 20px;
            max-width: 420px;
            cursor: pointer;
            overflow: hidden;
            border-radius: 12px;
            max-height: 58px;
        }
        #info-panel.expanded {
            max-height: 90vh; 
            cursor: default;
            overflow-y: auto;
            z-index: 11;
        }
        #info-header { display: flex; justify-content: space-between; align-items: center; }
        #toggle-icon { transition: transform 0.3s ease-in-out; }
        #info-panel.expanded #toggle-icon { transform: rotate(180deg); }
        .formula-placeholder {
            font-family: 'monospace';
            background-color: #1f2937;
            padding: 1rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            margin-top: 1rem;
            color: #d1d5db;
            border: 1px solid #374151;
            white-space: pre;
        }
        #controls-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            border-radius: 12px 12px 0 0;
            padding: 1.5rem;
            padding-top: 2rem;
            display: flex;
            justify-content: flex-start; /* Align items to the start for scrolling */
            align-items: center;
            gap: 1.5rem;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #controls-panel.collapsed {
            transform: translateY(calc(100% - 40px));
        }
        #collapse-toggle {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 5rem;
            height: 2rem;
            background-color: rgba(31, 41, 55, 0.9);
            border: 1px solid rgba(55, 65, 81, 0.9);
            border-bottom: none;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        #collapse-icon { transition: transform 0.3s ease-in-out; }
        #controls-panel.collapsed #collapse-icon { transform: rotate(180deg); }
        #controls-wrapper {
            transition: opacity 0.2s ease-in-out;
            width: 100%;
            display: flex;
            flex-wrap: nowrap; /* Prevent wrapping */
            overflow-x: auto; /* Enable horizontal scrolling */
            align-items: center;
            justify-content: flex-start;
            gap: 1.5rem;
            padding-bottom: 1rem; /* Space for scrollbar */
        }
        #controls-wrapper::-webkit-scrollbar {
            height: 8px;
        }
        #controls-wrapper::-webkit-scrollbar-track {
            background: rgba(31, 41, 55, 0.5);
            border-radius: 4px;
        }
        #controls-wrapper::-webkit-scrollbar-thumb {
            background-color: #4f46e5;
            border-radius: 4px;
        }
        #controls-wrapper::-webkit-scrollbar-thumb:hover {
            background-color: #6366f1;
        }
        #controls-panel.collapsed #controls-wrapper {
            opacity: 0;
            pointer-events: none;
        }
        header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background-color: rgba(3, 7, 18, 0.5);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(55, 65, 81, 0.7);
        }
        .menu-button {
            background-color: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            font-weight: 500;
            font-size: 0.875rem;
            white-space: nowrap;
        }
        .menu-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px);
        }
        .menu-button.active {
            background-color: #4f46e5;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
        }
        .menu-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            background-color: rgba(55, 65, 81, 0.8);
        }
        input[type="number"] {
            -moz-appearance: textfield;
            background-color: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 6px;
            color: white;
            text-align: center;
            padding: 0.25rem;
            width: 45px;
            height: 45px;
            font-size: 1rem;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0; /* Prevent control groups from shrinking */
        }
        #kernel-grid {
            display: grid;
            gap: 5px;
        }
        #presets-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }
        .canvas-label {
            position: absolute;
            color: #9ca3af;
            background: rgba(17, 24, 39, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
        }
        #settings-button {
            position: absolute;
            top: 80px;
            right: 20px;
            background-color: rgba(55, 65, 81, 0.8);
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 11;
        }
        #settings-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px) rotate(45deg);
        }
        #settings-panel {
            top: 80px;
            right: 0;
            width: 300px;
            border-radius: 12px 0 0 12px;
            transform: translateX(100%);
            z-index: 12;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }
        #settings-panel.open {
            transform: translateX(0);
        }
        
        @media (max-width: 768px) {
            #settings-button { top: 70px; right: 10px; }
            #settings-panel { top: 70px; width: 280px; max-height: calc(100vh - 80px);}
        }
    </style>
</head>
<body>
    <header>
        <h1 class="text-xl font-bold text-gray-200 tracking-wider opacity-90">3D Convolutional Filter Visualizer</h1>
    </header>

    <div id="info-panel" class="ui-panel">
        <div id="info-header">
            <h2 class="text-xl font-bold text-indigo-400">What is a Convolutional Filter?</h2>
            <div id="toggle-icon" class="text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg></div>
        </div>
        <div id="info-content" class="pt-4 space-y-3">
             <p class="text-gray-300">This 3D visualization shows how a kernel (the floating cubes) processes an input image to create an output. Each cube's height represents its value. As you hover, lines show the neighboring input pixels being multiplied and summed to produce one output pixel.</p>
             <div class="formula-placeholder">NewPixel = Σ(Neighbor × KernelValue)</div>
        </div>
    </div>
    
    <div id="controls-panel" class="ui-panel">
        <button id="collapse-toggle">
            <svg id="collapse-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
        </button>
        <div id="controls-wrapper">
            <div class="control-group">
                 <label class="text-sm font-medium">Kernel Size</label>
                 <div id="kernel-size-selector" class="flex gap-2"></div>
            </div>
            <div id="presets-container" class="control-group"></div>
            <div class="control-group">
                <label class="text-sm font-medium mb-1">Kernel Matrix</label>
                <div id="kernel-grid"></div>
            </div>
            <div class="control-group">
                <div class="flex flex-col gap-4">
                    <div class="control-group"><label for="divisor-input" class="text-sm font-medium">Divisor</label><input id="divisor-input" type="number" value="1" step="0.1" class="w-20 h-10"></div>
                    <div class="control-group"><label for="offset-input" class="text-sm font-medium">Offset</label><input id="offset-input" type="number" value="0" step="0.1" class="w-20 h-10"></div>
                </div>
            </div>
        </div>
    </div>
    
    <button id="settings-button" title="Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0 2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
    </button>
    
    <div id="settings-panel" class="ui-panel hidden">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-xl font-bold text-gray-200">Settings</h3>
            <button id="close-settings" class="text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
        </div>
        <div class="space-y-6">
             <div class="control-group text-left w-full">
                <label for="graphics-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Graphics Quality:</span>
                    <span id="graphics-quality-value">High</span>
                </label>
                <input id="graphics-slider" type="range" min="0.5" max="2" step="0.1" value="1.5" class="w-full">
               <div class="text-xs text-gray-500 w-full flex justify-between mt-1">
                   <span>Low</span><span>Native</span><span>High</span>
               </div>
            </div>
             <div class="control-group text-left w-full">
                <label class="text-sm font-medium self-start w-full">Upload Image</label>
                <input type="file" id="image-upload" accept="image/*" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 cursor-pointer">
            </div>
        </div>
    </div>


<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { CSS2DObject, CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer.js';

    const MAX_KERNEL_SIZE = 9;
    let currentKernelSize = 3;

    let scene, camera, renderer, controls, labelRenderer, raycaster;
    let inputPlane, outputPlane, kernelViz, textureLoader;
    const kernelInputs = [];
    const mouse = new THREE.Vector2(1,1); // Offscreen initially
    let convolutionLines, outputLine;
    const tempVec = new THREE.Vector3();
    let heightData = null, imageDimensions = { width: 0, height: 0 };
    const MESH_DISPLACEMENT_SCALE = 0.2;

    const uniforms = {
        uTexture: { value: null },
        uKernel: { value: new Float32Array(MAX_KERNEL_SIZE * MAX_KERNEL_SIZE) },
        uKernelSize: { value: 3 },
        uDivisor: { value: 1.0 },
        uOffset: { value: 0.0 },
        uTexelSize: { value: new THREE.Vector2() }
    };
    
    const presets = {
        identity: { name: 'Identity', kernel: [0,0,0, 0,1,0, 0,0,0], divisor: 1, offset: 0 },
        sharpen: { name: 'Sharpen', kernel: [0,-1,0, -1,5,-1, 0,-1,0], divisor: 1, offset: 0 },
        boxBlur: { name: 'Box Blur', kernel: [1,1,1, 1,1,1, 1,1,1], divisor: 9, offset: 0 },
        edgeDetect: { name: 'Edge Detect', kernel: [-1,-1,-1, -1,8,-1, -1,-1,-1], divisor: 1, offset: 0 },
        emboss: { name: 'Emboss', kernel: [-2,-1,0, -1,1,1, 0,1,2], divisor: 1, offset: 0.5 },
    };

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 4, 7);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        document.body.appendChild(labelRenderer.domElement);

        controls = new OrbitControls(camera, labelRenderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0);

        raycaster = new THREE.Raycaster();
        textureLoader = new THREE.TextureLoader();

        setupUI();
        initVisualizer();
        setupSettingsPanel();
        
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('mousemove', onMouseMove);
        renderer.setAnimationLoop(animate);
    }

    function initVisualizer() {
        const PLANE_SIZE = 4;
        const SEGMENTS = 128;
        const geometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE, SEGMENTS, SEGMENTS);
        const planeMaterial = new THREE.ShaderMaterial({
            uniforms: { uTexture: { value: null } },
            vertexShader: `
                uniform sampler2D uTexture;
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    vec4 tex = texture2D(uTexture, uv);
                    float height = (tex.r + tex.g + tex.b) / 3.0;
                    vec3 displaced = position + normal * height * ${MESH_DISPLACEMENT_SCALE};
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture;
                varying vec2 vUv;
                void main() {
                    gl_FragColor = texture2D(uTexture, vUv);
                }
            `,
        });

        inputPlane = new THREE.Mesh(geometry, planeMaterial.clone());
        inputPlane.rotation.x = -Math.PI / 2;
        inputPlane.position.z = -2.2;
        scene.add(inputPlane);
        createLabel(inputPlane, 'Input Image', new THREE.Vector3(0, 0, -2.1));
        
        const filteredMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: planeMaterial.vertexShader,
            fragmentShader: `
                uniform sampler2D uTexture;
                uniform float uKernel[${MAX_KERNEL_SIZE * MAX_KERNEL_SIZE}];
                uniform int uKernelSize;
                uniform float uDivisor;
                uniform float uOffset;
                uniform vec2 uTexelSize;
                varying vec2 vUv;
                void main() {
                    vec4 sum = vec4(0.0);
                    int radius = (uKernelSize - 1) / 2;
                    for (int i = 0; i < ${MAX_KERNEL_SIZE}; i++) {
                        if (i >= uKernelSize) break;
                        for (int j = 0; j < ${MAX_KERNEL_SIZE}; j++) {
                             if (j >= uKernelSize) break;
                             vec2 offset = vec2(float(j - radius), float(radius - i)); // Flipped y-axis for texture coords
                             sum += texture2D(uTexture, vUv + uTexelSize * offset) * uKernel[i * uKernelSize + j];
                        }
                    }
                    gl_FragColor = vec4((sum/uDivisor + uOffset).rgb, 1.0);
                }
            `,
        });
        
        outputPlane = new THREE.Mesh(geometry, filteredMaterial);
        outputPlane.rotation.x = -Math.PI / 2;
        outputPlane.position.z = 2.2;
        scene.add(outputPlane);
        createLabel(outputPlane, 'Output Image', new THREE.Vector3(0, 0, 2.1));
        
        kernelViz = new THREE.Group();
        scene.add(kernelViz);
        
        const lineMat = new THREE.LineBasicMaterial({color: 0x6366f1, transparent: true, opacity: 0.7});
        const outLineMat = new THREE.LineBasicMaterial({color: 0x10b981, transparent: true, opacity: 0.9, linewidth: 2});
        convolutionLines = new THREE.LineSegments(new THREE.BufferGeometry(), lineMat);
        scene.add(convolutionLines);
        outputLine = new THREE.LineSegments(new THREE.BufferGeometry(), outLineMat);
        scene.add(outputLine);

        loadImage('https://placehold.co/256x256/d1d5db/1f2937?text=Drop+Image');
        changeKernelSize(3);
    }
    
    function createLabel(object, text, offset) {
        const div = document.createElement('div');
        div.className = 'canvas-label';
        div.textContent = text;
        const label = new CSS2DObject(div);
        label.position.copy(offset);
        object.add(label);
    }
    
    function loadImage(url) {
        textureLoader.load(url, (texture) => {
            texture.colorSpace = THREE.SRGBColorSpace;
            inputPlane.material.uniforms.uTexture.value = texture;
            outputPlane.material.uniforms.uTexture.value = texture;
            outputPlane.material.uniforms.uTexelSize.value.set(1/texture.image.width, 1/texture.image.height);
            
            const img = texture.image;
            imageDimensions.width = img.width;
            imageDimensions.height = img.height;
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, img.width, img.height).data;
            heightData = new Float32Array(img.width * img.height);
            for(let i = 0; i < data.length; i+=4) {
                const gray = (data[i] + data[i+1] + data[i+2]) / 3 / 255;
                heightData[i/4] = gray;
            }
        });
    }

    function setupUI() {
        document.getElementById('collapse-toggle').addEventListener('click', () => {
            document.getElementById('controls-panel').classList.toggle('collapsed');
        });
        
        document.getElementById('divisor-input').addEventListener('input', updateFromUI);
        document.getElementById('offset-input').addEventListener('input', updateFromUI);

        const presetsContainer = document.getElementById('presets-container');
        const presetsLabel = document.createElement('label');
        presetsLabel.className = 'text-sm font-medium';
        presetsLabel.textContent = '3x3 Presets';
        presetsContainer.appendChild(presetsLabel);
        const presetButtons = document.createElement('div');
        presetButtons.className = 'flex gap-2';
        presetsContainer.appendChild(presetButtons);

        Object.keys(presets).forEach(key => {
            const button = document.createElement('button');
            button.className = 'menu-button';
            button.textContent = presets[key].name;
            button.dataset.key = key;
            button.addEventListener('click', () => applyPreset(key));
            presetButtons.appendChild(button);
        });

        const sizeSelector = document.getElementById('kernel-size-selector');
        [3, 5, 7].forEach(size => {
            const button = document.createElement('button');
            button.className = 'menu-button';
            button.textContent = `${size}x${size}`;
            button.dataset.size = size;
            button.addEventListener('click', () => changeKernelSize(size));
            sizeSelector.appendChild(button);
        });
        
        document.getElementById('info-panel').addEventListener('click', (e) => e.currentTarget.classList.add('expanded'));
        document.getElementById('toggle-icon').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('info-panel').classList.toggle('expanded');
        });
    }

    function setupSettingsPanel() {
        const settingsPanel = document.getElementById('settings-panel');
        const settingsButton = document.getElementById('settings-button');
        const closeSettingsButton = document.getElementById('close-settings');
        const graphicsSlider = document.getElementById('graphics-slider');
        const graphicsQualityValue = document.getElementById('graphics-quality-value');
        const uploadInput = document.getElementById('image-upload');

        settingsButton.addEventListener('click', () => {
            settingsPanel.classList.remove('hidden');
            requestAnimationFrame(() => settingsPanel.classList.add('open'));
        });
        closeSettingsButton.addEventListener('click', () => settingsPanel.classList.remove('open'));
        
        settingsPanel.addEventListener('transitionend', () => {
            if (!settingsPanel.classList.contains('open')) settingsPanel.classList.add('hidden');
        });

        graphicsSlider.addEventListener('input', (e) => {
            const quality = parseFloat(e.target.value);
            renderer.setPixelRatio(quality);
            if (quality < 0.8) graphicsQualityValue.textContent = "Low";
            else if (quality < 1.5) graphicsQualityValue.textContent = "Medium";
            else graphicsQualityValue.textContent = "High";
        });
        
        uploadInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                const url = URL.createObjectURL(e.target.files[0]);
                loadImage(url);
            }
        });

        document.body.addEventListener('dragover', (e) => e.preventDefault());
        document.body.addEventListener('drop', (e) => {
            e.preventDefault();
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                const url = URL.createObjectURL(e.dataTransfer.files[0]);
                loadImage(url);
            }
        });
    }
    
    function changeKernelSize(size) {
        currentKernelSize = size;
        uniforms.uKernelSize.value = size;

        // Update UI
        document.querySelectorAll('#kernel-size-selector button').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.size) === size);
        });
        document.getElementById('presets-container').style.display = (size === 3) ? 'flex' : 'none';

        // Rebuild grids and visualizations
        rebuildKernelUI(size);
        rebuildKernelViz(size);
        rebuildLineGeometries(size);

        // Set to identity kernel
        const kernel = new Float32Array(size * size).fill(0);
        const center = Math.floor(size*size / 2);
        kernel[center] = 1;
        kernelInputs[center].value = 1;
        document.getElementById('divisor-input').value = 1;
        document.getElementById('offset-input').value = 0;
        updateFromUI();
    }

    function rebuildKernelUI(size) {
        const grid = document.getElementById('kernel-grid');
        grid.innerHTML = '';
        kernelInputs.length = 0;
        grid.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
        for (let i = 0; i < size * size; i++) {
            const input = document.createElement('input');
            input.type = 'number';
            input.step = '0.1';
            input.value = 0;
            input.addEventListener('input', updateFromUI);
            grid.appendChild(input);
            kernelInputs.push(input);
        }
    }

    function rebuildKernelViz(size) {
        while(kernelViz.children.length) kernelViz.remove(kernelViz.children[0]);
        const radius = (size - 1) / 2;
        const boxGeo = new THREE.BoxGeometry(0.1, 1, 0.1);
        for(let i=0; i < size * size; i++) {
            const mat = new THREE.MeshBasicMaterial({color: 0xffffff});
            const cube = new THREE.Mesh(boxGeo, mat);
            const row = Math.floor(i / size);
            const col = i % size;
            cube.position.set((col - radius) * 0.12, 0, (row - radius) * 0.12);
            kernelViz.add(cube);
        }
    }

    function rebuildLineGeometries(size) {
        const numPoints = size * size;
        convolutionLines.geometry.dispose();
        outputLine.geometry.dispose();

        let points = new Float32Array(numPoints * 2 * 3);
        convolutionLines.geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(points, 3));
        
        points = new Float32Array(1 * 2 * 3);
        outputLine.geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(points, 3));
    }
    
    function applyPreset(key) {
        if (currentKernelSize !== 3) return;
        const preset = presets[key];
        preset.kernel.forEach((val, i) => kernelInputs[i].value = val);
        document.getElementById('divisor-input').value = preset.divisor;
        document.getElementById('offset-input').value = preset.offset;
        document.querySelectorAll('#presets-container button').forEach(btn => btn.classList.toggle('active', btn.dataset.key === key));
        updateFromUI();
    }
    
    function updateFromUI() {
        const size = currentKernelSize;
        const newKernel = new Float32Array(MAX_KERNEL_SIZE * MAX_KERNEL_SIZE).fill(0);
        let activeKernel = [];
        for(let i = 0; i < size * size; i++) {
            const val = parseFloat(kernelInputs[i].value) || 0;
            newKernel[i] = val;
            activeKernel.push(val);
        }
        
        uniforms.uKernel.value = newKernel;
        uniforms.uDivisor.value = parseFloat(document.getElementById('divisor-input').value) || 1.0;
        uniforms.uOffset.value = parseFloat(document.getElementById('offset-input').value) || 0.0;
        if(currentKernelSize === 3) {
           document.querySelectorAll('#presets-container button').forEach(btn => btn.classList.remove('active'));
        }
        updateKernelViz(activeKernel);
    }

    function updateKernelViz(kernel) {
        let maxVal = 0;
        kernel.forEach(v => maxVal = Math.max(maxVal, Math.abs(v)));
        maxVal = Math.max(maxVal, 1.0);

        kernelViz.children.forEach((cube, i) => {
            const value = kernel[i];
            cube.scale.y = Math.abs(value);
            cube.position.y = value * 0.5;
            const hue = value < 0 ? 0.66 : 0.0;
            const saturation = Math.abs(value) / maxVal;
            cube.material.color.setHSL(hue, saturation, 0.55);
        });
    }

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }
    
    function updateRaycaster() {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(inputPlane);

        if(intersects.length > 0 && heightData) {
            const intersect = intersects[0];
            const point = intersect.point;
            const uv = intersect.uv;
            
            kernelViz.visible = true;
            convolutionLines.visible = true;
            outputLine.visible = true;

            const ix = Math.floor(uv.x * imageDimensions.width);
            const iy = Math.floor((1 - uv.y) * imageDimensions.height);
            const centerHeight = heightData[iy * imageDimensions.width + ix] || 0;

            kernelViz.position.set(point.x, centerHeight * MESH_DISPLACEMENT_SCALE + 0.1, point.z);
            
            const stepX = inputPlane.geometry.parameters.width / imageDimensions.width;
            const stepZ = inputPlane.geometry.parameters.height / imageDimensions.height;
            
            const linePos = convolutionLines.geometry.attributes.position;
            const outPos = outputLine.geometry.attributes.position;
            let lineIdx = 0;
            let outputGrayValue = 0;
            const size = currentKernelSize;
            const radius = (size - 1) / 2;

            for(let i=0; i < size*size; i++) {
                const cube = kernelViz.children[i];
                cube.getWorldPosition(tempVec);
                linePos.setXYZ(lineIdx, tempVec.x, tempVec.y, tempVec.z);
                
                const d_row = Math.floor(i / size) - radius;
                const d_col = (i % size) - radius;

                const nx = ix + d_col;
                const ny = iy + d_row;

                let neighborHeight = 0;
                if (nx >= 0 && nx < imageDimensions.width && ny >= 0 && ny < imageDimensions.height) {
                    neighborHeight = heightData[ny * imageDimensions.width + nx];
                }
                outputGrayValue += neighborHeight * uniforms.uKernel.value[i];

                linePos.setXYZ(lineIdx + 1, point.x + d_col * stepX, neighborHeight * MESH_DISPLACEMENT_SCALE, point.z - d_row * stepZ);
                lineIdx += 2;
            }
            linePos.needsUpdate = true;
            
            outputGrayValue = (outputGrayValue / uniforms.uDivisor.value) + uniforms.uOffset.value;
            outputGrayValue = Math.max(0, Math.min(1, outputGrayValue)); // clamp

            const centerIndex = Math.floor(size*size / 2);
            kernelViz.children[centerIndex].getWorldPosition(tempVec);
            outPos.setXYZ(0, tempVec.x, tempVec.y, tempVec.z);
            outPos.setXYZ(1, point.x, outputGrayValue * MESH_DISPLACEMENT_SCALE, outputPlane.position.z);
            outPos.needsUpdate = true;
            
        } else {
            kernelViz.visible = false;
            convolutionLines.visible = false;
            outputLine.visible = false;
        }
    }

    function onWindowResize() { 
        camera.aspect = window.innerWidth / window.innerHeight; 
        camera.updateProjectionMatrix(); 
        renderer.setSize(window.innerWidth, window.innerHeight); 
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() { 
        controls.update(); 
        updateRaycaster();
        renderer.render(scene, camera); 
        labelRenderer.render(scene, camera);
    }
    
    init();
</script>
</body>
</html>

