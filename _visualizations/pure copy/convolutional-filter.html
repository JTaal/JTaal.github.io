<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Convolutional Filter Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #111827;
            color: #e5e7eb;
        }
        .ui-panel {
            position: absolute;
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(8px);
            padding: 1.25rem;
            border: 1px solid rgba(55, 65, 81, 0.7);
            transition: all 0.5s ease-in-out;
            z-index: 10;
        }
        .hidden { display: none !important; }
        #info-panel {
            top: 80px;
            left: 20px;
            max-width: 420px;
            cursor: pointer;
            overflow: hidden;
            border-radius: 12px;
            max-height: 58px;
        }
        #info-panel.expanded {
            max-height: 90vh; 
            cursor: default;
            overflow-y: auto;
            z-index: 11;
        }
        #info-header { display: flex; justify-content: space-between; align-items: center; }
        #toggle-icon { transition: transform 0.3s ease-in-out; }
        #info-panel.expanded #toggle-icon { transform: rotate(180deg); }
        .formula-placeholder {
            font-family: 'monospace';
            background-color: #1f2937;
            padding: 1rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            margin-top: 1rem;
            color: #d1d5db;
            border: 1px solid #374151;
            white-space: pre;
        }
        #controls-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            border-radius: 12px 12px 0 0;
            padding: 1.5rem;
            padding-top: 2rem;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 1.5rem;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #controls-panel.collapsed {
            transform: translateY(calc(100% - 40px));
        }
        #collapse-toggle {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 5rem;
            height: 2rem;
            background-color: rgba(31, 41, 55, 0.9);
            border: 1px solid rgba(55, 65, 81, 0.9);
            border-bottom: none;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        #collapse-icon { transition: transform 0.3s ease-in-out; }
        #controls-panel.collapsed #collapse-icon { transform: rotate(180deg); }
        #controls-wrapper {
            transition: opacity 0.2s ease-in-out;
            width: 100%;
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            align-items: center;
            justify-content: flex-start;
            gap: 1.5rem;
            padding-bottom: 1rem;
        }
        #controls-wrapper::-webkit-scrollbar { height: 8px; }
        #controls-wrapper::-webkit-scrollbar-track { background: rgba(31, 41, 55, 0.5); border-radius: 4px; }
        #controls-wrapper::-webkit-scrollbar-thumb { background-color: #4f46e5; border-radius: 4px; }
        #controls-wrapper::-webkit-scrollbar-thumb:hover { background-color: #6366f1; }
        #controls-panel.collapsed #controls-wrapper { opacity: 0; pointer-events: none; }
        header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background-color: rgba(3, 7, 18, 0.5);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(55, 65, 81, 0.7);
        }
        .menu-button {
            background-color: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            font-weight: 500;
            font-size: 0.875rem;
            white-space: nowrap;
        }
        .menu-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px);
        }
        .menu-button.active {
            background-color: #4f46e5;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
        }
        .menu-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            background-color: rgba(55, 65, 81, 0.8);
        }
        select {
             background-color: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.875rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2220%22%20height%3D%2220%22%20fill%3D%22%239ca3af%22%3E%3Cpath%20d%3D%22M7%2010l5%205%205-5z%22/%3E%3C/svg%3E');
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.2em;
            padding-right: 2.5rem;
        }
        input[type="number"] {
            -moz-appearance: textfield;
            background-color: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 6px;
            color: white;
            text-align: center;
            padding: 0.25rem;
            width: 45px;
            height: 45px;
            font-size: 1rem;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0;
        }
        #kernel-grid {
            display: grid;
            gap: 5px;
        }
        .canvas-label {
            position: absolute;
            color: #9ca3af;
            background: rgba(17, 24, 39, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
        }
        #calculation-panel {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            font-family: 'monospace';
            font-size: 0.8rem;
            line-height: 1.4;
            color: #d1d5db;
            text-shadow: 1px 1px 2px #000;
        }
        .calc-line {
            display: inline-block;
            margin-right: 5px;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .calc-line.highlight {
            background-color: rgba(79, 70, 229, 0.7);
        }
        #settings-button {
            position: absolute;
            top: 80px;
            right: 20px;
            background-color: rgba(55, 65, 81, 0.8);
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 11;
        }
        #settings-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px) rotate(45deg);
        }
        #settings-panel {
            top: 80px;
            right: 0;
            width: 300px;
            border-radius: 12px 0 0 12px;
            transform: translateX(100%);
            z-index: 12;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }
        #settings-panel.open {
            transform: translateX(0);
        }
        
        @media (max-width: 768px) {
            #settings-button { top: 70px; right: 10px; }
            #settings-panel { top: 70px; width: 280px; max-height: calc(100vh - 80px);}
        }
    </style>
</head>
<body>
    <header>
        <h1 class="text-xl font-bold text-gray-200 tracking-wider opacity-90">3D Convolutional Filter Visualizer</h1>
    </header>

    <div id="info-panel" class="ui-panel">
        <div id="info-header">
            <h2 class="text-xl font-bold text-indigo-400">What is a Convolutional Filter?</h2>
            <div id="toggle-icon" class="text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg></div>
        </div>
        <div id="info-content" class="pt-4 space-y-3">
             <p class="text-gray-300">This 3D visualization shows how a kernel (the floating cubes) processes an input image to create an output. Each cube's height represents its value. As you hover, lines show the neighboring input pixels being multiplied and summed to produce one output pixel.</p>
             <div class="formula-placeholder">NewPixel = Σ(Neighbor × KernelValue)</div>
        </div>
    </div>
    
    <div id="controls-panel" class="ui-panel">
        <button id="collapse-toggle">
            <svg id="collapse-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
        </button>
        <div id="controls-wrapper">
            <div class="control-group">
                 <label class="text-sm font-medium">Kernel Size</label>
                 <div id="kernel-size-selector" class="flex gap-2"></div>
            </div>
            <div id="presets-container" class="control-group">
                <label for="presets-select" class="text-sm font-medium">Presets</label>
                <select id="presets-select"></select>
            </div>
            <div class="control-group">
                <label class="text-sm font-medium mb-1">Kernel Matrix</label>
                <div id="kernel-grid"></div>
            </div>
            <div class="control-group">
                <div class="flex flex-col gap-4">
                    <div class="control-group"><label for="divisor-input" class="text-sm font-medium">Divisor</label><input id="divisor-input" type="number" value="1" step="0.1" class="w-20 h-10"></div>
                    <div class="control-group"><label for="offset-input" class="text-sm font-medium">Offset</label><input id="offset-input" type="number" value="0" step="0.1" class="w-20 h-10"></div>
                </div>
            </div>
            <div class="control-group">
                <label for="animation-speed-slider" class="text-sm font-medium">Animation Speed</label>
                <input id="animation-speed-slider" type="range" min="0" max="100" value="50">
            </div>
             <button id="convolve-button" class="menu-button self-end">Animate Convolution</button>
        </div>
    </div>
    
    <div id="calculation-panel" class="ui-panel hidden"></div>

    <button id="settings-button" title="Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0 2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
    </button>
    
    <div id="settings-panel" class="ui-panel hidden">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-xl font-bold text-gray-200">Settings</h3>
            <button id="close-settings" class="text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
        </div>
        <div class="space-y-6">
             <div class="control-group text-left w-full">
                <label for="graphics-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Graphics Quality:</span>
                    <span id="graphics-quality-value">High</span>
                </label>
                <input id="graphics-slider" type="range" min="0.5" max="2" step="0.1" value="1.5" class="w-full">
               <div class="text-xs text-gray-500 w-full flex justify-between mt-1">
                   <span>Low</span><span>Native</span><span>High</span>
               </div>
            </div>
             <div class="control-group text-left w-full">
                <label class="text-sm font-medium self-start w-full">Upload Image</label>
                <input type="file" id="image-upload" accept="image/*" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 cursor-pointer">
            </div>
        </div>
    </div>


<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { CSS2DObject, CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer.js';

    const MAX_KERNEL_SIZE = 9;
    let currentKernelSize = 3;

    let scene, camera, renderer, controls, labelRenderer, raycaster;
    let inputPlane, outputPlane, kernelViz, textureLoader;
    let outputDataTexture, animatedMaterial;
    const kernelInputs = [];
    const mouse = new THREE.Vector2(1,1);
    let convolutionLines, outputLine;
    const tempVec = new THREE.Vector3();
    let heightData = null, imageDimensions = { width: 0, height: 0 };
    const MESH_DISPLACEMENT_SCALE = 0.2;

    let isAnimating = false;
    let animState = { x: 0, y: 0, kernelIdx: 0, timeout: 50 };

    const uniforms = {
        uTexture: { value: null },
        uKernel: { value: new Float32Array(MAX_KERNEL_SIZE * MAX_KERNEL_SIZE) },
        uKernelSize: { value: 3 },
        uDivisor: { value: 1.0 },
        uOffset: { value: 0.0 },
        uTexelSize: { value: new THREE.Vector2() }
    };
    
    const presets = {
        '3': {
            identity: { name: 'Identity', kernel: [0,0,0, 0,1,0, 0,0,0], divisor: 1, offset: 0 },
            sharpen: { name: 'Sharpen', kernel: [0,-1,0, -1,5,-1, 0,-1,0], divisor: 1, offset: 0 },
            sharpen_more: { name: 'Sharpen More', kernel: [-1,-1,-1, -1,9,-1, -1,-1,-1], divisor: 1, offset: 0 },
            box_blur: { name: 'Box Blur', kernel: [1,1,1, 1,1,1, 1,1,1], divisor: 9, offset: 0 },
            edge_detect: { name: 'Edge Detect', kernel: [-1,-1,-1, -1,8,-1, -1,-1,-1], divisor: 1, offset: 0 },
            emboss: { name: 'Emboss', kernel: [-2,-1,0, -1,1,1, 0,1,2], divisor: 1, offset: 0.5 },
            sobel_h: { name: 'Sobel Horizontal', kernel: [1,2,1, 0,0,0, -1,-2,-1], divisor: 1, offset: 0.5 },
            sobel_v: { name: 'Sobel Vertical', kernel: [1,0,-1, 2,0,-2, 1,0,-1], divisor: 1, offset: 0.5 },
        },
        '5': {
            identity: { name: 'Identity', kernel: Array(25).fill(0).map((_, i) => i === 12 ? 1 : 0), divisor: 1, offset: 0 },
            gaussian_blur: { name: 'Gaussian Blur 5x5', kernel: [1,4,7,4,1, 4,16,26,16,4, 7,26,41,26,7, 4,16,26,16,4, 1,4,7,4,1], divisor: 273, offset: 0 },
            unsharp_mask: { name: 'Unsharp Masking', kernel: [1,4,6,4,1, 4,16,24,16,4, 6,24,-476,24,6, 4,16,24,16,4, 1,4,6,4,1], divisor: -256, offset: 0 },
            motion_blur: { name: 'Motion Blur', kernel: [1,0,0,0,0, 0,1,0,0,0, 0,0,1,0,0, 0,0,0,1,0, 0,0,0,0,1], divisor: 5, offset: 0 },
        },
        '7': {
            identity: { name: 'Identity', kernel: Array(49).fill(0).map((_, i) => i === 24 ? 1 : 0), divisor: 1, offset: 0 },
            gaussian_blur: { name: 'Gaussian Blur 7x7', kernel: [1,1,2,2,2,1,1, 1,2,5,5,5,2,1, 2,5,12,15,12,5,2, 2,5,15,20,15,5,2, 2,5,12,15,12,5,2, 1,2,5,5,5,2,1, 1,1,2,2,2,1,1], divisor: 220, offset: 0 },
            lens_blur: { name: 'Lens Blur', kernel: [0,0,1,1,1,0,0, 0,1,1,1,1,1,0, 1,1,1,1,1,1,1, 1,1,1,1,1,1,1, 1,1,1,1,1,1,1, 0,1,1,1,1,1,0, 0,0,1,1,1,0,0], divisor: 33, offset: 0 },
        }
    };

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 4, 7);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        document.body.appendChild(labelRenderer.domElement);

        controls = new OrbitControls(camera, labelRenderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0);

        raycaster = new THREE.Raycaster();
        textureLoader = new THREE.TextureLoader();

        setupUI();
        initVisualizer();
        setupSettingsPanel();
        
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('mousemove', onMouseMove);
        renderer.setAnimationLoop(animate);
    }

    function initVisualizer() {
        const PLANE_SIZE = 4;
        const SEGMENTS = 128;
        const geometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE, SEGMENTS, SEGMENTS);
        const planeMaterial = new THREE.ShaderMaterial({
            uniforms: { uTexture: { value: null } },
            vertexShader: `
                uniform sampler2D uTexture;
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    vec4 tex = texture2D(uTexture, uv);
                    float height = (tex.r + tex.g + tex.b) / 3.0;
                    vec3 displaced = position + normal * height * ${MESH_DISPLACEMENT_SCALE};
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture;
                varying vec2 vUv;
                void main() {
                    gl_FragColor = texture2D(uTexture, vUv);
                }
            `,
        });

        inputPlane = new THREE.Mesh(geometry, planeMaterial.clone());
        inputPlane.rotation.x = -Math.PI / 2;
        inputPlane.position.z = -2.2;
        scene.add(inputPlane);
        createLabel(inputPlane, 'Input Image', new THREE.Vector3(0, 0, -2.1));
        
        const filteredMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: planeMaterial.vertexShader,
            fragmentShader: `
                uniform sampler2D uTexture;
                uniform float uKernel[${MAX_KERNEL_SIZE * MAX_KERNEL_SIZE}];
                uniform int uKernelSize;
                uniform float uDivisor;
                uniform float uOffset;
                uniform vec2 uTexelSize;
                varying vec2 vUv;
                void main() {
                    vec4 sum = vec4(0.0);
                    int radius = (uKernelSize - 1) / 2;
                    for (int i = 0; i < ${MAX_KERNEL_SIZE}; i++) {
                        if (i >= uKernelSize) break;
                        for (int j = 0; j < ${MAX_KERNEL_SIZE}; j++) {
                             if (j >= uKernelSize) break;
                             vec2 offset = vec2(float(j - radius), float(radius - i));
                             sum += texture2D(uTexture, vUv + uTexelSize * offset) * uKernel[i * uKernelSize + j];
                        }
                    }
                    gl_FragColor = vec4((sum/uDivisor + uOffset).rgb, 1.0);
                }
            `,
        });
        
        outputPlane = new THREE.Mesh(geometry, filteredMaterial);
        outputPlane.rotation.x = -Math.PI / 2;
        outputPlane.position.z = 2.2;
        scene.add(outputPlane);
        createLabel(outputPlane, 'Output Image', new THREE.Vector3(0, 0, 2.1));
        
        kernelViz = new THREE.Group();
        scene.add(kernelViz);
        
        const lineMat = new THREE.LineBasicMaterial({color: 0x6366f1, transparent: true, opacity: 0.7});
        const outLineMat = new THREE.LineBasicMaterial({color: 0x10b981, transparent: true, opacity: 0.9, linewidth: 2});
        convolutionLines = new THREE.LineSegments(new THREE.BufferGeometry(), lineMat);
        scene.add(convolutionLines);
        outputLine = new THREE.LineSegments(new THREE.BufferGeometry(), outLineMat);
        scene.add(outputLine);

        loadImage('https://placehold.co/256x256/d1d5db/1f2937?text=Drop+Image');
        changeKernelSize(3);
    }
    
    function createLabel(object, text, offset) {
        const div = document.createElement('div');
        div.className = 'canvas-label';
        div.textContent = text;
        const label = new CSS2DObject(div);
        label.position.copy(offset);
        object.add(label);
    }
    
    function loadImage(url) {
        textureLoader.load(url, (texture) => {
            texture.colorSpace = THREE.SRGBColorSpace;
            inputPlane.material.uniforms.uTexture.value = texture;
            outputPlane.material.uniforms.uTexture.value = texture;
            outputPlane.material.uniforms.uTexelSize.value.set(1/texture.image.width, 1/texture.image.height);
            
            const img = texture.image;
            imageDimensions.width = img.width;
            imageDimensions.height = img.height;
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, img.width, img.height).data;
            heightData = new Float32Array(img.width * img.height);
            for(let i = 0; i < data.length; i+=4) {
                const gray = (data[i] + data[i+1] + data[i+2]) / 3 / 255;
                heightData[i/4] = gray;
            }
        });
    }

    function setupUI() {
        document.getElementById('collapse-toggle').addEventListener('click', () => {
            document.getElementById('controls-panel').classList.toggle('collapsed');
        });
        
        document.getElementById('divisor-input').addEventListener('input', updateFromUI);
        document.getElementById('offset-input').addEventListener('input', updateFromUI);

        const sizeSelector = document.getElementById('kernel-size-selector');
        [3, 5, 7].forEach(size => {
            const button = document.createElement('button');
            button.className = 'menu-button';
            button.textContent = `${size}x${size}`;
            button.dataset.size = size;
            button.addEventListener('click', () => changeKernelSize(size));
            sizeSelector.appendChild(button);
        });
        
        document.getElementById('presets-select').addEventListener('change', (e) => applyPreset(e.target.value));
        document.getElementById('convolve-button').addEventListener('click', toggleConvolutionAnimation);

        const animSpeedSlider = document.getElementById('animation-speed-slider');
        animSpeedSlider.addEventListener('input', (e) => {
            const speed = 100 - parseInt(e.target.value, 10);
            animState.timeout = speed;
        });

        document.getElementById('info-panel').addEventListener('click', (e) => e.currentTarget.classList.add('expanded'));
        document.getElementById('toggle-icon').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('info-panel').classList.toggle('expanded');
        });
    }

    function setupSettingsPanel() {
        const settingsPanel = document.getElementById('settings-panel');
        const settingsButton = document.getElementById('settings-button');
        const closeSettingsButton = document.getElementById('close-settings');
        const graphicsSlider = document.getElementById('graphics-slider');
        const graphicsQualityValue = document.getElementById('graphics-quality-value');
        const uploadInput = document.getElementById('image-upload');

        settingsButton.addEventListener('click', () => {
            settingsPanel.classList.remove('hidden');
            requestAnimationFrame(() => settingsPanel.classList.add('open'));
        });
        closeSettingsButton.addEventListener('click', () => settingsPanel.classList.remove('open'));
        
        settingsPanel.addEventListener('transitionend', () => {
            if (!settingsPanel.classList.contains('open')) settingsPanel.classList.add('hidden');
        });

        graphicsSlider.addEventListener('input', (e) => {
            const quality = parseFloat(e.target.value);
            renderer.setPixelRatio(quality);
            if (quality < 0.8) graphicsQualityValue.textContent = "Low";
            else if (quality < 1.5) graphicsQualityValue.textContent = "Medium";
            else graphicsQualityValue.textContent = "High";
        });
        
        uploadInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                const url = URL.createObjectURL(e.target.files[0]);
                loadImage(url);
            }
        });

        document.body.addEventListener('dragover', (e) => e.preventDefault());
        document.body.addEventListener('drop', (e) => {
            e.preventDefault();
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                const url = URL.createObjectURL(e.dataTransfer.files[0]);
                loadImage(url);
            }
        });
    }
    
    function changeKernelSize(size) {
        if(isAnimating) return;
        currentKernelSize = size;
        uniforms.uKernelSize.value = size;

        document.querySelectorAll('#kernel-size-selector button').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.size) === size);
        });
        
        updatePresetDropdown(size);
        rebuildKernelUI(size);
        rebuildKernelViz(size);
        rebuildLineGeometries(size);
        
        applyPreset('identity');
    }

    function updatePresetDropdown(size) {
        const select = document.getElementById('presets-select');
        select.innerHTML = '';
        
        const customOption = document.createElement('option');
        customOption.value = 'custom';
        customOption.textContent = 'Custom';
        select.appendChild(customOption);

        const sizePresets = presets[size];
        if (!sizePresets) return;

        Object.keys(sizePresets).forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = sizePresets[key].name;
            select.appendChild(option);
        });
    }

    function rebuildKernelUI(size) {
        const grid = document.getElementById('kernel-grid');
        grid.innerHTML = '';
        kernelInputs.length = 0;
        grid.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
        for (let i = 0; i < size * size; i++) {
            const input = document.createElement('input');
            input.type = 'number';
            input.step = '0.1';
            input.value = 0;
            input.addEventListener('input', () => updateFromUI(true));
            grid.appendChild(input);
            kernelInputs.push(input);
        }
    }

    function rebuildKernelViz(size) {
        while(kernelViz.children.length) kernelViz.remove(kernelViz.children[0]);
        const radius = (size - 1) / 2;
        const boxGeo = new THREE.BoxGeometry(0.1, 1, 0.1);
        for(let i=0; i < size * size; i++) {
            const mat = new THREE.MeshBasicMaterial({color: 0xffffff});
            const cube = new THREE.Mesh(boxGeo, mat);
            const row = Math.floor(i / size);
            const col = i % size;
            cube.position.set((col - radius) * 0.12, 0, (row - radius) * 0.12);
            kernelViz.add(cube);
        }
    }

    function rebuildLineGeometries(size) {
        const numPoints = size * size;
        convolutionLines.geometry.dispose();
        outputLine.geometry.dispose();

        let points = new Float32Array(numPoints * 2 * 3);
        convolutionLines.geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(points, 3));
        
        points = new Float32Array(1 * 2 * 3);
        outputLine.geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(points, 3));
    }
    
    function applyPreset(key) {
        if (key === 'custom') return;
        const preset = presets[currentKernelSize]?.[key];
        if (!preset) { // Handle identity for sizes without specific presets
            changeKernelSize(currentKernelSize); // Resets to identity
            return;
        };
        
        preset.kernel.forEach((val, i) => {
             if(kernelInputs[i]) kernelInputs[i].value = val
        });
        document.getElementById('divisor-input').value = preset.divisor;
        document.getElementById('offset-input').value = preset.offset;
        document.getElementById('presets-select').value = key;
        updateFromUI(false);
    }
    
    function updateFromUI(fromInput = true) {
        const size = currentKernelSize;
        const newKernel = new Float32Array(MAX_KERNEL_SIZE * MAX_KERNEL_SIZE).fill(0);
        let activeKernel = [];
        for(let i = 0; i < size * size; i++) {
            const val = parseFloat(kernelInputs[i].value) || 0;
            newKernel[i] = val;
            activeKernel.push(val);
        }
        
        uniforms.uKernel.value = newKernel;
        uniforms.uDivisor.value = parseFloat(document.getElementById('divisor-input').value) || 1.0;
        uniforms.uOffset.value = parseFloat(document.getElementById('offset-input').value) || 0.0;
        
        if (fromInput) {
            document.getElementById('presets-select').value = 'custom';
        }
        
        updateKernelViz(activeKernel);
    }

    function updateKernelViz(kernel) {
        let maxVal = 0;
        kernel.forEach(v => maxVal = Math.max(maxVal, Math.abs(v)));
        maxVal = Math.max(maxVal, 1.0);

        kernelViz.children.forEach((cube, i) => {
            const value = kernel[i];
            cube.scale.y = Math.abs(value);
            cube.position.y = value * 0.5;
            const hue = value < 0 ? 0.66 : 0.0;
            const saturation = Math.abs(value) / maxVal;
            cube.material.color.setHSL(hue, saturation, 0.55);
        });
    }

    function onMouseMove(event) {
        if(isAnimating) return;
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    function updateFromRaycaster() {
        if(isAnimating) return;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(inputPlane);

        if(intersects.length > 0 && heightData) {
            const intersect = intersects[0];
            const point = intersect.point;
            const uv = intersect.uv;
            
            kernelViz.visible = true;
            convolutionLines.visible = true;
            outputLine.visible = true;
            
            updateKernelAndLines(uv, point);
            
        } else {
            kernelViz.visible = false;
            convolutionLines.visible = false;
            outputLine.visible = false;
        }
    }
    
    function updateKernelAndLines(uv, point) {
        const ix = Math.floor(uv.x * imageDimensions.width);
        const iy = Math.floor((1 - uv.y) * imageDimensions.height);
        const centerHeight = heightData[iy * imageDimensions.width + ix] || 0;

        kernelViz.position.set(point.x, centerHeight * MESH_DISPLACEMENT_SCALE + 0.1, point.z);
        
        const stepX = inputPlane.geometry.parameters.width / imageDimensions.width;
        const stepZ = inputPlane.geometry.parameters.height / imageDimensions.height;
        
        const linePos = convolutionLines.geometry.attributes.position;
        const outPos = outputLine.geometry.attributes.position;
        let lineIdx = 0;
        let outputGrayValue = 0;
        const size = currentKernelSize;
        const radius = (size - 1) / 2;

        for(let i=0; i < size*size; i++) {
            const cube = kernelViz.children[i];
            cube.getWorldPosition(tempVec);
            linePos.setXYZ(lineIdx, tempVec.x, tempVec.y, tempVec.z);
            
            const d_row = Math.floor(i / size) - radius;
            const d_col = (i % size) - radius;

            const nx = ix + d_col;
            const ny = iy + d_row;

            let neighborHeight = 0;
            if (nx >= 0 && nx < imageDimensions.width && ny >= 0 && ny < imageDimensions.height) {
                neighborHeight = heightData[ny * imageDimensions.width + nx];
            }
            outputGrayValue += neighborHeight * uniforms.uKernel.value[i];

            linePos.setXYZ(lineIdx + 1, point.x + d_col * stepX, neighborHeight * MESH_DISPLACEMENT_SCALE, point.z - d_row * stepZ);
            lineIdx += 2;
        }
        linePos.needsUpdate = true;
        
        outputGrayValue = (outputGrayValue / uniforms.uDivisor.value) + uniforms.uOffset.value;
        outputGrayValue = Math.max(0, Math.min(1, outputGrayValue)); // clamp

        const centerIndex = Math.floor(size*size / 2);
        kernelViz.children[centerIndex].getWorldPosition(tempVec);
        outPos.setXYZ(0, tempVec.x, tempVec.y, tempVec.z);
        outPos.setXYZ(1, point.x, outputGrayValue * MESH_DISPLACEMENT_SCALE, outputPlane.position.z);
        outPos.needsUpdate = true;
    }

    // --- Animation Logic ---
    
    function toggleConvolutionAnimation() {
        if(isAnimating) {
            stopConvolutionAnimation();
        } else {
            startConvolutionAnimation();
        }
    }
    
    function startConvolutionAnimation() {
        if(!heightData) return;
        isAnimating = true;
        
        document.getElementById('controls-wrapper').style.pointerEvents = 'none';
        document.getElementById('controls-wrapper').style.opacity = '0.5';
        const convolveBtn = document.getElementById('convolve-button');
        convolveBtn.textContent = 'Cancel Animation';
        convolveBtn.classList.add('active');

        controls.enabled = false;
        
        const data = new Uint8Array(imageDimensions.width * imageDimensions.height * 4);
        outputDataTexture = new THREE.DataTexture(data, imageDimensions.width, imageDimensions.height);
        outputDataTexture.colorSpace = THREE.SRGBColorSpace;

        animatedMaterial = new THREE.MeshBasicMaterial({ map: outputDataTexture });
        outputPlane.material = animatedMaterial;

        animState = { x: 0, y: 0, kernelIdx: 0, sum: 0, terms: [] };
        
        kernelViz.visible = true;
        convolutionLines.visible = true;
        outputLine.visible = true;

        document.getElementById('calculation-panel').classList.remove('hidden');

        requestAnimationFrame(convolutionStep);
    }

    function stopConvolutionAnimation() {
        isAnimating = false;
        document.getElementById('controls-wrapper').style.pointerEvents = 'auto';
        document.getElementById('controls-wrapper').style.opacity = '1';
        const convolveBtn = document.getElementById('convolve-button');
        convolveBtn.textContent = 'Animate Convolution';
        convolveBtn.classList.remove('active');

        controls.enabled = true;
        outputPlane.material = outputPlane.geometry.attributes.position.count > 0 ? outputPlane.material.clone() : new THREE.MeshBasicMaterial();
        outputPlane.material.uniforms = uniforms;
        outputPlane.material.needsUpdate = true;
        
        kernelViz.visible = false;
        convolutionLines.visible = false;
        outputLine.visible = false;
        document.getElementById('calculation-panel').classList.add('hidden');
    }

    function convolutionStep() {
        if (!isAnimating) return;

        const { width, height } = imageDimensions;
        const size = currentKernelSize;
        const radius = (size - 1) / 2;

        // --- Calculation for one kernel element ---
        const d_row = Math.floor(animState.kernelIdx / size) - radius;
        const d_col = (animState.kernelIdx % size) - radius;
        const nx = animState.x + d_col;
        const ny = animState.y + d_row;

        let neighborHeight = 0;
        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            neighborHeight = heightData[ny * width + nx];
        }
        
        const kernelValue = uniforms.uKernel.value[animState.kernelIdx];
        const term = neighborHeight * kernelValue;
        animState.sum += term;
        animState.terms.push({val: neighborHeight, kernel: kernelValue, term});

        // --- Update visualizations ---
        const uv = new THREE.Vector2((animState.x + 0.5) / width, 1 - (animState.y + 0.5) / height);
        const planePoint = new THREE.Vector3( (uv.x - 0.5) * inputPlane.geometry.parameters.width, 0, (uv.y - 0.5) * inputPlane.geometry.parameters.height);
        planePoint.z *= -1; // Correct for plane orientation
        updateKernelAndLines(uv, planePoint);
        updateCalculationPanel();

        camera.position.lerp(new THREE.Vector3(planePoint.x, 3, planePoint.z + 4), 0.1);
        controls.target.lerp(planePoint, 0.1);

        // --- Move to next state ---
        animState.kernelIdx++;
        if (animState.kernelIdx >= size * size) {
            // --- Finalize pixel ---
            let finalValue = (animState.sum / uniforms.uDivisor.value) + uniforms.uOffset.value;
            finalValue = Math.floor(Math.max(0, Math.min(1, finalValue)) * 255);
            
            const dataIdx = (animState.y * width + animState.x) * 4;
            outputDataTexture.image.data[dataIdx] = finalValue;
            outputDataTexture.image.data[dataIdx + 1] = finalValue;
            outputDataTexture.image.data[dataIdx + 2] = finalValue;
            outputDataTexture.image.data[dataIdx + 3] = 255;
            outputDataTexture.needsUpdate = true;

            // --- Move to next pixel ---
            animState.kernelIdx = 0;
            animState.sum = 0;
            animState.terms = [];
            animState.x++;
            if (animState.x >= width) {
                animState.x = 0;
                animState.y++;
                if (animState.y >= height) {
                    stopConvolutionAnimation();
                    return;
                }
            }
        }
        
        setTimeout(() => requestAnimationFrame(convolutionStep), animState.timeout);
    }

    function updateCalculationPanel() {
        const panel = document.getElementById('calculation-panel');
        let html = '';
        animState.terms.forEach((t, i) => {
            const highlight = (i === animState.terms.length - 1) ? 'highlight' : '';
            html += `<span class="calc-line ${highlight}">(${t.val.toFixed(2)}*${t.kernel.toFixed(1)})</span> + `;
        });
        html = html.slice(0, -2); // remove trailing +
        html += `= ${animState.sum.toFixed(2)}`;
        panel.innerHTML = html;
    }


    function onWindowResize() { 
        camera.aspect = window.innerWidth / window.innerHeight; 
        camera.updateProjectionMatrix(); 
        renderer.setSize(window.innerWidth, window.innerHeight); 
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() { 
        controls.update(); 
        if(!isAnimating) {
           updateFromRaycaster();
        }
        renderer.render(scene, camera); 
        labelRenderer.render(scene, camera);
    }
    
    init();
</script>
</body>
</html>

