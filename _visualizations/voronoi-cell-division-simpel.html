<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Logistic Map Cell Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #030712;
            color: #e5e7eb;
        }
        .ui-panel {
            position: absolute;
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(8px);
            padding: 1.25rem;
            border: 1px solid rgba(55, 65, 81, 0.7);
            transition: all 0.5s ease-in-out;
            z-index: 10;
        }
        #info-panel {
            top: 80px;
            left: 20px;
            max-width: 420px;
            cursor: pointer;
            overflow: hidden;
            border-radius: 12px;
            max-height: 58px;
        }
        #info-panel.expanded {
            max-height: 90vh; 
            cursor: default;
            overflow-y: auto;
            z-index: 11;
        }
        #info-header { display: flex; justify-content: space-between; align-items: center; }
        #toggle-icon { transition: transform 0.3s ease-in-out; }
        #info-panel.expanded #toggle-icon { transform: rotate(180deg); }
        #controls-panel {
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            border-radius: 12px 12px 0 0;
            padding: 1rem 1.5rem;
            display: flex;
            flex-direction: column; /* Changed to column */
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 1rem; /* Spacing between rows */
        }
        .controls-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
        }
        #bifurcation-panel {
            top: 80px;
            right: 20px;
            width: 350px;
            height: 250px;
            border-radius: 12px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }
        #bifurcation-canvas {
            width: 100%;
            height: 100%;
            background-color: rgba(3, 7, 18, 0.5);
            border-radius: 6px;
        }
        header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background-color: rgba(3, 7, 18, 0.5);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(55, 65, 81, 0.7);
        }
        .menu-button, .toggle-button, .action-button, .preset-button {
            background-color: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            font-weight: 500;
        }
        .action-button:disabled {
            background-color: #374151;
            cursor: not-allowed;
            transform: none;
        }
        .menu-button:hover, .toggle-button:hover, .action-button:not(:disabled):hover, .preset-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px);
        }
        .menu-button.active, .toggle-button.active {
            background-color: #4f46e5;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
        }
        input[type="range"] {
            -webkit-appearance: none; width: 100%; height: 4px;
            background: #4b5563; border-radius: 2px; outline: none;
            opacity: 0.7; transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 18px; height: 18px; background: #818cf8;
            cursor: pointer; border-radius: 50%;
        }
        .control-group {
            display: flex; flex-direction: column;
            align-items: center; gap: 0.5rem; text-align: center;
            min-width: 200px;
        }
        .hidden { display: none !important; }
        canvas { display: block; }
    </style>
</head>
<body>
    <header>
        <h1 class="text-xl font-bold">3D Cell Division</h1>
        <div id="menu"></div>
    </header>
    <div id="info-panel" class="ui-panel">
        <div id="info-header">
            <h2 id="info-title" class="text-xl font-bold text-indigo-400"></h2>
            <div id="toggle-icon" class="text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg></div>
        </div>
        <div id="info-content" class="pt-4"><p id="info-description"></p></div>
    </div>
    <div id="bifurcation-panel" class="ui-panel">
        <h3 class="text-lg font-bold text-indigo-400 mb-2">Bifurcation Diagram</h3>
        <canvas id="bifurcation-canvas"></canvas>
    </div>
    <div id="controls-panel" class="ui-panel"></div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { Delaunay } from 'https://cdn.jsdelivr.net/npm/d3-delaunay@6/+esm';

    const scenes = {
        cell_division: {
            title: 'Logistic Growth & Cell Division',
            description: 'A 3D simulation of population dynamics based on the logistic map: x_n+1 = r * x_n * (1 - x_n). The growth rate "r" determines the population\'s behavior, from stable equilibrium to chaotic fluctuation, visualized as dividing cells on a culture plate.',
            init: initCellDivisionSim,
        },
    };

    function initCellDivisionSim() {
        const MAX_CELLS = 750;
        const PLATE_SIZE = 25;
        const BLOOM_LAYER = 1;
        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_LAYER);

        let simState = { r: 2.8, x: 0.5, autoPlay: false, timeSinceLastStep: 0 };
        let resources = { disposables: [] };
        let cellInstances = []; 

        let composer, cytoplasmMesh, nucleusMesh, voronoiMesh;
        const dummy = new THREE.Object3D();

        let bifurcationCanvas, bifurcationCtx, bifurcationImageData;

        function init() {
            camera.position.set(0, 10, 15); 
            controls.target.set(0, 0, 0);
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.2;
            controls.maxPolarAngle = Math.PI / 2.1;

            setupPostProcessing();
            setupUI();
            createEnvironment();
            createCellMeshes();
            setupBifurcationDiagram();
        }

        function setupPostProcessing() {
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.5);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            resources.disposables.push(composer);
        }

        function setupUI() {
            const controlsPanel = document.getElementById('controls-panel');
            controlsPanel.innerHTML = `
                <div class="controls-row">
                    <div class="control-group">
                        <label class="text-sm font-medium">Growth Rate (r): <span id="r-value">${simState.r.toFixed(3)}</span></label>
                        <input id="r-slider" type="range" min="0" max="4" step="0.001" value="${simState.r}" class="w-full">
                    </div>
                     <div class="h-8 border-l border-gray-600 mx-2"></div>
                    <button id="next-gen-btn" class="action-button">Next Gen</button>
                    <button id="autoplay-btn" class="toggle-button">Auto-Play</button>
                    <button id="reset-btn" class="action-button">Reset</button>
                </div>
                <div class="controls-row" id="presets-container">
                     <button class="preset-button" data-r="2.8">Stable</button>
                     <button class="preset-button" data-r="3.2">Bifurcation</button>
                     <button class="preset-button" data-r="3.5">Period-Doubling</button>
                     <button class="preset-button" data-r="3.8">Chaos</button>
                     <button class="preset-button" data-r="4.0">Collapse</button>
                     <div class="h-8 border-l border-gray-600 mx-2"></div>
                     <button id="toggle-graph-btn" class="toggle-button active">Hide Graph</button>
                     <button id="toggle-voronoi-btn" class="toggle-button active">Hide Voronoi</button>
                </div>
            `;
            document.getElementById('r-slider').addEventListener('input', e => {
                setGrowthRate(parseFloat(e.target.value));
            });
            document.getElementById('next-gen-btn').onclick = calculateNextGeneration;
            document.getElementById('reset-btn').onclick = resetSimulation;
            document.getElementById('autoplay-btn').addEventListener('click', e => {
                simState.autoPlay = !simState.autoPlay;
                e.target.textContent = simState.autoPlay ? 'Pause' : 'Auto-Play';
                e.target.classList.toggle('active', simState.autoPlay);
                simState.timeSinceLastStep = 0;
            });
            
            document.querySelectorAll('.preset-button').forEach(button => {
                button.addEventListener('click', () => {
                    const rValue = parseFloat(button.dataset.r);
                    setGrowthRate(rValue);
                });
            });
            
            document.getElementById('toggle-graph-btn').addEventListener('click', (e) => {
                const panel = document.getElementById('bifurcation-panel');
                const isHidden = panel.style.display === 'none';
                panel.style.display = isHidden ? 'flex' : 'none';
                e.target.textContent = isHidden ? 'Hide Graph' : 'Show Graph';
                e.target.classList.toggle('active', isHidden);
            });
            
            document.getElementById('toggle-voronoi-btn').addEventListener('click', (e) => {
                if (voronoiMesh) {
                    voronoiMesh.visible = !voronoiMesh.visible;
                    e.target.textContent = voronoiMesh.visible ? 'Hide Voronoi' : 'Show Voronoi';
                    e.target.classList.toggle('active', voronoiMesh.visible);
                }
            });
        }
        
        function setGrowthRate(r) {
            simState.r = r;
            document.getElementById('r-slider').value = r;
            document.getElementById('r-value').textContent = r.toFixed(3);
            calculateNextGeneration();
        }

        function createEnvironment() {
            const plateGeometry = new THREE.PlaneGeometry(PLATE_SIZE, PLATE_SIZE, 10, 10);
            const plateMaterial = new THREE.MeshStandardMaterial({
                color: 0x4f46e5, transparent: true, opacity: 0.1,
                side: THREE.DoubleSide, metalness: 0.2, roughness: 0.8
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.rotation.x = -Math.PI / 2;
            activeSceneObjects.add(plate);

            const grid = new THREE.GridHelper(PLATE_SIZE, 20, 0x4f46e5, 0x374151);
            grid.position.y = 0.01;
            activeSceneObjects.add(grid);
            
            const voronoiGeometry = new THREE.BufferGeometry();
            const voronoiMaterial = new THREE.LineBasicMaterial({
                color: 0x67e8f9, // Cyan-300
                transparent: true,
                opacity: 0.75,
                depthTest: false
            });
            voronoiMesh = new THREE.LineSegments(voronoiGeometry, voronoiMaterial);
            voronoiMesh.position.y = 0.02; // Slightly above grid
            voronoiMesh.renderOrder = 1; // Render on top
            activeSceneObjects.add(voronoiMesh);

            resources.disposables.push(plateGeometry, plateMaterial, voronoiGeometry, voronoiMaterial);
        }

        function createCellMeshes() {
            const cellGroup = new THREE.Group();
            activeSceneObjects.add(cellGroup);

            const cytoplasmGeom = new THREE.SphereGeometry(0.5, 20, 16);
            const cytoplasmMat = new THREE.MeshStandardMaterial({
                color: 0xffa07a, // Light Salmon
                transparent: true, opacity: 0.4, premultipliedAlpha: true,
                metalness: 0.1, roughness: 0.4
            });
            cytoplasmMesh = new THREE.InstancedMesh(cytoplasmGeom, cytoplasmMat, MAX_CELLS);
            cytoplasmMesh.layers.enable(BLOOM_LAYER);
            cellGroup.add(cytoplasmMesh);

            const nucleusGeom = new THREE.SphereGeometry(0.2, 16, 12);
            const nucleusMat = new THREE.MeshStandardMaterial({
                color: 0x4b0082, // Indigo
                emissive: 0x312e81, emissiveIntensity: 0.5,
                metalness: 0.2, roughness: 0.5
            });
            nucleusMesh = new THREE.InstancedMesh(nucleusGeom, nucleusMat, MAX_CELLS);
            nucleusMesh.layers.enable(BLOOM_LAYER);
            cellGroup.add(nucleusMesh);
            resources.disposables.push(cytoplasmGeom, cytoplasmMat, nucleusGeom, nucleusMat);

            for (let i = 0; i < MAX_CELLS; i++) {
                cellInstances.push({
                    position: new THREE.Vector3((Math.random() - 0.5) * PLATE_SIZE, 0.5, (Math.random() - 0.5) * PLATE_SIZE),
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 0.2, 0, (Math.random() - 0.5) * 0.2),
                    targetScale: 0, currentScale: 0
                });
            }
        }
        
        function setupBifurcationDiagram() {
            bifurcationCanvas = document.getElementById('bifurcation-canvas');
            
            requestAnimationFrame(() => {
                const dpr = window.devicePixelRatio || 1;
                
                if (!bifurcationCanvas || !bifurcationCanvas.clientWidth) {
                    console.error("Bifurcation canvas not ready.");
                    return;
                }

                bifurcationCanvas.width = bifurcationCanvas.clientWidth * dpr;
                bifurcationCanvas.height = bifurcationCanvas.clientHeight * dpr;

                bifurcationCtx = bifurcationCanvas.getContext('2d');
                bifurcationCtx.fillStyle = 'rgba(129, 140, 248, 0.1)'; 

                const width = bifurcationCanvas.width;
                const height = bifurcationCanvas.height;
                
                if (width === 0 || height === 0) return;

                for (let i = 0; i < width; i++) {
                    const r = (i / width) * 4.0;
                    let x = Math.random();
                    for (let j = 0; j < 500; j++) {
                        x = r * x * (1 - x);
                    }
                    for (let j = 0; j < 200; j++) {
                        x = r * x * (1 - x);
                        const y = height - (x * height);
                        if (y >= 0 && y < height) {
                            bifurcationCtx.fillRect(i, y, 1, 1);
                        }
                    }
                }
                
                bifurcationImageData = bifurcationCtx.getImageData(0, 0, width, height);
                calculateNextGeneration();
            });
        }
        
        function updateBifurcationMarker() {
            if (!bifurcationCtx || !bifurcationImageData) return;

            const width = bifurcationCanvas.width;
            const height = bifurcationCanvas.height;
            
            bifurcationCtx.putImageData(bifurcationImageData, 0, 0);
            
            const r_pos = (simState.r / 4.0) * width;
            const x_pos = height - (simState.x * height);
            
            bifurcationCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
            bifurcationCtx.lineWidth = 1 * (window.devicePixelRatio || 1);
            
            bifurcationCtx.beginPath();
            bifurcationCtx.moveTo(r_pos, 0);
            bifurcationCtx.lineTo(r_pos, height);
            bifurcationCtx.stroke();
            
            bifurcationCtx.beginPath();
            bifurcationCtx.moveTo(0, x_pos);
            bifurcationCtx.lineTo(width, x_pos);
            bifurcationCtx.stroke();
        }

        function resetSimulation() {
            simState.x = 0.5;
            setGrowthRate(2.8);
        }

        function calculateNextGeneration() {
            simState.x = simState.r * simState.x * (1 - simState.x);
            const newCellCount = Math.floor(simState.x * MAX_CELLS);

            for (let i = 0; i < MAX_CELLS; i++) {
                cellInstances[i].targetScale = i < newCellCount ? 1 : 0;
            }
            updateBifurcationMarker();
        }

        function update(delta) {
            if (simState.autoPlay) {
                simState.timeSinceLastStep += delta;
                if (simState.timeSinceLastStep > (0.5 / animationSpeed)) {
                    calculateNextGeneration();
                    simState.timeSinceLastStep = 0;
                }
            }

            const halfPlate = PLATE_SIZE / 2;
            const activeCellIndices = [];
            for(let i = 0; i < MAX_CELLS; i++) {
                if (cellInstances[i].targetScale > 0) {
                    activeCellIndices.push(i);
                }
            }

            // --- Cell Repulsion to prevent overlap ---
            const repulsionStrength = 0.02;
            const effectiveRadius = 0.5; // Cytoplasm radius
            for (let i = 0; i < activeCellIndices.length; i++) {
                for (let j = i + 1; j < activeCellIndices.length; j++) {
                    const instanceA = cellInstances[activeCellIndices[i]];
                    const instanceB = cellInstances[activeCellIndices[j]];

                    const diff = new THREE.Vector3().subVectors(instanceA.position, instanceB.position);
                    diff.y = 0; // Only consider 2D distance for repulsion
                    const dist = diff.length();
                    const overlap = (effectiveRadius * 2) - dist;

                    if (overlap > 0) {
                        const repulsion = diff.normalize().multiplyScalar(overlap * repulsionStrength);
                        instanceA.velocity.add(repulsion);
                        instanceB.velocity.sub(repulsion);
                    }
                }
            }
            
            // --- Update All Cell Positions and Matrices ---
            for (let i = 0; i < MAX_CELLS; i++) {
                const instance = cellInstances[i];
                instance.currentScale += (instance.targetScale - instance.currentScale) * 0.1;
                instance.position.add(instance.velocity.clone().multiplyScalar(delta * animationSpeed));

                if (Math.abs(instance.position.x) > halfPlate) {
                    instance.velocity.x *= -1;
                    instance.position.x = Math.sign(instance.position.x) * halfPlate;
                }
                if (Math.abs(instance.position.z) > halfPlate) {
                    instance.velocity.z *= -1;
                    instance.position.z = Math.sign(instance.position.z) * halfPlate;
                }
                
                dummy.position.copy(instance.position);
                dummy.scale.setScalar(Math.max(0, instance.currentScale));
                dummy.updateMatrix();
                cytoplasmMesh.setMatrixAt(i, dummy.matrix);
                nucleusMesh.setMatrixAt(i, dummy.matrix);
            }
            cytoplasmMesh.instanceMatrix.needsUpdate = true;
            nucleusMesh.instanceMatrix.needsUpdate = true;
            
            // --- Update Voronoi Diagram ---
            if (voronoiMesh && voronoiMesh.visible && activeCellIndices.length > 2) {
                const activeCells = activeCellIndices.map(i => cellInstances[i]);
                const points = activeCells.map(c => [c.position.x, c.position.z]);
                const delaunay = Delaunay.from(points);
                const voronoi = delaunay.voronoi([-halfPlate, -halfPlate, halfPlate, halfPlate]);

                const vertices = [];
                for (const polygon of voronoi.cellPolygons()) {
                    if (polygon) {
                        for (let i = 0; i < polygon.length; i++) {
                            const p1 = polygon[i];
                            const p2 = polygon[(i + 1) % polygon.length];
                            vertices.push(p1[0], 0, p1[1]);
                            vertices.push(p2[0], 0, p2[1]);
                        }
                    }
                }
                
                if (vertices.length > 0) {
                    voronoiMesh.geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                }
            } else if (voronoiMesh) {
                 voronoiMesh.geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
            }
        }

        function render() {
            composer.render();
        }

        function cleanup() {
            controls.autoRotate = false;
            resources.disposables.forEach(d => d.dispose && d.dispose());
            document.getElementById('bifurcation-panel').style.display = 'none';
        }

        document.getElementById('bifurcation-panel').style.display = 'flex';
        init();
        return { update, cleanup, render };
    }

    // Template Engine
    let scene, camera, renderer, controls, clock;
    let activeSceneObjects = new THREE.Group();
    let currentUpdate = () => {}, currentCleanup = () => {}, currentRender = null;
    let currentSceneKey = null;
    let animationSpeed = 1.0;
    
    function init() {
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x030712);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 15);
        scene.add(dirLight);
        const bottomLight = new THREE.PointLight(0x4f46e5, 5, 50);
        bottomLight.position.set(0, -10, 0);
        scene.add(bottomLight);
        scene.add(activeSceneObjects);
        setupUI();
        const firstSceneKey = Object.keys(scenes)[0];
        if (firstSceneKey) switchScene(firstSceneKey);
        window.addEventListener('resize', onWindowResize);
        renderer.setAnimationLoop(animate);
    }

    function switchScene(key) {
        if (key === currentSceneKey) return;
        if (currentCleanup) currentCleanup();
        while(activeSceneObjects.children.length > 0){ 
            activeSceneObjects.remove(activeSceneObjects.children[0]); 
        }
        document.getElementById('controls-panel').innerHTML = '';
        currentRender = null;
        controls.reset();
        camera.position.set(0, 2, 8);
        controls.target.set(0, 0, 0);
        const sceneData = scenes[key];
        document.getElementById('info-title').textContent = sceneData.title;
        document.getElementById('info-description').textContent = sceneData.description;
        document.querySelectorAll('.menu-button').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById(`btn-${key}`);
        if(btn) btn.classList.add('active');
        currentSceneKey = key;
        const result = sceneData.init();
        currentUpdate = result.update || (() => {});
        currentCleanup = result.cleanup || (() => {});
        currentRender = result.render;
    }

    function animate() { 
        const delta = clock.getDelta();
        controls.update();
        currentUpdate(delta);
        if (currentRender) {
            currentRender();
        } else {
            renderer.render(scene, camera);
        }
    }
    
    function setupUI() {
        const menuDiv = document.getElementById('menu');
        Object.keys(scenes).forEach(key => {
            const button = document.createElement('button');
            button.id = `btn-${key}`;
            button.className = 'menu-button';
            button.textContent = scenes[key].title.split(':')[0];
            button.onclick = () => switchScene(key);
            menuDiv.appendChild(button);
        });
        document.getElementById('info-panel').addEventListener('click', (e) => {
            if (!e.target.closest('button, a, input')) {
                e.currentTarget.classList.toggle('expanded');
            }
        });
    }

    function onWindowResize() { 
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h; 
        camera.updateProjectionMatrix(); 
        renderer.setSize(w, h);
    }
    
    init();

</script>
</body>
</html>
