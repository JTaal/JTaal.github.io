<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Interactive Entropy Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #030712; /* bg-gray-950 */
            color: #e5e7eb;
        }
        .ui-panel {
            position: absolute;
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(8px);
            padding: 1.25rem;
            border: 1px solid rgba(55, 65, 81, 0.7);
            transition: all 0.5s ease-in-out;
            z-index: 10;
        }
        #info-panel {
            top: 80px;
            left: 20px;
            max-width: 420px;
            cursor: pointer;
            overflow: hidden;
            border-radius: 12px;
            max-height: 58px; /* Collapsed */
        }
        #info-panel.expanded {
            max-height: 90vh; 
            cursor: default;
            overflow-y: auto;
        }
        #info-header { display: flex; justify-content: space-between; align-items: center; }
        #toggle-icon { transition: transform 0.3s ease-in-out; }
        #info-panel.expanded #toggle-icon { transform: rotate(180deg); }
        .formula {
            font-family: 'Georgia', serif;
            background-color: #1f2937;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
            font-size: 1.2rem;
            margin-top: 1rem;
            color: #d1d5db;
            border: 1px solid #374151;
        }
        #controls-panel {
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            border-radius: 12px 12px 0 0;
            padding: 1rem 2rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
        }
        header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background-color: rgba(3, 7, 18, 0.5);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(55, 65, 81, 0.7);
        }
        #menu {
            display: flex;
            gap: 10px;
        }
        .menu-button, .preset-button, .toggle-button {
            background-color: rgba(55, 65, 81, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(75, 85, 99, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            font-weight: 500;
            font-size: 0.875rem;
        }
        .menu-button:hover, .preset-button:hover, .toggle-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px);
        }
        .menu-button.active, .preset-button.active, .toggle-button.active {
            background-color: #4f46e5;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: #4b5563;
            border-radius: 2px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #818cf8;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="number"] {
            -moz-appearance: textfield;
            background-color: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 6px;
            color: white;
            text-align: center;
            padding: 0.25rem;
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .chart-container {
            background-color: #111827;
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .hidden { display: none !important; }
        canvas { display: block; }
        .surprisal-gradient {
            background-image: linear-gradient( to right, hsl(240, 90%, 60%), hsl(180, 90%, 60%), hsl(120, 90%, 60%), hsl(60, 90%, 60%), hsl(0, 90%, 60%) );
        }
    </style>
</head>
<body>
    <header>
        <h1 class="text-xl font-bold text-gray-200 tracking-wider opacity-90">Entropy Explorer</h1>
        <div id="menu"></div>
    </header>

    <div id="info-panel" class="ui-panel">
        <div id="info-header">
            <h2 id="info-title" class="text-xl font-bold text-indigo-400">Welcome!</h2>
            <div id="toggle-icon" class="text-indigo-400">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
            </div>
        </div>
        <div id="info-content" class="pt-4 space-y-3">
             <p id="info-description" class="text-gray-300"></p>
             <div id="info-formula" class="formula"></div>
             <div id="shannon-explanation-content">
                <h3 class="font-bold text-lg text-indigo-400 mt-4">Max Entropy vs. States</h3>
                <p class="text-sm text-gray-300">This chart shows the logarithmic growth of maximum possible entropy ($H_{max} = \log_2(N)$) as the number of states (N) increases. The red dot indicates the maximum entropy for the current number of states in the simulation.</p>
                <div class="chart-container">
                    <canvas id="shannon-growth-chart"></canvas>
                </div>
             </div>
             <div id="differential-explanation-content">
                <h3 class="font-bold text-lg text-teal-400 mt-4">Probability Density (PDF)</h3>
                <p id="pdf-description" class="text-sm text-gray-300"></p>
                 <div class="chart-container">
                    <canvas id="differential-pdf-chart"></canvas>
                </div>
             </div>
        </div>
    </div>
    
    <div id="controls-panel" class="ui-panel"></div>

<script type="module">
    let scene, camera, renderer, controls;
    let activeSceneObjects = new THREE.Group();
    let raycaster, mouse;
    const fontLoader = new THREE.FontLoader();
    let mainFont = null;
    let particles = [];
    const NUM_PARTICLES = 2000;
    let shannonGrowthChart, differentialInfoChart;

    const concepts = {
        shannon_entropy: {
            title: 'Shannon Entropy',
            description: 'This cloud of particles represents a system with discrete states (the glowing attractors). Entropy measures the average "surprise" of finding a particle in any one state. When particles are concentrated, the system is predictable (low entropy).',
            formula: 'H(X) = - &Sigma; p(x<sub>i</sub>) log<sub>2</sub>(p(x<sub>i</sub>))',
            init: initShannon,
        },
        differential_entropy: {
            title: 'Differential Entropy',
            description: 'Here, particles move freely within a probability distribution. Differential entropy measures the uncertainty of a particle\'s position. As the distribution spreads out, so does the uncertainty and the entropy.',
            formula: 'h(X) = - &int; f(x) log<sub>2</sub>(f(x)) dx',
            init: initDifferential,
        },
        boltzmann_entropy: {
            title: 'Boltzmann Entropy',
            description: 'This concept from physics relates the statistical randomness of a system (the number of possible microscopic arrangements, W) to its overall entropy (S). Drag the barrier or use the new controls to change the system\'s constraints.',
            formula: 'S = k<sub>B</sub> ln(W)',
            init: initBoltzmann,
        }
    };

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 4, 15);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        scene.add(new THREE.AmbientLight(0xffffff, 0.2));
        scene.add(new THREE.PointLight(0xffffff, 0.8, 100));
        scene.add(activeSceneObjects);

        fontLoader.load('https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            mainFont = font;
            createMenu();
            setupInfoPanelCharts();
            switchConcept('shannon_entropy');
        });
        
        window.addEventListener('resize', onWindowResize, false);
        document.getElementById('info-panel').addEventListener('click', (e) => {
            if (e.target.closest('canvas')) return;
            e.currentTarget.classList.toggle('expanded');
        });
        
        animate();
    }
    
    let currentCleanup = () => {};
    let currentUpdate = () => {};
    let currentConceptKey = null;

    function switchConcept(key) {
        if (key === currentConceptKey) return;
        currentCleanup();
        while(activeSceneObjects.children.length > 0) { 
            const obj = activeSceneObjects.children[0];
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material && obj.material.dispose) obj.material.dispose();
            activeSceneObjects.remove(obj); 
        }
        document.getElementById('controls-panel').innerHTML = '';
        
        const concept = concepts[key];
        document.getElementById('info-title').textContent = concept.title;
        document.getElementById('info-description').textContent = concept.description;
        document.getElementById('info-formula').innerHTML = concept.formula;
        document.getElementById('shannon-explanation-content').style.display = key === 'shannon_entropy' ? 'block' : 'none';
        document.getElementById('differential-explanation-content').style.display = key === 'differential_entropy' ? 'block' : 'none';
        document.getElementById('info-panel').classList.remove('expanded');

        if (currentConceptKey) document.getElementById(`btn-${currentConceptKey}`).classList.remove('active');
        document.getElementById(`btn-${key}`).classList.add('active');

        currentConceptKey = key;
        const { update, cleanup } = concept.init();
        currentUpdate = update;
        currentCleanup = cleanup;
    }

    function createMenu() {
        const menuDiv = document.getElementById('menu');
        Object.keys(concepts).forEach(key => {
            const button = document.createElement('button');
            button.id = `btn-${key}`;
            button.className = 'menu-button';
            button.textContent = concepts[key].title.split('(')[0].trim();
            button.onclick = () => switchConcept(key);
            menuDiv.appendChild(button);
        });
    }

    function setupInfoPanelCharts() {
        const shannonCtx = document.getElementById('shannon-growth-chart').getContext('2d');
        const labels = Array.from({length: 100}, (_, i) => i + 1);
        const data = labels.map(n => Math.log2(n));
        
        shannonGrowthChart = new Chart(shannonCtx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    { label: 'H_max = log2(N)', data: data, borderColor: '#818cf8', tension: 0.1, pointRadius: 0 },
                    { label: 'Current N', data: [], type: 'scatter', backgroundColor: '#ef4444', pointRadius: 5 }
                ]
            },
            options: {
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: { 
                    x: { title: { display: true, text: 'Number of States (N)', color: '#9ca3af'}, ticks: { color: '#9ca3af' }}, 
                    y: { title: { display: true, text: 'Max Entropy (bits)', color: '#9ca3af'}, ticks: { color: '#9ca3af' }}
                }
            }
        });

        const diffCtx = document.getElementById('differential-pdf-chart').getContext('2d');
        differentialInfoChart = new Chart(diffCtx, {
            type: 'line',
            data: { datasets: [] },
            options: { maintainAspectRatio: false, plugins: { legend: { display: false }}, scales: { x: { type: 'linear', min: -10, max: 10, ticks: { color: '#9ca3af' }}, y: { beginAtZero: true, ticks: { color: '#9ca3af' }}} }
        });
    }
    
    function updateShannonGrowthChartMarker(numStates) {
        if (!shannonGrowthChart || numStates === undefined || numStates < 1) return;
        const maxEntropy = Math.log2(numStates);
        shannonGrowthChart.data.datasets[1].data = [{x: numStates, y: maxEntropy}];
        shannonGrowthChart.update();
    }
    
    function createParticles(count = NUM_PARTICLES, color = 0x818cf8) {
        particles = [];
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        const material = new THREE.PointsMaterial({ size: 0.1, blending: THREE.AdditiveBlending, transparent: true, sizeAttenuation: true, vertexColors: true });
        for (let i = 0; i < count; i++) {
            const [x,y,z] = [(Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10];
            positions.set([x,y,z], i*3);
            const baseColor = new THREE.Color(color);
            colors.set([baseColor.r, baseColor.g, baseColor.b], i * 3);
            particles.push({ position: new THREE.Vector3(x, y, z), velocity: new THREE.Vector3() });
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const points = new THREE.Points(geometry, material);
        activeSceneObjects.add(points);
        return points;
    }

    function initShannon() {
        const particleSystem = createParticles();
        let attractors = [];
        let distributions = [];
        let entropyText;
        let surprisalMode = false;

        function setup(numStates) {
            attractors.forEach(attr => activeSceneObjects.remove(attr));
            attractors = [];
            for (let i = 0; i < numStates; i++) {
                const angle = (i / numStates) * Math.PI * 2;
                const radius = numStates > 1 ? 4 + numStates * 0.05 : 0;
                const attractor = new THREE.PointLight(0xfbbf24, 2, 5 + numStates * 0.1);
                attractor.position.set(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
                activeSceneObjects.add(attractor);
                attractors.push(attractor);
            }
            updateShannonGrowthChartMarker(numStates);
            applyDistribution();
        }

        function applyDistribution() {
            let particleIndex = 0;
            for (let i = 0; i < attractors.length; i++) {
                const count = Math.round(NUM_PARTICLES * (distributions[i] || 0));
                for (let j = 0; j < count; j++) {
                    if (particles[particleIndex]) particles[particleIndex].attractorIndex = i;
                    particleIndex++;
                }
            }
             while(particleIndex < NUM_PARTICLES) {
                 if (particles[particleIndex]) particles[particleIndex].attractorIndex = particleIndex % attractors.length;
                 particleIndex++;
            }
        }
        
        function createControls(numStates) {
            const controlsDiv = document.getElementById('controls-panel');
            controlsDiv.innerHTML = `
                <div class="control-group">
                    <label for="states-input" class="text-sm font-medium">Number of States:</label>
                    <input id="states-input" type="number" min="1" max="100" value="${numStates}" class="w-20">
                </div>
                <div class="text-center text-3xl font-bold"><span id="entropy-value" class="text-white">1.00</span> bits</div>
                <div id="dist-controls" class="flex items-center gap-4"></div>
                <div class="control-group">
                    <label class="text-sm font-medium">Visualization</label>
                    <button id="surprisal-toggle" class="toggle-button">Surprisal</button>
                </div>
                <div id="surprisal-legend" class="control-group hidden w-full">
                    <label class="text-sm font-medium">Surprisal Color Range</label>
                    <div class="w-48 h-4 rounded-full surprisal-gradient"></div>
                    <div class="flex justify-between w-48 text-xs text-gray-400">
                        <span>Low</span>
                        <span>High</span>
                    </div>
                </div>
            `;
            entropyText = document.getElementById('entropy-value');
            const statesInput = document.getElementById('states-input');
            statesInput.addEventListener('focus', (e) => e.target.select());
            statesInput.addEventListener('input', (e) => {
                let n = parseInt(e.target.value);
                if (isNaN(n) || n < 1) return;
                if (n > 100) n = 100;
                e.target.value = n;
                setup(n);
                createDistributionControls(n);
            });
             statesInput.addEventListener('blur', (e) => {
                 let n = parseInt(e.target.value);
                if (isNaN(n) || n < 1) {
                    e.target.value = 1;
                    setup(1);
                    createDistributionControls(1);
                }
            });

            document.getElementById('surprisal-toggle').addEventListener('click', (e) => {
                surprisalMode = !surprisalMode;
                e.target.classList.toggle('active', surprisalMode);
                document.getElementById('surprisal-legend').classList.toggle('hidden', !surprisalMode);
            });
            createDistributionControls(numStates);
        }
        
        function createDistributionControls(numStates) {
            const distControlsDiv = document.getElementById('dist-controls');
            distControlsDiv.innerHTML = '';
            if (numStates <= 1) {
                distributions = [1];
                applyDistribution();
                return;
            };

            if (numStates <= 5) {
                let sliderHTML = '<div class="flex flex-col gap-2 w-40">';
                for(let i = 0; i < numStates - 1; i++) {
                    sliderHTML += `<div><input class="dist-slider" data-index="${i}" type="range" min="0" max="1" step="0.01" value="${1/(numStates-i)}"></div>`;
                }
                sliderHTML += '</div>';
                distControlsDiv.innerHTML = sliderHTML;
                document.querySelectorAll('.dist-slider').forEach(s => s.addEventListener('input', handleSliderChange));
                handleSliderChange();
            } else {
                 distControlsDiv.innerHTML = `<div class="control-group"><label class="text-sm font-medium">Distribution Shape</label><div class="flex gap-2"><button class="preset-button active" data-shape="uniform">Uniform</button><button class="preset-button" data-shape="skewed">Skewed</button><button class="preset-button" data-shape="peaked">Peaked</button></div></div>`;
                document.querySelectorAll('.preset-button').forEach(b => b.addEventListener('click', handlePresetChange));
                handlePresetChange({ target: document.querySelector('.preset-button.active') });
            }
        }

        function handleSliderChange() {
            let remaining = 1.0;
            const sliders = document.querySelectorAll('.dist-slider');
            distributions = new Array(sliders.length + 1).fill(0);
            sliders.forEach((slider, i) => {
                const val = parseFloat(slider.value) * remaining;
                distributions[i] = val;
                remaining -= val;
            });
            distributions[sliders.length] = remaining;
            applyDistribution();
        }

        function handlePresetChange(e) {
            document.querySelectorAll('.preset-button').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            const shape = e.target.dataset.shape;
            const n = attractors.length;
            distributions = new Array(n);
            let sum = 0;
            for(let i=0; i < n; i++) {
                if (shape === 'uniform') distributions[i] = 1;
                else if (shape === 'skewed') distributions[i] = Math.pow(n - i, 2);
                else if (shape === 'peaked') distributions[i] = Math.exp(-Math.pow(i - (n - 1) / 2, 2) / (n / 4));
                sum += distributions[i];
            }
            distributions = distributions.map(d => d / sum);
            applyDistribution();
        }

        function update() {
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            let entropy = 0;
            const probs = new Array(attractors.length).fill(1e-9); 
            
            particles.forEach(p => {
                if (probs[p.attractorIndex] !== undefined) probs[p.attractorIndex]++;
            });

            const normalizedProbs = probs.map(c => c / (NUM_PARTICLES + attractors.length * 1e-9));
            const surprisals = normalizedProbs.map(p => -Math.log2(p));
            const maxSurprisal = Math.max(...surprisals, 1);

            normalizedProbs.forEach(p => {
                entropy -= p * Math.log2(p);
            });

            const defaultColor = new THREE.Color(0x818cf8);
            const surprisalColor = new THREE.Color();

            particles.forEach((p, i) => {
                const attractor = attractors[p.attractorIndex];
                if(attractor) p.velocity.add(attractor.position.clone().sub(p.position).multiplyScalar(0.002));
                p.velocity.add(new THREE.Vector3((Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05));
                p.velocity.multiplyScalar(0.95);
                p.position.add(p.velocity);
                positions.set([p.position.x, p.position.y, p.position.z], i*3);
                
                if (surprisalMode) {
                    const surprisal = surprisals[p.attractorIndex] || 0;
                    const normalizedSurprisal = Math.min(surprisal / maxSurprisal, 1.0);
                    const hue = 0.66 * (1 - normalizedSurprisal);
                    surprisalColor.setHSL(hue, 0.9, 0.6);
                    colors.set([surprisalColor.r, surprisalColor.g, surprisalColor.b], i * 3);
                } else {
                    colors.set([defaultColor.r, defaultColor.g, defaultColor.b], i*3);
                }
            });

            if (entropyText) entropyText.textContent = entropy.toFixed(2);
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
        }
        
        createControls(2);
        setup(2);
        return { update, cleanup: () => {} };
    }

    function initDifferential() {
        const particleSystem = createParticles();
        let boundingBox = new THREE.Box3(new THREE.Vector3(-5,-5,-5), new THREE.Vector3(5,5,5));
        let boxHelper = new THREE.Box3Helper(boundingBox, 0x0d9488);
        activeSceneObjects.add(boxHelper);
        let entropyText;
        let mode = 'uniform';
        let variance = 5.0;

        function updatePDFChart() {
            const pdfDesc = document.getElementById('pdf-description');
            if (mode === 'uniform') {
                const size = document.getElementById('size-slider').value;
                const halfSize = parseFloat(size);
                const volume = Math.pow(halfSize*2, 3);
                const height = volume > 0 ? 1 / volume : 0;
                pdfDesc.textContent = "For a uniform distribution, the PDF is a constant value within the volume. The area under this 'curve' must equal 1.";
                differentialInfoChart.data = { datasets: [{ stepped: true, data: [{x: -halfSize, y: height}, {x: halfSize, y: height}], borderColor: '#facc15', backgroundColor: 'rgba(250, 204, 21, 0.3)', fill: {target: 'origin'} }] };
                differentialInfoChart.options.scales.x.min = -halfSize - 1;
                differentialInfoChart.options.scales.x.max = halfSize + 1;
            } else {
                const sigma = Math.sqrt(variance);
                pdfDesc.textContent = "For a Gaussian (Normal) distribution, the PDF is a bell curve. Higher variance means a wider, flatter curve, increasing entropy.";
                const data = [];
                for(let x = -15; x <= 15; x+=0.5) {
                    const pdf = (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow(x / sigma, 2));
                    data.push({x, y: pdf});
                }
                differentialInfoChart.data = { datasets: [{ data, borderColor: '#2dd4bf', backgroundColor: 'rgba(45, 212, 191, 0.3)', fill: 'origin', tension: 0.4 }] };
                differentialInfoChart.options.scales.x.min = -15;
                differentialInfoChart.options.scales.x.max = 15;
            }
            differentialInfoChart.update();
        }
        
        function createControls() {
            const controlsDiv = document.getElementById('controls-panel');
            controlsDiv.innerHTML = `
                <div class="control-group">
                    <label class="text-sm font-medium">Distribution Type</label>
                    <div class="flex gap-2">
                         <button class="preset-button active" data-shape="uniform">Uniform</button>
                         <button class="preset-button" data-shape="gaussian">Gaussian</button>
                    </div>
                </div>
                <div id="uniform-controls" class="control-group">
                    <label class="text-sm font-medium">Container Size: <span id="volume-value">1000</span> (Volume)</label>
                    <input id="size-slider" type="range" min="0.1" max="25" step="0.1" value="5" class="w-48">
                </div>
                 <div id="gaussian-controls" class="control-group hidden">
                    <label class="text-sm font-medium">Variance (&sigma;Â²): <span id="variance-value">5.0</span></label>
                    <input id="variance-slider" type="range" min="0" max="100" step="1" value="50" class="w-48">
                </div>
                <div class="text-center text-3xl font-bold text-teal-400"><span id="entropy-value" class="text-white">9.97</span> bits</div>
            `;
            entropyText = document.getElementById('entropy-value');
            
            document.querySelectorAll('#controls-panel .preset-button').forEach(b => b.addEventListener('click', (e) => {
                mode = e.target.dataset.shape;
                document.querySelectorAll('#controls-panel .preset-button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                document.getElementById('uniform-controls').classList.toggle('hidden', mode !== 'uniform');
                document.getElementById('gaussian-controls').classList.toggle('hidden', mode !== 'gaussian');
                boxHelper.visible = (mode === 'uniform');
                updatePDFChart();
            }));

            document.getElementById('size-slider').addEventListener('input', (e) => {
                const size = parseFloat(e.target.value);
                boundingBox.setFromCenterAndSize(new THREE.Vector3(), new THREE.Vector3(size, size, size));
                const volume = Math.pow(size*2, 3);
                document.getElementById('volume-value').textContent = volume.toFixed(0);
                updatePDFChart();
            });
            document.getElementById('variance-slider').addEventListener('input', e => {
                const sliderValue = parseFloat(e.target.value);
                const minVar = 0.1;
                const maxVar = 1000000;
                const minLog = Math.log(minVar);
                const maxLog = Math.log(maxVar);
                const scale = (maxLog - minLog) / 100;
                const actualVariance = Math.exp(minLog + scale * sliderValue);
                variance = actualVariance;
                document.getElementById('variance-value').textContent = actualVariance > 1000 ? actualVariance.toExponential(1) : actualVariance.toFixed(1);
                updatePDFChart();
            });
            updatePDFChart();
        }
        
        function update() {
            const positions = particleSystem.geometry.attributes.position.array;
            particles.forEach((p, i) => {
                if (mode === 'uniform') {
                    p.velocity.add(new THREE.Vector3((Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1));
                    p.position.add(p.velocity);
                    ['x', 'y', 'z'].forEach(axis => {
                        if (p.position[axis] < boundingBox.min[axis] || p.position[axis] > boundingBox.max[axis]) {
                            p.position[axis] = THREE.MathUtils.clamp(p.position[axis], boundingBox.min[axis], boundingBox.max[axis]);
                            p.velocity[axis] *= -0.8;
                        }
                    });
                    p.velocity.multiplyScalar(0.99);
                } else {
                    const restoringForce = p.position.clone().multiplyScalar(-0.005 / variance);
                    p.velocity.add(restoringForce);
                    p.velocity.add(new THREE.Vector3((Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05));
                    p.velocity.multiplyScalar(0.95);
                    p.position.add(p.velocity);
                }
                positions.set([p.position.x, p.position.y, p.position.z], i*3);
            });
            
            let entropy = 0;
            if (mode === 'uniform') {
                const size = boundingBox.getSize(new THREE.Vector3());
                const volume = size.x * size.y * size.z;
                entropy = Math.log2(volume);
            } else {
                entropy = 0.5 * Math.log2(Math.pow(2 * Math.PI * Math.E * variance, 3));
            }

            if (entropyText) entropyText.textContent = entropy.toFixed(2);
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }

        createControls();
        return { update, cleanup: () => {} };
    }
    
    function initBoltzmann() {
        const PARTICLE_COUNT = 500;
        const BOX_SIZE = 10;
        const particleSystem = createParticles(PARTICLE_COUNT, 0xffa500);
        let boundingBox = new THREE.Box3(new THREE.Vector3(-BOX_SIZE/2, -BOX_SIZE/2, -BOX_SIZE/2), new THREE.Vector3(BOX_SIZE/2, BOX_SIZE/2, BOX_SIZE/2));
        const boxHelper = new THREE.Box3Helper(boundingBox, 0xffffff);
        
        const sphereGeo = new THREE.SphereGeometry(BOX_SIZE/2, 32, 32);
        const sphereMat = new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: true, transparent: true, opacity: 0.3});
        const sphereHelper = new THREE.Mesh(sphereGeo, sphereMat);
        sphereHelper.visible = false;
        
        activeSceneObjects.add(boxHelper, sphereHelper);

        const barrierGeo = new THREE.PlaneGeometry(BOX_SIZE, BOX_SIZE);
        const barrierMat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide});
        const barrier = new THREE.Mesh(barrierGeo, barrierMat);
        barrier.rotation.x = Math.PI / 2;
        activeSceneObjects.add(barrier);

        let entropyText, barrierSlider;
        let selectedObject = null;
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        let shapeMode = 'cube';
        let gravityMode = false;
        let collisionsMode = false;
        
        function resetParticles() {
            particles.forEach(p => {
                p.velocity.set((Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1);
                if(shapeMode === 'cube') {
                    p.position.set(
                        (Math.random() - 0.5) * BOX_SIZE,
                        (Math.random() - 0.5) * (BOX_SIZE / 2) - (BOX_SIZE / 4),
                        (Math.random() - 0.5) * BOX_SIZE
                    );
                } else {
                     p.position.setFromSphericalCoords(
                        Math.random() * BOX_SIZE/2,
                        Math.acos(2 * Math.random() - 1),
                        Math.random() * 2 * Math.PI
                    );
                }
            });
            barrier.position.y = -BOX_SIZE/4;
            if(barrierSlider) barrierSlider.value = -BOX_SIZE/4;
        }

        function createControls() {
            const controlsDiv = document.getElementById('controls-panel');
            controlsDiv.innerHTML = `
                <div class="control-group">
                    <div class="text-center text-3xl font-bold my-2 text-orange-400">S ~ <span id="entropy-value" class="text-white">1.00</span></div>
                </div>
                <div class="flex gap-4">
                    <button id="shape-toggle" class="toggle-button">Shape: Cube</button>
                    <button id="gravity-toggle" class="toggle-button">Gravity: Off</button>
                    <button id="collision-toggle" class="toggle-button">Collisions: Off</button>
                </div>
                <div id="barrier-controls" class="control-group">
                    <label class="text-sm font-medium">Remove Barrier</label>
                    <input id="barrier-slider" type="range" min="${-BOX_SIZE/2}" max="${BOX_SIZE/2}" step="0.1" value="0" class="w-48">
                </div>
            `;
            entropyText = document.getElementById('entropy-value');
            barrierSlider = document.getElementById('barrier-slider');
            const shapeBtn = document.getElementById('shape-toggle');
            const gravityBtn = document.getElementById('gravity-toggle');
            const collisionBtn = document.getElementById('collision-toggle');
            const barrierControls = document.getElementById('barrier-controls');

            shapeBtn.addEventListener('click', () => {
                shapeMode = shapeMode === 'cube' ? 'sphere' : 'cube';
                shapeBtn.textContent = `Shape: ${shapeMode === 'cube' ? 'Cube' : 'Sphere'}`;
                boxHelper.visible = shapeMode === 'cube';
                sphereHelper.visible = shapeMode === 'sphere';
                barrier.visible = shapeMode === 'cube';
                barrierControls.classList.toggle('hidden', shapeMode !== 'cube');
                resetParticles();
            });
            
            gravityBtn.addEventListener('click', () => {
                gravityMode = !gravityMode;
                gravityBtn.textContent = `Gravity: ${gravityMode ? 'On' : 'Off'}`;
                gravityBtn.classList.toggle('active', gravityMode);
            });

            collisionBtn.addEventListener('click', () => {
                collisionsMode = !collisionsMode;
                collisionBtn.textContent = `Collisions: ${collisionsMode ? 'On' : 'Off'}`;
                collisionBtn.classList.toggle('active', collisionsMode);
            });
            
            barrierSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                barrier.position.y = val;
            });
        }
        
        const onPointerDown = (e) => {
            if (shapeMode !== 'cube') return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(barrier);
            if (intersects.length > 0) {
                selectedObject = barrier;
                controls.enabled = false;
            }
        };

        const onPointerMove = (e) => {
            if (selectedObject) {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersectionPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(plane.normal), selectedObject.position), intersectionPoint);
                
                let newY = intersectionPoint.y;
                newY = Math.max(-BOX_SIZE/2, Math.min(newY, BOX_SIZE / 2));
                barrier.position.y = newY;
                barrierSlider.value = newY;
            }
        };

        const onPointerUp = () => {
            selectedObject = null;
            controls.enabled = true;
        };

        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerup', onPointerUp);

        function handleCollisions() {
            const particleRadius = 0.1;
            for(let i=0; i < particles.length; i++) {
                for(let j=i+1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    const dist = p1.position.distanceTo(p2.position);
                    if(dist < 2 * particleRadius) {
                        const collisionAxis = p1.position.clone().sub(p2.position).normalize();
                        const v1 = p1.velocity;
                        const v2 = p2.velocity;
                        const v1_proj = collisionAxis.clone().multiplyScalar(v1.dot(collisionAxis));
                        const v2_proj = collisionAxis.clone().multiplyScalar(v2.dot(collisionAxis));
                        v1.sub(v1_proj).add(v2_proj);
                        v2.sub(v2_proj).add(v1_proj);
                        
                        const overlap = 2 * particleRadius - dist;
                        p1.position.add(collisionAxis.clone().multiplyScalar(overlap / 2));
                        p2.position.sub(collisionAxis.clone().multiplyScalar(overlap / 2));
                    }
                }
            }
        }

        function update() {
            const positions = particleSystem.geometry.attributes.position.array;
            const barrierY = barrier.position.y;
            
            if(collisionsMode) handleCollisions();

            particles.forEach((p, i) => {
                if (!gravityMode) {
                    p.velocity.add(new THREE.Vector3((Math.random()-0.5)*0.01, (Math.random()-0.5)*0.01, (Math.random()-0.5)*0.01));
                }
                
                if (gravityMode) {
                    if (shapeMode === 'cube') {
                        p.velocity.y -= 0.005;
                    } else {
                        p.velocity.add(p.position.clone().multiplyScalar(-0.001));
                    }
                }

                p.position.add(p.velocity);
                const pos = p.position;
                const vel = p.velocity;
                
                if(shapeMode === 'cube') {
                    if (pos.x < -BOX_SIZE/2 || pos.x > BOX_SIZE/2) vel.x *= -0.9;
                    if (pos.y < -BOX_SIZE/2 || pos.y > BOX_SIZE/2) vel.y *= -0.9;
                    if (pos.z < -BOX_SIZE/2 || pos.z > BOX_SIZE/2) vel.z *= -0.9;
                    if (pos.y < barrierY && (pos.y - vel.y) >= barrierY) vel.y *= -0.9;
                    pos.clamp(boundingBox.min, boundingBox.max);
                } else {
                    if(pos.length() > BOX_SIZE/2) {
                        const normal = pos.clone().normalize();
                        vel.reflect(normal).multiplyScalar(0.9);
                        pos.copy(normal.multiplyScalar(BOX_SIZE/2));
                    }
                }
                
                positions.set([pos.x, pos.y, pos.z], i*3);
            });
            
            if (shapeMode === 'cube') {
                const accessibleHeight = (BOX_SIZE/2) + barrier.position.y;
                const W = accessibleHeight / BOX_SIZE; 
                const entropy = Math.log(W * 1e12); // Scaled for better visualization
                if (entropyText) entropyText.textContent = entropy.toFixed(2);
            } else {
                 if (entropyText) entropyText.textContent = "Constant";
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
        
        createControls();
        resetParticles();
        return { 
            update, 
            cleanup: () => {
                renderer.domElement.removeEventListener('pointerdown', onPointerDown);
                renderer.domElement.removeEventListener('pointermove', onPointerMove);
                renderer.domElement.removeEventListener('pointerup', onPointerUp);
            }
        };
    }


    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        if(currentUpdate) currentUpdate();
        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>

