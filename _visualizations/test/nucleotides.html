<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>3D DNA Monomers — Three.js</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    html,body{height:100%;margin:0;background:#111}
    #app{width:100%;height:100%;display:block}
    .info{position:absolute;left:10px;top:10px;color:#ddd;font-family:monospace;z-index:2}
    .credits{position:absolute;right:10px;bottom:10px;color:#bbb;font-family:monospace;font-size:12px}
  </style>
</head>
<body>
<div id="app"></div>
<div class="info">Drag to orbit • Scroll to zoom • Double-click to reset</div>
<div class="credits">Generated with three.js — nucleotide monomer models</div><!-- Module scripts from unpkg CDN --><script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
import { GUI } from 'https://unpkg.com/lil-gui@0.18.0/dist/lil-gui.esm.js';

// ----- Scene setup -----
const container = document.getElementById('app');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0b0b);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 20, 80);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.screenSpacePanning = false;
controls.minDistance = 10;
controls.maxDistance = 400;

window.addEventListener('resize', onWindowResize);
function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// Lights
const hemi = new THREE.HemisphereLight(0x8888ff, 0x222222, 0.6);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(10, 30, 20);
scene.add(dir);
const amb = new THREE.AmbientLight(0x404040, 0.6);
scene.add(amb);

// ----- Materials & helpers -----
const atomSegments = 28; // higher = smoother spheres
const bondRadialSegments = 16;

const COLORS = {
  P: 0xffa500, // phosphate: orange
  O: 0xff4500, // oxygen: reddish
  C: 0xaaaaaa, // carbon: light gray
  H: 0xffffff, // hydrogen: white
  N: 0x2266ff, // nitrogen: blue
  S: 0xffff00, // sulfur (not used) yellow
  A: 0x4caf50, // adenine green
  Cb: 0x2196f3, // cytosine blue
  T: 0xf44336, // thymine red
  G: 0xffeb3b  // guanine yellow
};

function atomMesh(radius, color){
  const geo = new THREE.SphereGeometry(radius, atomSegments, atomSegments);
  const mat = new THREE.MeshStandardMaterial({color, metalness:0.1, roughness:0.45});
  return new THREE.Mesh(geo, mat);
}

function bondMesh(start, end, radius = 0.4){
  const dir = new THREE.Vector3().subVectors(end, start);
  const len = dir.length();
  const geo = new THREE.CylinderGeometry(radius, radius, len, bondRadialSegments, 1, true);
  const mat = new THREE.MeshStandardMaterial({color:0x888888, metalness:0.2, roughness:0.5});
  const mesh = new THREE.Mesh(geo, mat);
  // position and orient
  mesh.position.copy(start).add(dir.multiplyScalar(0.5));
  mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), new THREE.Vector3().subVectors(end,start).normalize());
  return mesh;
}

// Create a canvas texture for base labels (A,C,T,G) — crisp letters on transparent background
function createBaseLabelTexture(letter){
  const size = 256;
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,size,size);
  // background slightly transparent circle
  ctx.fillStyle = 'rgba(255,255,255,0.05)';
  ctx.beginPath(); ctx.arc(size/2, size/2, size*0.45, 0, Math.PI*2); ctx.fill();
  // letter
  ctx.fillStyle = 'white';
  ctx.font = 'bold 160px serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(letter, size/2, size/2 + 8);
  const tx = new THREE.CanvasTexture(canvas);
  tx.encoding = THREE.sRGBEncoding;
  tx.needsUpdate = true;
  return tx;
}

// ----- Molecular building blocks -----
// Helper: create a sugar (deoxyribose) as a pentagon ring of carbon atoms + H/O where appropriate.
function createSugar(){
  const group = new THREE.Group();
  const radius = 1.2;
  const ringRadius = 4.2; // scale
  const angleOffset = Math.PI/10;
  const positions = [];
  for(let i=0;i<5;i++){
    const ang = angleOffset + i*(Math.PI*2/5);
    const x = ringRadius * Math.cos(ang);
    const y = 0.0;
    const z = ringRadius * Math.sin(ang);
    positions.push(new THREE.Vector3(x,y,z));
  }
  // Carbon atoms on ring
  positions.forEach(pos=>{
    const a = atomMesh(radius, COLORS.C);
    a.position.copy(pos);
    group.add(a);
  });
  // bonds between ring carbons
  for(let i=0;i<5;i++){
    const a=positions[i], b=positions[(i+1)%5];
    group.add(bondMesh(a,b,0.35));
  }
  // add an oxygen (to represent O in sugar backbone linkage) slightly out of plane
  const oxygen = atomMesh(1.0, COLORS.O);
  oxygen.position.copy(positions[2]).add(new THREE.Vector3(0,1.2,-0.8));
  group.add(oxygen);
  // attach a small methyl (H) for realism
  const hydrogen = atomMesh(0.45, COLORS.H);
  hydrogen.position.copy(positions[0]).add(new THREE.Vector3(0.7,0.8,-0.2));
  group.add(hydrogen);
  return group;
}

// Helper: create phosphate group (P + 4 oxygens) as tetrahedral approx
function createPhosphate(){
  const group = new THREE.Group();
  const p = atomMesh(1.1, COLORS.P);
  p.position.set(0,0,0);
  group.add(p);
  const oxyOffsets = [
    new THREE.Vector3(2.2,0.6,0.3),
    new THREE.Vector3(-1.8,1.0,0.9),
    new THREE.Vector3(-1.2,-1.2,-1.0),
    new THREE.Vector3(1.2,-1.4,1.3)
  ];
  oxyOffsets.forEach(o=>{
    const ox = atomMesh(0.9, COLORS.O);
    ox.position.copy(o);
    group.add(ox);
    group.add(bondMesh(p.position, ox.position, 0.25));
  });
  return group;
}

// Helper: create a base (approximate atomic ring structures). We'll make pyrimidine (one ring) and purine (two fused rings).
function createBase(type){
  const group = new THREE.Group();
  // scale & layout
  const ringRadius = (type === 'A' || type === 'G') ? 3.2 : 2.6;
  const segments = 6; // hexagon-ish for aromatic rings
  const center = new THREE.Vector3(0,0,0);
  // For pyrimidines (C,T) single ring; for purines (A,G) two fused rings
  const baseColor = COLORS[type];

  function makeRing(offset){
    const pts = [];
    for(let i=0;i<segments;i++){
      const ang = i*(Math.PI*2/segments) + offset;
      pts.push(new THREE.Vector3(ringRadius*Math.cos(ang), 0, ringRadius*Math.sin(ang)));
    }
    pts.forEach(p=>{
      const atom = atomMesh(0.65, COLORS.C);
      atom.position.copy(p);
      group.add(atom);
    });
    for(let i=0;i<segments;i++){
      group.add(bondMesh(pts[i], pts[(i+1)%segments], 0.18));
    }
    return pts;
  }

  if(type === 'A' || type === 'G'){
    // two fused rings: second ring shifted
    const r1 = makeRing(0);
    const r2 = makeRing(Math.PI/segments);
    // shift second ring slightly
    r2.forEach((v)=>v.add(new THREE.Vector3(1.6,0,0)));
    // reposition meshes to match shifted coords
    // (the earlier created meshes are still at unshifted positions; to keep code simple, create explicit atoms instead)
    group.clear();
    const fusedCenters = [new THREE.Vector3(-1.5,0,0), new THREE.Vector3(1.0,0,0)];
    fusedCenters.forEach((centerShift, idx)=>{
      const pts = [];
      for(let i=0;i<6;i++){
        const ang = i*(Math.PI*2/6) + (idx===0?0:Math.PI/6);
        pts.push(new THREE.Vector3(ringRadius*Math.cos(ang), 0, ringRadius*Math.sin(ang)).add(centerShift));
      }
      pts.forEach(p=>{ group.add(atomMesh(0.65, COLORS.C)); group.children[group.children.length-1].position.copy(p); });
      for(let i=0;i<6;i++) group.add(bondMesh(pts[i], pts[(i+1)%6], 0.18));
    });
  } else {
    // single ring
    const pts = [];
    for(let i=0;i<6;i++){ const ang = i*(Math.PI*2/6); pts.push(new THREE.Vector3(ringRadius*Math.cos(ang),0,ringRadius*Math.sin(ang))); }
    pts.forEach(p=>{ group.add(atomMesh(0.65, COLORS.C)); group.children[group.children.length-1].position.copy(p); });
    for(let i=0;i<6;i++) group.add(bondMesh(pts[i], pts[(i+1)%6], 0.18));
  }

  // add a colored plate under the base to indicate base type and a label
  const plateGeo = new THREE.CircleGeometry((type === 'A' || type === 'G') ? 3.8 : 3.1, 64);
  const canvasTex = createBaseLabelTexture(type);
  const plateMat = new THREE.MeshStandardMaterial({map: canvasTex, transparent:true, opacity:0.95, metalness:0.0, roughness:0.6});
  const plate = new THREE.Mesh(plateGeo, plateMat);
  plate.rotateX(-Math.PI/2);
  plate.position.set(0,-0.55,0);
  group.add(plate);

  // slight color tint overlay for base (a translucent plane)
  const overlay = new THREE.Mesh(new THREE.PlaneGeometry(6.5,6.5,1,1), new THREE.MeshStandardMaterial({color:baseColor, transparent:true, opacity:0.06}));
  overlay.rotateX(-Math.PI/2);
  overlay.position.set(0,-0.4,0);
  group.add(overlay);

  return group;
}

// ----- Assemble a nucleotide -----
function createNucleotide(type){
  const root = new THREE.Group();
  // sugar
  const sugar = createSugar();
  sugar.scale.set(1.2,1.2,1.2);
  sugar.position.set(0,0,0);
  root.add(sugar);
  // phosphate
  const phosphate = createPhosphate();
  phosphate.scale.set(0.9,0.9,0.9);
  phosphate.position.set(-9.0, -0.8, 0);
  root.add(phosphate);
  // bond sugar-phosphate
  root.add(bondMesh(new THREE.Vector3(-4.0,-0.4,0), new THREE.Vector3(-9.0,-0.8,0), 0.28));
  // base attached to sugar — place to the right of sugar
  const base = createBase(type);
  base.position.set(7.2, 0.6, 0);
  base.rotateY(Math.PI*0.0);
  root.add(base);
  // bond sugar-base
  root.add(bondMesh(new THREE.Vector3(4.2,0.2,0), new THREE.Vector3(5.6,0.2,0), 0.25));
  return root;
}

// Make a short strand (several nucleotides) and alternate bases
const strandGroup = new THREE.Group();
const seq = ['A','C','T','G','A','G','C','T'];
let xOff = 0;
for(let i=0;i<seq.length;i++){
  const mon = createNucleotide(seq[i]);
  mon.position.set(i*14 - (seq.length*14)/2 + 7, 0, (i%2===0? -1.2: 1.2));
  mon.rotation.z = (i%2===0)? 0.06 : -0.05;
  mon.userData.base = seq[i];
  strandGroup.add(mon);
}
scene.add(strandGroup);

// Add a ground grid for scale
const grid = new THREE.GridHelper(200, 40, 0x222222, 0x111111);
grid.position.y = -10;
scene.add(grid);

// GUI controls
const params = {
  'show axes': false,
  'base scale': 1.0,
  'spacing': 14,
  'auto-rotate': false
};
const gui = new GUI({width:300});
gui.add(params, 'show axes').onChange(v=>{
  if(v){
    const axes = new THREE.AxesHelper(20);
    axes.name = 'axes_helper';
    scene.add(axes);
  } else {
    const old = scene.getObjectByName('axes_helper');
    if(old) scene.remove(old);
  }
});
gui.add(params, 'base scale', 0.4, 2.0).onChange(v=>{ strandGroup.scale.set(v,v,v); });
gui.add(params, 'spacing', 8, 30).onChange(v=>{
  for(let i=0;i<strandGroup.children.length;i++){
    strandGroup.children[i].position.x = i*v - (strandGroup.children.length*v)/2 + v/2;
  }
});
gui.add(params, 'auto-rotate');

// simple double-click to reset view
renderer.domElement.addEventListener('dblclick', ()=>{
  controls.reset();
  camera.position.set(0,20,80);
});

// For picking: show base letter on hover
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let highlighted = null;
window.addEventListener('pointermove', (e)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left)/rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top)/rect.height) * 2 + 1;
});

function animate(){
  requestAnimationFrame(animate);
  controls.update();
  if(params['auto-rotate']) strandGroup.rotation.y += 0.002;

  // hover detection
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(strandGroup.children, true);
  if(intersects.length>0){
    // find top-level nucleotide parent
    let obj = intersects[0].object;
    while(obj && !strandGroup.children.includes(obj)) obj = obj.parent;
    if(obj && highlighted!==obj){
      if(highlighted) highlightNode(highlighted, false);
      highlighted = obj; highlightNode(highlighted, true);
    }
  } else {
    if(highlighted){ highlightNode(highlighted, false); highlighted = null; }
  }

  renderer.render(scene,camera);
}

function highlightNode(node, on){
  if(on){
    node.traverse(c=>{ if(c.isMesh) c.material && (c.material.emissive && (c.material.emissive.setHex(0x222222)), c.material && (c.material.opacity!==undefined && (c.material.opacity = Math.min(1, (c.material.opacity||1)+0.05)))); });
  } else {
    node.traverse(c=>{ if(c.isMesh) c.material && (c.material.emissive && (c.material.emissive.setHex(0x000000)), c.material && (c.material.opacity!==undefined && (c.material.opacity = Math.max(0.06, (c.material.opacity||1)-0.05)))); });
  }
}

animate();

// Expose a function to create a single nucleotide for quick testing in console
window.createNucleotide = createNucleotide;
</script></body>
</html>