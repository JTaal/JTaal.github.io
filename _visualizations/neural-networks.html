<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Neural Network Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #030712; color: #e5e7eb; overflow: hidden; }
        .ui-panel { background-color: rgba(17, 24, 39, 0.9); backdrop-filter: blur(10px); border: 1px solid rgba(55, 65, 81, 0.7); border-radius: 12px; }
        .control-btn, .preset-btn, .main-nav-btn { background-color: #374151; border: 1px solid #4b5563; transition: background-color 0.2s, transform 0.1s; border-radius: 6px; padding: 0.5rem 1rem; }
        .control-btn:hover, .preset-btn:hover, .main-nav-btn:hover { background-color: #4f46e5; }
        .control-btn:active, .preset-btn:active, .main-nav-btn:active { transform: translateY(1px); }
        .preset-btn.active, .main-nav-btn.active { background-color: #4f46e5; box-shadow: 0 0 10px rgba(79, 70, 229, 0.5); font-weight: 600; }
        select { background-color: #1f2937; border: 1px solid #4b5563; border-radius: 6px; padding: 0.5rem; width: 100%; }
        input[type="range"]{-webkit-appearance:none;width:100%;height:4px;background:#4b5563;border-radius:2px;outline:none}
        input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:#818cf8;cursor:pointer;border-radius:50%}
        .main-view { display: none; } .main-view.active { display: block; }
        header { position: fixed; top: 0; left: 0; right: 0; z-index: 20; display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.5rem; background-color: rgba(3, 7, 18, 0.5); backdrop-filter: blur(5px); border-bottom: 1px solid rgba(55, 65, 81, 0.7); height: 65px; }
        #settings-panel { position: fixed; top: 0; right: 0; width: 400px; max-width: 100vw; height: 100%; z-index: 30; padding: 1.5rem; transition: transform 0.3s ease-in-out; transform: translateX(100%); overflow-y: auto; }
        #settings-panel.open { transform: translateX(0); }
        #settings-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 29; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        #settings-backdrop.open { opacity: 1; pointer-events: auto; }
        .hidden { display: none !important; }
        
        #three-d-view { position: fixed; top: 65px; bottom: 85px; left: 0; right: 0; z-index: 0; }
        #three-canvas { cursor: grab; width:100%; height:100%;}
        #bottom-dock { position: fixed; bottom: 0; left: 50%; transform: translateX(-50%); z-index: 20; padding: 0.75rem 1.5rem; margin-bottom: 1rem; height: 68px; }

        #builder-view { background-color: #030712; width: 100%; height: calc(100vh - 65px); margin-top: 65px; box-sizing: border-box; }
        #builder-svg { width: 100%; height: 100%; }
        #builder-svg .builder-node { cursor: pointer; transition: all 0.2s; }
        #builder-svg .builder-node:hover > circle { fill: #4f46e5; stroke: #a5b4fc; }
        #builder-svg .builder-node.io-node:hover > circle { fill: #16a34a; }
        #builder-svg .add-btn, #builder-svg .delete-btn { cursor: pointer; opacity: 0.7; transition: opacity 0.2s; }
        #builder-svg .add-btn:hover, #builder-svg .delete-btn:hover { opacity: 1; }
        .builder-select { background-color: #1f2937; border: 1px solid #4b5563; color: #e5e7eb; border-radius: 4px; font-family: 'Inter', sans-serif; }
    </style>
</head>
<body>
    <header>
        <div class="flex items-center gap-4">
             <h1 class="text-xl font-bold text-gray-200">NN Visualizer</h1>
             <div class="flex items-center gap-2 p-1 bg-gray-900 rounded-lg">
                 <button id="nav-builder" class="main-nav-btn text-sm py-1 px-3">Network Builder</button>
                 <button id="nav-trainer" class="main-nav-btn text-sm py-1 px-3 active">3D Training View</button>
             </div>
        </div>
        <div class="flex items-center gap-4">
            <button id="apply-architecture-btn" class="main-nav-btn active hidden">Apply & Train</button>
            <button id="settings-btn" class="control-btn"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg></button>
        </div>
    </header>
    
    <!-- Trainer View -->
    <div id="three-d-view" class="main-view active">
        <div id="three-canvas-container" class="w-full h-full"><canvas id="three-canvas"></canvas></div>
        <div id="bottom-dock" class="ui-panel flex items-center gap-6"><button id="play-pause-btn" class="control-btn flex items-center justify-center gap-2"><svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M8 5v14l11-7z"/></svg><svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="hidden"><path fill="currentColor" d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg><span id="play-pause-text">Play</span></button><div class="text-center text-sm text-gray-400">Epoch: <span id="epoch-counter" class="font-mono font-bold text-gray-200 text-base">0</span></div><button id="reset-btn" class="control-btn flex items-center justify-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg><span>Reset</span></button></div>
    </div>
    
    <!-- Builder View -->
    <div id="builder-view" class="main-view">
        <svg id="builder-svg"></svg>
    </div>

    <!-- Hidden Canvases for Chart Textures -->
    <div class="hidden">
        <canvas id="loss-canvas"></canvas>
        <canvas id="accuracy-canvas"></canvas>
    </div>

    <!-- Settings Panel -->
    <div id="settings-backdrop"></div>
    <div id="settings-panel" class="ui-panel">
        <div class="flex justify-between items-center border-b border-gray-700 pb-3 mb-4"><h2 class="text-xl font-bold text-indigo-400">Settings</h2><button id="close-settings-btn" class="control-btn p-2"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button></div>
        <div class="space-y-3 mb-6"><h3 class="font-semibold">3D View Mode</h3><div id="three-d-view-selector" class="flex items-center gap-2 p-1 bg-gray-900 rounded-lg"><button class="preset-btn text-sm py-2 px-3 w-full" data-view="output">Final Output</button><button class="preset-btn text-sm py-2 px-3 w-full" data-view="neuron">Single Neuron</button></div><div id="neuron-selector-container" class="flex items-center gap-2 text-sm mt-2 sm:mt-0 hidden"><label for="neuron-select">View Neuron:</label><select id="neuron-select" class="w-full"></select></div></div>
        <div class="space-y-4 mb-6"><h3 class="font-semibold">Training Parameters</h3><div><label for="lr-slider" class="font-medium text-sm">Learning Rate: <span id="lr-value" class="font-mono">0.03</span></label><input id="lr-slider" type="range" min="0.001" max="0.5" step="0.001" value="0.03"></div><div><label for="batch-size-slider" class="font-medium text-sm">Batch Size: <span id="batch-size-value" class="font-mono">10</span></label><input id="batch-size-slider" type="range" min="1" max="50" step="1" value="10"></div></div>
        <div class="space-y-3 mb-6">
            <h3 class="font-semibold">Display</h3>
            <div class="flex items-center justify-between p-2 bg-gray-900/50 rounded-lg">
                <label for="charts-toggle" class="font-medium text-sm text-gray-300">Show Performance Charts</label>
                <button id="charts-toggle" class="relative inline-flex items-center h-6 rounded-full w-11 transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-indigo-500 bg-indigo-500">
                    <span id="charts-toggle-knob" class="inline-block w-4 h-4 transform bg-white rounded-full transition-transform duration-200 ease-in-out translate-x-6"></span>
                </button>
            </div>
        </div>
        <div class="space-y-3 mb-6"><h3 class="font-semibold">Dataset Templates</h3><div id="dataset-presets" class="grid grid-cols-2 gap-2"><button class="preset-btn active" data-dataset="circle">Circle</button><button class="preset-btn" data-dataset="xor">XOR</button><button class="preset-btn" data-dataset="spiral">Spiral</button><button class="preset-btn" data-dataset="interleaved">Interleaved</button><button class="preset-btn" data-dataset="moons">Moons</button><button class="preset-btn" data-dataset="gaussian">Blobs</button><button class="preset-btn" data-dataset="ushape">U-Shape</button></div></div>
        <div class="space-y-3 mb-6"><h3 class="font-semibold">Network Presets</h3><div id="nn-presets" class="grid grid-cols-2 gap-2"><button class="preset-btn" data-preset="linear">Linear</button><button class="preset-btn" data-preset="xor">XOR Solver</button><button class="preset-btn" data-preset="moons">Moons Solver</button><button class="preset-btn" data-preset="spiral">Spiral Solver</button></div></div>
    </div>
    
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- STATE & CONFIG ---
    let nn_state = { isTraining: false, learningRate: 0.03, batchSize: 10, currentDataset: 'circle', networkArchitecture: [2, 2], activations: ['softmax'], epoch: 0, rafId: null };
    let builder_state = { architecture: [2, 4, 2], activations: ['relu', 'softmax'] };
    let threeState = { selectedNeuron: 0, viewMode: 'output' };
    let display_state = { showCharts: true };
    let network, trainX, trainY, lossChart, accuracyChart;
    
    // --- 3D SCENE & NN IMPLEMENTATION ---
    let threeScene, threeCamera, threeRenderer, threeControls, planeMesh, dataPointsObject, weightVectorHelper, biasPlaneHelper;
    let lossChartPlane, accuracyChartPlane;
    let draggableObjects = [];
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    let selectedObject = null;

    const ACTIVATION_FUNCTIONS = {
        relu: { func: (x) => Math.max(0, x), derivative: (x) => x > 0 ? 1 : 0, formula: "y = max(0, x)" },
        tanh: { func: (x) => Math.tanh(x), derivative: (x) => 1 - Math.pow(Math.tanh(x), 2), formula: "y = tanh(x)" },
        sigmoid: { func: (x) => 1 / (1 + Math.exp(-x)), derivative: (x) => { const s = 1 / (1 + Math.exp(-x)); return s * (1 - s); }, formula: "y = 1 / (1 + e⁻ˣ)" },
        softmax: { isOutput: true, formula: "softmax" }
    };

    const ACTIVATION_PATHS = {
        relu: "M-8,5 L0,5 L8,-5",
        tanh: "M-8,8 C-4,8 4,-8 8,-8",
        sigmoid: "M-8,8 C-4,8 4,0 8,0"
    };
    
    function initThreeJS() {
        const container = document.getElementById('three-canvas-container');
        threeScene = new THREE.Scene();
        threeCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 100);
        threeCamera.position.set(0, 2, 3.5);
        threeRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, canvas: document.getElementById('three-canvas') });
        threeRenderer.setPixelRatio(window.devicePixelRatio);
        threeRenderer.setSize(container.clientWidth, container.clientHeight);
        
        threeControls = new OrbitControls(threeCamera, threeRenderer.domElement);
        threeControls.enableDamping = true;
        threeScene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(2, 3, 2);
        threeScene.add(dirLight);

        const planeGeom = new THREE.PlaneGeometry(2.5, 2.5, 60, 60);
        const planeMat = new THREE.MeshStandardMaterial({ vertexColors: true, side: THREE.DoubleSide, metalness: 0.2, roughness: 0.8 });
        planeMesh = new THREE.Mesh(planeGeom, planeMat);
        planeMesh.rotation.x = -Math.PI / 2;
        threeScene.add(planeMesh);
        
        dataPointsObject = new THREE.Group();
        threeScene.add(dataPointsObject);
        weightVectorHelper = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1.2, 0xffff00, 0.1, 0.05);
        threeScene.add(weightVectorHelper);
        const biasPlaneGeom = new THREE.PlaneGeometry(3, 3);
        const biasPlaneMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
        biasPlaneHelper = new THREE.Mesh(biasPlaneGeom, biasPlaneMat);
        threeScene.add(biasPlaneHelper);

        const animate = () => { requestAnimationFrame(animate); threeControls.update(); threeRenderer.render(threeScene, threeCamera); };
        animate();
        
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                const { width, height } = entry.contentRect;
                 if (width > 0 && height > 0) {
                     threeCamera.aspect = width / height;
                     threeCamera.updateProjectionMatrix();
                     threeRenderer.setSize(width, height);
                 }
            }
        });
        resizeObserver.observe(container);

        threeRenderer.domElement.addEventListener('pointerdown', onPointerDown);
        threeRenderer.domElement.addEventListener('pointermove', onPointerMove);
        threeRenderer.domElement.addEventListener('pointerup', onPointerUp);
    }
    
    function update3DScene() {
        if (!planeMesh || !network) return;
        const positions = planeMesh.geometry.attributes.position;
        const colors = planeMesh.geometry.attributes.color || new THREE.BufferAttribute(new Float32Array(positions.count * 3), 3);
        const colorClass0 = new THREE.Color('#4f46e5'), colorClass1 = new THREE.Color('#16a34a');

        if (threeState.viewMode === 'output') {
             for (let i = 0; i < positions.count; i++) {
                 const x_in = positions.getX(i), y_in = positions.getY(i);
                 const probClass0 = network.predict([x_in, -y_in])[0];
                 positions.setZ(i, (probClass0 - 0.5) * 2);
                 const color = colorClass0.clone().lerp(colorClass1, 1 - probClass0);
                 colors.setXYZ(i, color.r, color.g, color.b);
             }
        } else {
            const firstHiddenLayer = network.layers[0];
            const neuronIndex = threeState.selectedNeuron;
            if (!firstHiddenLayer || neuronIndex >= firstHiddenLayer.biases.length) return;
            const { weights, biases, activation } = firstHiddenLayer;
            const [w1, w2, bias] = [weights[0][neuronIndex], weights[1][neuronIndex], biases[neuronIndex]];
            for (let i = 0; i < positions.count; i++) {
                const x_in = positions.getX(i), y_in = positions.getY(i);
                const z_pre = w1 * x_in + w2 * (-y_in) + bias;
                positions.setZ(i, activation.func(z_pre));
                const color = z_pre > 0 ? colorClass0 : colorClass1;
                const intensity = Math.min(1, Math.abs(z_pre) * 0.8);
                colors.setXYZ(i, color.r * intensity, color.g * intensity, color.b * intensity);
            }
            const weightVec = new THREE.Vector3(w1, w2, 0);
            const weightLen = weightVec.length() || 1;
            weightVec.normalize();
            weightVectorHelper.setDirection(new THREE.Vector3(weightVec.x, 0, weightVec.y));
            weightVectorHelper.setLength(Math.min(1.2, weightLen * 0.5));
            const dist = -bias / weightLen;
            biasPlaneHelper.position.set(dist * weightVec.x, 0, dist * weightVec.y);
            biasPlaneHelper.lookAt(weightVec.x, 0, weightVec.y);
        }
        positions.needsUpdate = true;
        colors.needsUpdate = true;
        planeMesh.geometry.setAttribute('color', colors);
        planeMesh.geometry.computeVertexNormals();
        updateDataPoints3D();
    }
    
    function updateDataPoints3D() {
        dataPointsObject.children.forEach(child => {
            const { x_in, y_in } = child.userData;
            if (threeState.viewMode === 'output') {
                child.position.y = (network.predict([x_in, y_in])[0] - 0.5) * 2 + 0.05;
            } else {
                 if (network.layers.length > 0 && network.layers[0].biases.length > threeState.selectedNeuron) {
                     child.position.y = network.getNeuronActivation([x_in, y_in], 0, threeState.selectedNeuron) + 0.05;
                 }
            }
        });
    }
    
    class NeuralNetwork {
        constructor(arch, acts) { this.layers = []; this.activations = acts.map(a => ACTIVATION_FUNCTIONS[a]); for (let i = 0; i < arch.length - 1; i++) { this.layers.push({ weights: Array.from({ length: arch[i] }, () => Array.from({ length: arch[i+1] }, () => Math.random() * 0.2 - 0.1)), biases: Array(arch[i+1]).fill(0), activation: this.activations[i] }); } }
        forward(inputs) { let current = inputs; const all_activations = [inputs]; const all_pre_activations = []; for (const l of this.layers) { const pre_act = Array(l.biases.length).fill(0).map((_,j) => l.biases[j] + current.reduce((s,val,i) => s + val*l.weights[i][j], 0)); all_pre_activations.push(pre_act); if (l.activation.isOutput) { const max = Math.max(...pre_act); const exps = pre_act.map(o => Math.exp(o - max)); const sum = exps.reduce((a, b) => a + b, 0); current = exps.map(e => e / (sum || 1)); } else { current = pre_act.map(o => l.activation.func(o)); } all_activations.push(current); } return { final: current, all: all_activations, pre: all_pre_activations }; }
        predict(inputs) { return this.forward(inputs).final; }
        getNeuronActivation(inputs, layerIdx, neuronIdx) { let c=inputs; for(let i=0;i<layerIdx;i++) c=this.layers[i].biases.map((_,j)=>this.layers[i].activation.func(this.layers[i].biases[j]+c.reduce((s,v,k)=>s+v*this.layers[i].weights[k][j],0))); return this.layers[layerIdx].activation.func(this.layers[layerIdx].biases[neuronIdx]+c.reduce((s,v,i)=>s+v*this.layers[layerIdx].weights[i][neuronIdx],0)); }
        train(batchX, batchY) { let totalLoss=0; const grads=this.layers.map(l=>({weights:l.weights.map(r=>r.map(()=>0)),biases:l.biases.map(()=>0)})); for(let i=0;i<batchX.length;i++){ const x=batchX[i], y=batchY[i]; const {final,all,pre}=this.forward(x); totalLoss-=Math.log(final[y]+1e-9); let errors=[...final]; errors[y]-=1; for(let l=this.layers.length-1;l>=0;l--){ const layer=this.layers[l]; const prev_acts=all[l]; const pre_acts=pre[l]; if(!layer.activation.isOutput)errors=errors.map((e,j)=>e*layer.activation.derivative(pre_acts[j])); const next_errors=Array(prev_acts.length).fill(0); for(let j=0;j<errors.length;j++){ for(let k=0;k<prev_acts.length;k++){ grads[l].weights[k][j]+=prev_acts[k]*errors[j]; next_errors[k]+=layer.weights[k][j]*errors[j]; } grads[l].biases[j]+=errors[j]; } errors=next_errors; } } for(let l=0;l<this.layers.length;l++){for(let i=0;i<this.layers[l].weights.length;i++){for(let j=0;j<this.layers[l].weights[i].length;j++){this.layers[l].weights[i][j]-=nn_state.learningRate*(grads[l].weights[i][j]/batchX.length)}}for(let i=0;i<this.layers[l].biases.length;i++){this.layers[l].biases[i]-=nn_state.learningRate*(grads[l].biases[i]/batchX.length)}} return totalLoss/batchX.length; }
    }
    function normalizeData(data, labels) { const xs=data.map(d=>d[0]), ys=data.map(d=>d[1]); const xMin=Math.min(...xs), xMax=Math.max(...xs), yMin=Math.min(...ys), yMax=Math.max(...ys); const range=Math.max(xMax-xMin,yMax-yMin)||1; return { data: data.map(([x,y])=>[(x-(xMin+xMax)/2)/range*2.5,(y-(yMin+yMax)/2)/range*2.5]), labels }; }
    function generateCircleData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const r=i<n/2?Math.random()*2:Math.random()*2+2.5; const a=Math.random()*2*Math.PI; data.push([r*Math.sin(a),r*Math.cos(a)]);labels.push(i<n/2?0:1); } return normalizeData(data,labels); }
    function generateXORData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const x=Math.random()*2-1, y=Math.random()*2-1; data.push([x,y]); labels.push((x>0&&y>0)||(x<0&&y<0)?0:1); } return normalizeData(data,labels); }
    function generateSpiralData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const r=(i% (n/2))/(n/2)*5; const a=1.75*(i%(n/2))/(n/2)*2*Math.PI+(i<n/2?0:Math.PI); data.push([r*Math.sin(a),r*Math.cos(a)]); labels.push(i<n/2?0:1); } return normalizeData(data,labels); }
    function generateInterleavedData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const x=Math.random()*2-1, y=Math.random()*2-1; data.push([x,y]); labels.push(Math.sin(5*x)>y?0:1); } return normalizeData(data,labels); }
    function generateMoonsData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const m=i<n/2, a=Math.PI*Math.random(), r=m?1:-1; data.push([r*Math.cos(a)+(m?0:1),r*Math.sin(a)+(m?0:0.3)]); labels.push(m?0:1); } return normalizeData(data,labels); }
    function generateGaussianData(n=200){ const data=[],labels=[], c=[[-1.5,1.5],[1.5,-1.5]]; for(let i=0;i<n;i++){ const s=c[i<n/2?0:1]; data.push([s[0]+(Math.random()-0.5)*1.5,s[1]+(Math.random()-0.5)*1.5]); labels.push(i<n/2?0:1); } return normalizeData(data,labels); }
    function generateUshapeData(n=200){ const data=[],labels=[]; for(let i=0;i<n;i++){ const isU=i<n*0.7; let x,y; if(isU){const a=Math.PI+Math.random()*Math.PI;x=2*Math.cos(a);y=2*Math.sin(a)}else{x=Math.random()*4-2;y=Math.random()*2-1.5} data.push([x,y]); labels.push(isU?0:1); } return normalizeData(data,labels); }
    const DATASETS = { circle: generateCircleData, xor: generateXORData, spiral: generateSpiralData, interleaved: generateInterleavedData, moons: generateMoonsData, gaussian: generateGaussianData, ushape: generateUshapeData };
    const NN_PRESETS = { linear:{dataset:'circle',architecture:[2,2],activations:['softmax']}, xor:{dataset:'xor',architecture:[2,4,2],activations:['relu','softmax']}, moons:{dataset:'moons',architecture:[2,8,2],activations:['tanh','softmax']}, spiral:{dataset:'spiral',architecture:[2,8,8,2],activations:['tanh','tanh','softmax']} };
    
    function updateAllVisualizations() {
        requestAnimationFrame(() => {
            update3DScene();
        });
    }

    function trainingStep() {
        const batchIndices = Array.from({length: nn_state.batchSize}, () => Math.floor(Math.random() * trainX.length));
        const batchX = batchIndices.map(i => trainX[i]);
        const batchY = batchIndices.map(i => trainY[i]);
        const loss = network.train(batchX, batchY);
        
        if (nn_state.epoch % 10 === 0) {
            let correct = 0;
            trainX.forEach((x, i) => { if (network.predict(x).indexOf(Math.max(...network.predict(x))) === trainY[i]) correct++; });
            updateCharts(nn_state.epoch, loss, correct / trainX.length);
        }
        if (nn_state.epoch % 5 === 0) updateAllVisualizations();
        
        document.getElementById('epoch-counter').textContent = nn_state.epoch;
        nn_state.epoch++;
        if (nn_state.isTraining) nn_state.rafId = requestAnimationFrame(trainingStep);
    }
    
    function toggleTraining() {
        nn_state.isTraining = !nn_state.isTraining;
        document.getElementById('play-icon').classList.toggle('hidden', nn_state.isTraining);
        document.getElementById('pause-icon').classList.toggle('hidden', !nn_state.isTraining);
        document.getElementById('play-pause-text').textContent = nn_state.isTraining ? 'Pause' : 'Play';
        if (nn_state.isTraining) trainingStep();
        else cancelAnimationFrame(nn_state.rafId);
    }

    function fullResetNN() {
        if(nn_state.isTraining) toggleTraining();
        nn_state.epoch = 0;
        const { data, labels } = DATASETS[nn_state.currentDataset]();
        trainX = data; trainY = labels;
        const outputSize = Math.max(...labels) + 1;
        
        nn_state.networkArchitecture = [...builder_state.architecture];
        nn_state.networkArchitecture[nn_state.networkArchitecture.length - 1] = outputSize;
        nn_state.activations = [...builder_state.activations];
        
        network = new NeuralNetwork(nn_state.networkArchitecture, nn_state.activations);
        if (lossChart) {
            lossChart.data.labels = [];
            lossChart.data.datasets[0].data = [];
            accuracyChart.data.labels = [];
            accuracyChart.data.datasets[0].data = [];
            updateCharts(0, null, null);
        }
        document.getElementById('epoch-counter').textContent = 0;
        document.querySelectorAll('#dataset-presets button').forEach(b => b.classList.toggle('active', b.dataset.dataset === nn_state.currentDataset));
        populateNeuronSelector();
        
        dataPointsObject.clear();
        const pointGeom = new THREE.SphereGeometry(0.04, 16, 16);
        const matClass0 = new THREE.MeshBasicMaterial({color: 0x6366f1});
        const matClass1 = new THREE.MeshBasicMaterial({color: 0x22c55e});
        trainX.forEach((p, i) => {
            const point = new THREE.Mesh(pointGeom, trainY[i] === 0 ? matClass0 : matClass1);
            point.position.set(p[0], 0.05, p[1]);
            point.userData = { x_in: p[0], y_in: p[1] };
            dataPointsObject.add(point);
        });
        updateAllVisualizations();
    }
    
    function applyNNPreset(presetKey) {
        if(nn_state.isTraining) toggleTraining();
        const preset = NN_PRESETS[presetKey];
        nn_state.currentDataset = preset.dataset;
        builder_state.architecture = [...preset.architecture];
        builder_state.activations = [...preset.activations];
        document.querySelectorAll('#nn-presets button').forEach(b => b.classList.remove('active'));
        document.querySelector(`#nn-presets button[data-preset="${presetKey}"]`).classList.add('active');
        fullResetNN();
    }
    
    function setupCharts() {
        const backgroundPlugin = {
            id: 'customCanvasBackgroundColor',
            beforeDraw: (chart) => {
                const {ctx} = chart;
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.clearRect(0, 0, chart.width, chart.height); 
                ctx.fillStyle = 'rgba(31, 41, 55, 0.9)';
                ctx.fillRect(0, 0, chart.width, chart.height);
                ctx.restore();
            }
        };

        const chartOptions = {
            responsive: true, maintainAspectRatio: false, animation: false,
            scales: { 
                y: { beginAtZero: true, ticks:{color:'#e5e7eb', font: {size: 14}}}, 
                x: { ticks:{color:'#e5e7eb', display:false}} 
            }, 
            plugins: { 
                legend: { display: false },
                title: { display: true, text: 'Loss', color: '#e5e7eb', font: { size: 16 } },
            },
            layout: { padding: 10 }
        };
        
        const lossCanvas = document.getElementById('loss-canvas');
        lossCanvas.width = 400; lossCanvas.height = 200;
        lossChart = new Chart(lossCanvas.getContext('2d'), { 
            type: 'line', 
            data: { labels: [], datasets: [{ data: [], borderColor: '#f87171', tension: 0.1, pointRadius: 0 }] }, 
            options: chartOptions,
            plugins: [backgroundPlugin]
        });

        const accCanvas = document.getElementById('accuracy-canvas');
        accCanvas.width = 400; accCanvas.height = 200;
        accuracyChart = new Chart(accCanvas.getContext('2d'), { 
            type: 'line', 
            data: { labels: [], datasets: [{ data: [], borderColor: '#4ade80', tension: 0.1, pointRadius: 0 }] }, 
            options: {...chartOptions, plugins: {...chartOptions.plugins, title: {...chartOptions.plugins.title, text: 'Accuracy'}}, scales: {y: {min:0, max:1, ticks:{color:'#e5e7eb', font:{size:14}}}}},
            plugins: [backgroundPlugin]
        });

        lossChartPlane = createChartPlane(lossCanvas, new THREE.Vector3(-2, 1.5, -1));
        accuracyChartPlane = createChartPlane(accCanvas, new THREE.Vector3(2, 1.5, -1));
    }
    
    function updateCharts(epoch, loss, accuracy) {
        if (!lossChart || ! accuracyChart) return;
        const maxDataPoints = 100;

        if (epoch !== 0) {
            if (lossChart.data.labels.length >= maxDataPoints) {
                 lossChart.data.labels.shift();
                 lossChart.data.datasets[0].data.shift();
            }
             if (accuracyChart.data.labels.length >= maxDataPoints) {
                 accuracyChart.data.labels.shift();
                 accuracyChart.data.datasets[0].data.shift();
            }
            if (loss !== null) {
                lossChart.data.labels.push(epoch);
                lossChart.data.datasets[0].data.push(loss);
            }
            if (accuracy !== null) {
                accuracyChart.data.labels.push(epoch);
                accuracyChart.data.datasets[0].data.push(accuracy);
            }
        } else {
            lossChart.data.labels = [];
            lossChart.data.datasets[0].data = [];
            accuracyChart.data.labels = [];
            accuracyChart.data.datasets[0].data = [];
        }
        
        lossChart.update('none');
        accuracyChart.update('none');

        lossChartPlane.material.map.needsUpdate = true;
        accuracyChartPlane.material.map.needsUpdate = true;
    }

    function createChartPlane(canvas, position) {
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
        const geometry = new THREE.PlaneGeometry(2, 1);
        const plane = new THREE.Mesh(geometry, material);
        plane.position.copy(position);
        plane.userData.isDraggable = true;
        threeScene.add(plane);
        draggableObjects.push(plane);
        return plane;
    }

    function populateNeuronSelector() {
        const selector = document.getElementById('neuron-select');
        selector.innerHTML = '';
        if(nn_state.networkArchitecture.length < 3) return;
        const numNeurons = nn_state.networkArchitecture[1];
        if (numNeurons) {
            for (let i = 0; i < numNeurons; i++) {
                const option = document.createElement('option');
                option.value = i; option.textContent = `Hidden 1, Neuron ${i+1}`;
                selector.appendChild(option);
            }
        }
        selector.value = threeState.selectedNeuron < numNeurons ? threeState.selectedNeuron : 0;
    }
    
    function onPointerDown(event) {
        const canvas = threeRenderer.domElement;
        const rect = canvas.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(pointer, threeCamera);
        const intersects = raycaster.intersectObjects(draggableObjects);

        if(intersects.length > 0) {
            selectedObject = intersects[0].object;
            threeControls.enabled = false;
        }
    }
    function onPointerMove(event) {
        if (selectedObject) {
            const canvas = threeRenderer.domElement;
            const rect = canvas.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(pointer, threeCamera);
            const planeIntersect = new THREE.Vector3();
            const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(threeCamera.getWorldDirection(new THREE.Vector3()).negate(), selectedObject.position);
            raycaster.ray.intersectPlane(plane, planeIntersect);
            selectedObject.position.copy(planeIntersect);
        }
    }
    function onPointerUp() {
        selectedObject = null;
        threeControls.enabled = true;
    }
    
    function renderBuilder() {
        const svg = d3.select("#builder-svg");
        svg.selectAll("*").remove();
        const { width, height } = svg.node().getBoundingClientRect();
        if (width === 0) return;

        const arch = [2, ...builder_state.architecture.slice(1, -1), 2];
        const layerCount = arch.length;
        
        const maxLayerWidth = 150;
        const minGap = 20;
        let effectiveLayerWidth = Math.min(maxLayerWidth, (width - (layerCount + 1) * minGap) / layerCount);
        let layerGap = (width - layerCount * effectiveLayerWidth) / (layerCount + 1);

        const layersData = arch.map((size, i) => Array.from({ length: size }, (_, j) => ({ layer: i, neuron: j, size: size })));
        
        const nodes = layersData.flat();
        nodes.forEach(n => {
            n.x = layerGap + effectiveLayerWidth / 2 + n.layer * (effectiveLayerWidth + layerGap);
            n.y = (n.neuron + 1) * (height-120) / (n.size + 1) + 60;
        });

        const links = [];
        for (let i = 0; i < layerCount - 1; i++) {
            for (let j = 0; j < layersData[i].length; j++) {
                for (let k = 0; k < layersData[i+1].length; k++) {
                    links.push({ source: nodes.find(n => n.layer === i && n.neuron === j), target: nodes.find(n => n.layer === i + 1 && n.neuron === k) });
                }
            }
        }

        svg.append("g").selectAll("path").data(links).join("path").attr("d", d => `M${d.source.x},${d.source.y} L${d.target.x},${d.target.y}`).attr("stroke", "#4b5563").attr("stroke-width", 1.5);
        
        const layerGroups = svg.selectAll("g.layer-group").data(layersData).join("g");
        
        layerGroups.append("rect")
            .attr("x", d => layerGap + d[0].layer * (effectiveLayerWidth + layerGap))
            .attr("y", 20)
            .attr("width", effectiveLayerWidth)
            .attr("height", height - 40)
            .attr("fill", "rgba(31, 41, 55, 0.5)")
            .attr("stroke", "#4b5563")
            .attr("stroke-width", 1)
            .attr("rx", 12);

        layerGroups.append("text").attr("x", d => layerGap + effectiveLayerWidth / 2 + d[0].layer * (effectiveLayerWidth + layerGap)).attr("y", 45).attr("text-anchor", "middle").attr("font-size", "14px").attr("font-weight", "600").attr("fill", "#9ca3af").text((d, i) => i === 0 ? "Input" : i === layerCount - 1 ? "Output" : `Hidden ${i}`);

        const nodeGroups = svg.selectAll("g.builder-node").data(nodes).join("g").attr("class", d => `builder-node ${d.layer === 0 || d.layer === layerCount - 1 ? 'io-node' : ''}`).attr("transform", d => `translate(${d.x},${d.y})`).on("mouseover", function(e, d) { if (d.layer > 0 && d.layer < layerCount - 1 && arch[d.layer] > 1) { const g = d3.select(this).append("g").attr("class", "delete-btn"); g.append("circle").attr("r", 8).attr("fill", "#ef4444"); g.append("text").text("-").attr("fill", "white").attr("text-anchor", "middle").attr("dy", ".35em").style("font-weight", "bold"); g.on("click", (e, d) => { e.stopPropagation(); builder_state.architecture[d.layer]--; renderBuilder(); }); } }).on("mouseout", function() { d3.select(this).select(".delete-btn").remove(); });
        
        nodeGroups.append("circle").attr("r", 15).attr("fill", d => (d.layer === 0 || d.layer === layerCount-1) ? "#10b981" : "#283142").attr("stroke", "#4b5563").attr("stroke-width", 2);

        const hiddenNodeGroups = nodeGroups.filter(d => d.layer > 0 && d.layer < layerCount - 1);
        hiddenNodeGroups.append("path")
            .attr("d", d => ACTIVATION_PATHS[builder_state.activations[d.layer-1]])
            .attr("stroke", "#a5b4fc")
            .attr("stroke-width", 1.5)
            .attr("fill", "none");

        const hiddenLayersData = layersData.slice(1, -1);
        svg.selectAll("g.add-neuron").data(hiddenLayersData.filter(d => d.length < 8)).enter().append("g").attr("class", "add-btn").attr("transform", d => `translate(${layerGap + effectiveLayerWidth/2 + d[0].layer * (effectiveLayerWidth + layerGap)}, ${(d.length + 1) * (height-120) / (d.length + 2) + 60})`).on("click", (e, d) => { if (builder_state.architecture[d[0].layer] < 8) { builder_state.architecture[d[0].layer]++; renderBuilder(); } });

        if (layerCount - 2 < 4) {
             svg.selectAll("g.add-layer-btn").data(d3.range(layerCount - 1)).enter().append("g").attr("class", "add-btn").attr("transform", (d, i) => `translate(${(i + 1) * (effectiveLayerWidth + layerGap) + layerGap/2}, ${height / 2})`).on("click", (e, i) => { if (builder_state.architecture.length - 2 < 4) { builder_state.architecture.splice(i + 1, 0, 4); builder_state.activations.splice(i, 0, 'relu'); renderBuilder(); } }).append("circle").attr("r", 15).attr("fill", "#374151").attr("stroke", "#6b7280").attr("stroke-width", 2).style("stroke-dasharray", "3 3");
        }

        const hiddenLayerGroups = layerGroups.filter((d, i) => i > 0 && i < layerCount - 1);

        hiddenLayerGroups.append("text")
            .attr("class", "delete-btn")
            .attr("x", d => layerGap + effectiveLayerWidth - 15 + d[0].layer * (effectiveLayerWidth + layerGap))
            .attr("y", 45)
            .attr("text-anchor", "middle")
            .attr("font-size", "20px")
            .attr("fill", "#ef4444")
            .text("✕")
            .on("click", (e, d) => {
                const layerIndex = d[0].layer;
                if (builder_state.architecture.length > 2) {
                    builder_state.architecture.splice(layerIndex, 1);
                    builder_state.activations.splice(layerIndex - 1, 1);
                    renderBuilder();
                }
            });

        hiddenLayerGroups.append("foreignObject")
            .attr("x", d => layerGap + 10 + d[0].layer * (effectiveLayerWidth + layerGap))
            .attr("y", height - 65)
            .attr("width", effectiveLayerWidth - 20)
            .attr("height", 30)
            .html((d, i) => {
                const activation = builder_state.activations[i];
                let options = `<option value="relu" ${activation === 'relu' ? 'selected' : ''}>ReLU</option>`;
                options += `<option value="tanh" ${activation === 'tanh' ? 'selected' : ''}>Tanh</option>`;
                options += `<option value="sigmoid" ${activation === 'sigmoid' ? 'selected' : ''}>Sigmoid</option>`;
                return `<select class="builder-select w-full h-full text-center" onchange="(function(e, i){ this.builder_state.activations[i] = e.target.value; this.renderBuilder(); }).call(window, event, ${i})">${options}</select>`;
            });

        hiddenLayerGroups.append("text")
             .attr("x", d => layerGap + effectiveLayerWidth/2 + d[0].layer * (effectiveLayerWidth + layerGap))
             .attr("y", height - 80)
             .attr("text-anchor", "middle")
             .attr("font-family", "monospace")
             .attr("font-size", "12px")
             .attr("fill", "#818cf8")
             .text((d, i) => ACTIVATION_FUNCTIONS[builder_state.activations[i]].formula);
    }

    // --- INIT & BINDINGS ---
    initThreeJS();
    setupCharts();
    window.renderBuilder = renderBuilder;
    window.builder_state = builder_state;
    
    document.getElementById('settings-btn').addEventListener('click', () => { document.getElementById('settings-panel').classList.add('open'); document.getElementById('settings-backdrop').classList.add('open'); });
    const closeSettings = () => { document.getElementById('settings-panel').classList.remove('open'); document.getElementById('settings-backdrop').classList.remove('open'); };
    document.getElementById('close-settings-btn').addEventListener('click', closeSettings);
    document.getElementById('settings-backdrop').addEventListener('click', closeSettings);
    
    document.getElementById('play-pause-btn').addEventListener('click', toggleTraining);
    document.getElementById('reset-btn').addEventListener('click', fullResetNN);
    document.getElementById('three-d-view-selector').addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') { threeState.viewMode = e.target.dataset.view; document.querySelectorAll('#three-d-view-selector button').forEach(b => b.classList.remove('active')); e.target.classList.add('active'); document.getElementById('neuron-selector-container').classList.toggle('hidden', threeState.viewMode !== 'neuron'); weightVectorHelper.visible = biasPlaneHelper.visible = (threeState.viewMode === 'neuron'); update3DScene(); } });
    document.getElementById('nn-presets').addEventListener('click', e => { if (e.target.tagName === 'BUTTON') { applyNNPreset(e.target.dataset.preset); } });
    document.getElementById('dataset-presets').addEventListener('click', e => { if (e.target.tagName === 'BUTTON') { nn_state.currentDataset = e.target.dataset.dataset; fullResetNN(); } });
    document.getElementById('lr-slider').addEventListener('input', e => { nn_state.learningRate = parseFloat(e.target.value); document.getElementById('lr-value').textContent = nn_state.learningRate.toFixed(3); });
    document.getElementById('batch-size-slider').addEventListener('input', e => { nn_state.batchSize = parseInt(e.target.value); document.getElementById('batch-size-value').textContent = nn_state.batchSize; });
    document.getElementById('neuron-select').addEventListener('change', e => { threeState.selectedNeuron = parseInt(e.target.value); update3DScene(); });
    
    const chartsToggle = document.getElementById('charts-toggle');
    const chartsToggleKnob = document.getElementById('charts-toggle-knob');
    chartsToggle.addEventListener('click', () => {
        display_state.showCharts = !display_state.showCharts;
        lossChartPlane.visible = display_state.showCharts;
        accuracyChartPlane.visible = display_state.showCharts;

        if (display_state.showCharts) {
            chartsToggle.classList.remove('bg-gray-600');
            chartsToggle.classList.add('bg-indigo-500');
            chartsToggleKnob.classList.replace('translate-x-1', 'translate-x-6');
        } else {
            chartsToggle.classList.remove('bg-indigo-500');
            chartsToggle.classList.add('bg-gray-600');
            chartsToggleKnob.classList.replace('translate-x-6', 'translate-x-1');
        }
    });

    function switchView(viewName) {
        document.getElementById('three-d-view').classList.toggle('active', viewName === 'trainer');
        document.getElementById('builder-view').classList.toggle('active', viewName === 'builder');
        document.getElementById('nav-trainer').classList.toggle('active', viewName === 'trainer');
        document.getElementById('nav-builder').classList.toggle('active', viewName === 'builder');
        document.getElementById('apply-architecture-btn').classList.toggle('hidden', viewName !== 'builder');
        
        if(viewName === 'builder') {
            requestAnimationFrame(renderBuilder);
        }
    }
    document.getElementById('nav-trainer').addEventListener('click', () => switchView('trainer'));
    document.getElementById('nav-builder').addEventListener('click', () => switchView('builder'));
    document.getElementById('apply-architecture-btn').addEventListener('click', () => {
        fullResetNN();
        switchView('trainer');
    });

    applyNNPreset('linear');
    document.querySelector('#three-d-view-selector button[data-view="output"]').classList.add('active');
    switchView('trainer');

</script>
</body>
</html>

