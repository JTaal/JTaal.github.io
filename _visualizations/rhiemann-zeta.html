<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-g">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Riemann Zeta Function Visualization</title>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            color: #e0e0e0;
            background-color: #121212;
            overflow: hidden;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            max-width: 800px;
            left: 50%;
            transform: translateX(-50%);
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(40, 40, 40, 0.8);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            display: flex;
            gap: 15px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            border: none;
            background-color: #3d3d3d;
            color: #fff;
            transition: background-color 0.3s, transform 0.1s;
        }
        button:hover {
            background-color: #555;
        }
        button:active {
            transform: scale(0.95);
        }
        #plotContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a1a;
            display: none; /* Initially hidden */
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #plotCanvas {
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #plotControls {
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(40, 40, 40, 0.8);
            padding: 10px;
            border-radius: 8px;
        }
        #plotControls input {
            width: 80px;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #666;
            background-color: #222;
            color: #eee;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Riemann Zeta Function Visualization</h1>
        <p>Drag to rotate, scroll to zoom, right-click and drag to pan.</p>
    </div>

    <div id="plotContainer">
        <canvas id="plotCanvas"></canvas>
        <div id="plotControls">
            <button id="prevBtn">&lt;&lt; Prev</button>
            <span>t = </span>
            <input type="number" id="tOffsetInput" value="0">
            <button id="goBtn">Go</button>
            <button id="nextBtn">Next &gt;&gt;</button>
        </div>
    </div>

    <div class="controls">
        <button id="transformViewBtn">3D Transformation</button>
        <button id="zerosViewBtn">Zeros on Critical Line</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SCENE SETUP ---
        let scene, camera, renderer, controls;
        let plane, originalPositions;
        const VIEW_WIDTH = 40, VIEW_HEIGHT = 40;
        const SEGMENTS = 50;

        // --- 2D PLOT SETUP ---
        const plotContainer = document.getElementById('plotContainer');
        const plotCanvas = document.getElementById('plotCanvas');
        const plotCtx = plotCanvas.getContext('2d');
        let tOffset = 0;
        const tRange = 50;

        // The imaginary parts of the first 100 non-trivial zeros
        const knownZeros = [
            14.134725, 21.022040, 25.010858, 30.424876, 32.935062, 37.586178, 40.918719, 43.327073, 48.005151, 49.773832,
            52.970321, 56.446248, 59.347044, 60.831779, 65.085805, 67.079811, 69.546402, 72.067158, 75.704691, 77.144840,
            79.337375, 82.910381, 84.735493, 87.425275, 88.809111, 92.491899, 94.651344, 95.870634, 98.831194, 101.317851,
            103.725538, 105.446622, 107.168611, 111.029536, 111.874659, 114.320221, 116.226689, 118.790783, 121.370125, 122.947200,
            124.256818, 127.516684, 129.578704, 131.087689, 133.497737, 134.756590, 138.058316, 139.721187, 141.123707, 143.111845,
            146.000986, 147.422765, 150.053521, 150.925257, 153.024662, 156.112909, 157.597591, 158.849936, 161.411009, 163.030707,
            165.401444, 166.496921, 169.094519, 170.183791, 172.291617, 173.411039, 174.754115, 176.448748, 178.373523, 179.916484,
            182.015019, 183.085891, 185.341489, 187.214413, 188.403341, 189.870879, 192.033113, 193.318253, 195.033219, 196.876326,
            198.015753, 201.218903, 202.732703, 204.203337, 205.374020, 207.753344, 209.009772, 210.224335, 212.046552, 213.334751,
            214.347168, 216.599775, 217.794610, 219.231111, 221.341541, 222.793739, 224.161113, 225.334401, 227.818424, 229.337463
        ];


        // --- COMPLEX NUMBER ARITHMETIC ---
        class Complex {
            constructor(re = 0, im = 0) { this.re = re; this.im = im; }
            add(c) { return new Complex(this.re + c.re, this.im + c.im); }
            sub(c) { return new Complex(this.re - c.re, this.im - c.im); }
            mul(c) { return new Complex(this.re * c.re - this.im * c.im, this.re * c.im + this.im * c.re); }
            div(c) {
                const d = c.re * c.re + c.im * c.im;
                if (d === 0) return new Complex(Infinity, Infinity);
                return new Complex((this.re * c.re + this.im * c.im) / d, (this.im * c.re - this.re * c.im) / d);
            }
            static fromPolar(r, theta) { return new Complex(r * Math.cos(theta), r * Math.sin(theta)); }
            magnitude() { return Math.sqrt(this.re * this.re + this.im * this.im); }
            phase() { return Math.atan2(this.im, this.re); }
        }

        // --- SPECIAL FUNCTIONS: GAMMA and ZETA ---
        const g = 7;
        const p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
        function gamma(z) {
            if (z.re < 0.5) {
                const pi = new Complex(Math.PI, 0); const one = new Complex(1, 0);
                const sinPiZ = sin(pi.mul(z));
                if (sinPiZ.magnitude() < 1e-9) return new Complex(Infinity, Infinity);
                return pi.div(sin(pi.mul(z)).mul(gamma(one.sub(z))));
            } else {
                z = z.sub(new Complex(1, 0)); let x = new Complex(p[0], 0);
                for (let i = 1; i < g + 2; i++) { x = x.add(new Complex(p[i], 0).div(z.add(new Complex(i, 0)))); }
                const t = z.add(new Complex(g + 0.5, 0));
                const sqrt2pi = new Complex(Math.sqrt(2 * Math.PI), 0);
                let term1 = pow(t, z.add(new Complex(0.5, 0)));
                let term2 = exp(t.mul(new Complex(-1, 0)));
                return sqrt2pi.mul(term1).mul(term2).mul(x);
            }
        }
        function zeta(s) {
            if (Math.abs(s.re - 1) < 1e-9 && Math.abs(s.im) < 1e-9) return new Complex(Infinity, Infinity);
            if (s.re < 0) {
                const one = new Complex(1, 0); const two = new Complex(2, 0); const pi = new Complex(Math.PI, 0);
                const reflected_s = one.sub(s);
                const term1 = pow(two, s); const term2 = pow(pi, s.sub(one)); const term3 = sin(pi.mul(s).div(two)); const term4 = gamma(one.sub(s));
                const term5 = zeta(reflected_s);
                return term1.mul(term2).mul(term3).mul(term4).mul(term5);
            }
            const one = new Complex(1, 0); const two = new Complex(2, 0);
            const prefactor = one.div(one.sub(pow(two, one.sub(s))));
            let eta_sum = new Complex(0, 0);
            for (let i = 1; i <= 1000; i++) {
                const term = pow(new Complex(i, 0), s.mul(new Complex(-1,0)));
                if (i % 2 === 1) { eta_sum = eta_sum.add(term); } else { eta_sum = eta_sum.sub(term); }
            }
            return prefactor.mul(eta_sum);
        }
        function pow(base, exp) {
            if (base.magnitude() === 0) return new Complex(0,0);
            const logBase = new Complex(Math.log(base.magnitude()), base.phase());
            const z = logBase.mul(exp);
            return Complex.fromPolar(Math.exp(z.re), z.im);
        }
        function exp(c) { return Complex.fromPolar(Math.exp(c.re), c.im); }
        function sin(c) {
            const ez = exp(new Complex(-c.im, c.re));
            const e_iz = exp(new Complex(c.im, -c.re));
            return ez.sub(e_iz).div(new Complex(0, 2));
        }

        // --- 3D VISUALIZATION ---
        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            
            const geometry = new THREE.PlaneGeometry(VIEW_WIDTH, VIEW_HEIGHT, SEGMENTS, SEGMENTS);
            
            const material = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vColor;

                    // HSV to RGB conversion function
                    vec3 hsv2rgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }

                    void main() {
                        // Color is based on the phase (argument) of the original complex number
                        float angle = atan(position.y, position.x);
                        float hue = (angle + 3.14159) / (2.0 * 3.14159);
                        vColor = hsv2rgb(vec3(hue, 0.8, 0.9));
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;

                    void main() {
                        gl_FragColor = vec4(vColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide,
                wireframe: true
            });

            plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);
            
            originalPositions = Array.from(plane.geometry.attributes.position.array);
            camera.position.z = 25;
            camera.position.y = 15;
            
            transformPlane();
            animate3D();
        }

        function transformPlane() {
            const positions = plane.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                let s = new Complex(originalPositions[i], originalPositions[i + 1]);
                let z_s = zeta(s);
                let u = z_s.re;
                let v = z_s.im;
                const clampValue = 40;
                if (isFinite(u) && isFinite(v)) {
                    positions[i] = Math.max(-clampValue, Math.min(clampValue, u));
                    positions[i+1] = Math.max(-clampValue, Math.min(clampValue, v));
                    positions[i+2] = 0;
                } else {
                    positions[i] = clampValue * 2 * Math.sign(u || 0);
                    positions[i+1] = clampValue * 2 * Math.sign(v || 0);
                    positions[i+2] = 0;
                }
            }
            plane.geometry.attributes.position.needsUpdate = true;
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 2D ZEROS PLOT ---
        function drawZerosPlot(t_offset = 0) {
            plotContainer.style.display = 'flex';
            if (renderer) renderer.domElement.style.display = 'none';

            const width = Math.min(window.innerWidth * 0.95, 1000);
            const height = Math.min(window.innerHeight * 0.8, 600);
            plotCanvas.width = width; plotCanvas.height = height;

            const tMin = t_offset, tMax = t_offset + tRange;
            const yMin = -4, yMax = 4;
            const padding = 60;
            const plotWidth = width - 2 * padding; const plotHeight = height - 2 * padding;

            function toScreenX(t) { return padding + (t - tMin) / (tMax - tMin) * plotWidth; }
            function toScreenY(y) { return height - padding - (y - yMin) / (yMax - yMin) * plotHeight; }

            plotCtx.fillStyle = '#1a1a1a'; plotCtx.fillRect(0, 0, width, height);
            plotCtx.strokeStyle = '#888'; plotCtx.lineWidth = 1;
            plotCtx.beginPath(); plotCtx.moveTo(padding, toScreenY(0)); plotCtx.lineTo(width - padding, toScreenY(0)); plotCtx.moveTo(toScreenX(tMin), padding); plotCtx.lineTo(toScreenX(tMin), height - padding); plotCtx.stroke();
            plotCtx.fillStyle = '#ccc'; plotCtx.font = '12px Arial'; plotCtx.textAlign = 'center'; plotCtx.textBaseline = 'top';
            for (let t = Math.ceil(tMin / 5) * 5; t <= tMax; t += 5) { plotCtx.fillText(t, toScreenX(t), toScreenY(0) + 5); }
            plotCtx.fillText("t (imaginary component of s = 0.5 + it)", width/2, height - 25);
            plotCtx.textAlign = 'right'; plotCtx.textBaseline = 'middle';
            for (let y = yMin; y <= yMax; y += 1) { if(y!==0) plotCtx.fillText(y, padding - 10, toScreenY(y)); }

            plotCtx.lineWidth = 2;
            ['#4a90e2', '#f5a623'].forEach((color, index) => {
                plotCtx.strokeStyle = color; plotCtx.beginPath(); let first = true;
                for (let t = tMin; t < tMax; t += 0.1) {
                    const s = new Complex(0.5, t); const z = zeta(s);
                    const val = (index === 0) ? z.re : z.im;
                    if (isFinite(val)) {
                        if (first) { plotCtx.moveTo(toScreenX(t), toScreenY(val)); first = false; } else { plotCtx.lineTo(toScreenX(t), toScreenY(val)); }
                    }
                }
                plotCtx.stroke();
            });

            plotCtx.fillStyle = 'red'; plotCtx.font = 'bold 12px Arial';
            knownZeros.filter(t => t >= tMin && t <= tMax).forEach(t => {
                const x = toScreenX(t); plotCtx.beginPath(); plotCtx.arc(x, toScreenY(0), 5, 0, 2 * Math.PI); plotCtx.fill();
                plotCtx.fillText(t.toFixed(2), x, toScreenY(0) - 15);
            });
            
            plotCtx.fillStyle = '#4a90e2'; plotCtx.fillRect(width - padding - 100, padding, 10, 10);
            plotCtx.fillStyle = '#ccc'; plotCtx.textAlign = 'left'; plotCtx.fillText('Re(ζ(0.5 + it))', width - padding - 85, padding + 5);
            plotCtx.fillStyle = '#f5a623'; plotCtx.fillRect(width - padding - 100, padding + 20, 10, 10);
            plotCtx.fillText('Im(ζ(0.5 + it))', width - padding - 85, padding + 25);
        }

        // --- UI and EVENT LISTENERS ---
        document.getElementById('transformViewBtn').addEventListener('click', () => {
            plotContainer.style.display = 'none';
            if (renderer) renderer.domElement.style.display = 'block';
        });
        document.getElementById('zerosViewBtn').addEventListener('click', () => { drawZerosPlot(tOffset); });
        
        const tOffsetInput = document.getElementById('tOffsetInput');
        document.getElementById('nextBtn').addEventListener('click', () => { tOffset += tRange; tOffsetInput.value = tOffset; drawZerosPlot(tOffset); });
        document.getElementById('prevBtn').addEventListener('click', () => { tOffset = Math.max(0, tOffset - tRange); tOffsetInput.value = tOffset; drawZerosPlot(tOffset); });
        document.getElementById('goBtn').addEventListener('click', () => { const val = parseFloat(tOffsetInput.value); if (!isNaN(val)) { tOffset = Math.max(0, val); drawZerosPlot(tOffset); } });
        tOffsetInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') { document.getElementById('goBtn').click(); } });

        window.addEventListener('resize', () => {
            if (renderer && plotContainer.style.display === 'none') {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
            }
            if (plotContainer.style.display !== 'none') { drawZerosPlot(tOffset); }
        });

        init3D();
    </script>
</body>
</html>

