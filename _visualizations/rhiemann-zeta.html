<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Riemann Zeta Function Visualization</title>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            color: #e0e0e0;
            background-color: #121212;
            overflow: hidden;
        }
        canvas { 
            display: block; 
        }
        .info-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            max-width: 350px;
        }
        details {
            background: rgba(40, 40, 40, 0.85);
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        summary {
            padding: 12px 15px;
            font-weight: bold;
            cursor: pointer;
            outline: none;
            list-style: none;
        }
        summary::-webkit-details-marker { display: none; }
        summary::before {
            content: '►';
            margin-right: 8px;
            font-size: 0.8em;
            transition: transform 0.2s;
        }
        details[open] summary::before {
            transform: rotate(90deg);
        }
        .content-box {
            padding: 0 15px 15px 15px;
            border-top: 1px solid #555;
            font-size: 0.9em;
            line-height: 1.5;
            max-height: 50vh;
            overflow-y: auto;
        }
        .content-box h4 {
             margin-top: 20px;
             padding-top: 15px;
             border-top: 1px solid #444;
        }
        .calculator-container {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-wrap: wrap;
        }
        .calculator-container input {
            width: 55px;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #666;
            background-color: #222;
            color: #eee;
            text-align: center;
        }
        .calculator-container button {
            padding: 5px 10px;
            font-size: 14px;
        }
        #zetaResult {
            margin-top: 10px;
            font-weight: bold;
            font-size: 1.1em;
            color: #4a90e2;
            text-align: center;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(40, 40, 40, 0.8);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            display: flex;
            gap: 15px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            border: none;
            background-color: #3d3d3d;
            color: #fff;
            transition: background-color 0.3s, transform 0.1s;
        }
        button:hover {
            background-color: #555;
        }
        button:active {
            transform: scale(0.95);
        }
        #view3d-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }
        .settings-panel {
            background: rgba(40, 40, 40, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 250px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            margin-top: 10px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .settings-panel h4 { margin: 15px 0 10px 0; text-align: center; font-weight: bold; border-bottom: 1px solid #555; padding-bottom: 8px;}
        .settings-panel div { display: flex; justify-content: space-between; align-items: center; font-size: 0.9em; }
        .settings-panel input[type="range"] { width: 110px; }
        .settings-panel input[type="color"] { border: none; background: none; width: 30px; height: 30px; padding: 0; cursor: pointer; }
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #4a90e2; }
        input:checked + .slider:before { transform: translateX(20px); }

        #plotContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a1a;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #plotCanvas { border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #plotControls { margin-top: 15px; display: flex; align-items: center; gap: 10px; background: rgba(40, 40, 40, 0.8); padding: 10px; border-radius: 8px; }
        #plotControls input { width: 80px; padding: 8px; border-radius: 5px; border: 1px solid #666; background-color: #222; color: #eee; text-align: center; }
        .hidden { display: none !important; }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(20, 20, 20, 0.5);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
    </style>
</head>
<body>

    <div class="info-container">
        <details id="info3D" open>
            <summary>About the 3D Transformation</summary>
            <div class="content-box">
                <p>For Re(s) > 1, the zeta function is defined by the infinite sum:</p>
                <p>$$\zeta(s) = \sum_{n=1}^{\infty} \frac{1}{n^s}$$</p>
                <p>This visualization uses analytic continuation to extend this definition. The highlighted region is the **Critical Strip**.</p>
                <p>The red dots on the line Re(s) = 0.5 represent the **non-trivial zeros**. The blue dots on the negative real axis are the **trivial zeros**. When transformed, they all map to the origin.</p>
                
                <h4>Interactive Calculator</h4>
                <div class="calculator-container">
                    <span>ζ(</span>
                    <input type="number" id="zetaRealInput" value="-1" step="0.1">
                    <span> + </span>
                    <input type="number" id="zetaImagInput" value="0" step="0.1">
                    <span>i )</span>
                    <button id="calculateZetaBtn">Calculate</button>
                </div>
                <div id="zetaResult"></div>
            </div>
        </details>
        <details id="infoZeros" class="hidden">
            <summary>About the Zeros Plot</summary>
            <div class="content-box">
                <p>This graph plots the real (blue) and imaginary (orange) parts of ζ(s) along the **Critical Line**, where the real part of s is fixed at 0.5.</p>
                <p>A "zero" occurs where both lines cross the horizontal axis at the same time (marked with red dots).</p>
            </div>
        </details>
    </div>

    <div id="plotContainer">
        <canvas id="plotCanvas"></canvas>
        <div id="plotControls">
            <button id="prevBtn">&lt;&lt; Prev</button>
            <span>t = </span>
            <input type="number" id="tOffsetInput" value="0">
            <button id="goBtn">Go</button>
            <button id="nextBtn">Next &gt;&gt;</button>
        </div>
    </div>

    <div class="controls">
        <button id="transformViewBtn">3D Transformation</button>
        <button id="zerosViewBtn">Zeros on Critical Line</button>
    </div>

    <div id="view3d-controls">
        <div>
            <button id="transformBtn">Transform</button>
            <button id="continueBtn" class="hidden">Analytically Continue</button>
            <button id="resetBtn" class="hidden">Reset</button>
            <button id="settingsBtn">Settings</button>
        </div>
        <div id="settings-panel" class="settings-panel hidden">
            <h4>Grid Settings</h4>
            <div>
                <label for="gridSize">Size:</label>
                <input type="range" id="gridSize" min="10" max="500" value="30">
                <span id="gridSizeValue">30</span>
            </div>
            <div>
                <label for="gridDensity">Density:</label>
                <input type="range" id="gridDensity" min="20" max="600" value="80">
                <span id="gridDensityValue">80</span>
            </div>
             <div>
                <label for="animationSpeed">Duration (ms):</label>
                <input type="range" id="animationSpeed" min="200" max="20000" value="2000">
                <span id="animationSpeedValue">2000</span>
            </div>
            <div>
                <label for="stripWidth">Strip Width:</label>
                <input type="range" id="stripWidth" min="0" max="100" value="20" step="1">
                <span id="stripWidthValue">1.0</span>
            </div>
            <div>
                <label for="stripStart">Strip Start:</label>
                <input type="range" id="stripStart" min="-10" max="10" value="0" step="0.1">
                <span id="stripStartValue">0.0</span>
            </div>
            <div>
                <label for="zDisplacementToggle">3D Displacement:</label>
                <label class="switch">
                    <input type="checkbox" id="zDisplacementToggle">
                    <span class="slider"></span>
                </label>
            </div>
             <h4>Non-Trivial Zeros</h4>
             <div>
                <label for="showZerosToggle">Show Zeros:</label>
                <label class="switch">
                    <input type="checkbox" id="showZerosToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
             <div>
                <label for="zeroSizeSlider">Zero Size:</label>
                <input type="range" id="zeroSizeSlider" min="0.05" max="0.5" value="0.15" step="0.01">
                <span id="zeroSizeValue">0.15</span>
            </div>
            <h4>Trivial Zeros</h4>
             <div>
                <label for="showTrivialZerosToggle">Show Zeros:</label>
                <label class="switch">
                    <input type="checkbox" id="showTrivialZerosToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
             <div>
                <label for="trivialZeroSizeSlider">Zero Size:</label>
                <input type="range" id="trivialZeroSizeSlider" min="0.05" max="0.5" value="0.15" step="0.01">
                <span id="trivialZeroSizeValue">0.15</span>
            </div>
            <h4>Color Settings</h4>
             <div>
                <label for="stripOnlyColor">Strip Only:</label>
                <label class="switch">
                    <input type="checkbox" id="stripOnlyColor">
                    <span class="slider"></span>
                </label>
            </div>
            <div>
                <label for="baseColor">Base Color:</label>
                <input type="color" id="baseColor" value="#ffffff">
            </div>
            <div>
                <label for="stripColor">Strip Color:</label>
                <input type="color" id="stripColor" value="#ffd700">
            </div>
            <h4>Axis & Line Colors</h4>
            <div>
                <label for="boundaryColor">Boundary Color:</label>
                <input type="color" id="boundaryColor" value="#ffd700">
            </div>
             <div>
                <label for="realAxisColor">Real Axis:</label>
                <input type="color" id="realAxisColor" value="#ff4444">
            </div>
            <div>
                <label for="imagAxisColor">Imag Axis:</label>
                <input type="color" id="imagAxisColor" value="#4444ff">
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- MathJax for LaTeX -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>


    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let plane, customAxes, blackHole, originalPositions, transformedPositions, axesLabels = [];
        let nonTrivialZerosGroup, originalNonTrivialZeroPositions = [], nonTrivialZeroMeshes = [];
        let trivialZerosGroup, originalTrivialZeroPositions = [], trivialZeroMeshes = [];
        let currentAnimation;
        let isTransformed = false;
        let isContinued = false;

        const plotContainer = document.getElementById('plotContainer');
        const plotCanvas = document.getElementById('plotCanvas');
        const plotCtx = plotCanvas.getContext('2d');
        const view3dControls = document.getElementById('view3d-controls');
        const info3D = document.getElementById('info3D');
        const infoZeros = document.getElementById('infoZeros');
        let tOffset = 0;
        const tRange = 50;
        const knownZeros = [14.1347, 21.0220, 25.0108, 30.4248, 32.9350, 37.5861, 40.9187, 43.3270, 48.0051, 49.7738, 52.9703, 56.4462, 59.3470, 60.8317, 65.0858, 67.0798, 69.5464, 72.0671, 75.7046, 77.1448, 79.3373, 82.9103, 84.7354, 87.4252, 88.8091, 92.4918, 94.6513, 95.8706, 98.8311, 101.3178, 103.7255, 105.4466, 107.1686, 111.0295, 111.8746, 114.3202, 116.2266, 118.7907, 121.3701, 122.9472, 124.2568, 127.5166, 129.5787, 131.0876, 133.4977, 134.7565, 138.0583, 139.7211, 141.1237, 143.1118];

        // --- Complex Number and Zeta Function Math ---
        class Complex { constructor(re = 0, im = 0) { this.re = re; this.im = im; } add(c) { return new Complex(this.re + c.re, this.im + c.im); } sub(c) { return new Complex(this.re - c.re, this.im - c.im); } mul(c) { return new Complex(this.re * c.re - this.im * c.im, this.re * c.im + this.im * c.re); } div(c) { const d = c.re * c.re + c.im * c.im; if (d === 0) return new Complex(Infinity, Infinity); return new Complex((this.re * c.re + this.im * c.im) / d, (this.im * c.re - this.re * c.im) / d); } static fromPolar(r, theta) { return new Complex(r * Math.cos(theta), r * Math.sin(theta)); } magnitude() { return Math.sqrt(this.re * this.re + this.im * this.im); } phase() { return Math.atan2(this.im, this.re); } }
        const g = 7; const p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
        function gamma(z) { if (z.re < 0.5) { const pi = new Complex(Math.PI, 0); const one = new Complex(1, 0); const sinPiZ = sin(pi.mul(z)); if (sinPiZ.magnitude() < 1e-9) return new Complex(Infinity, Infinity); return pi.div(sin(pi.mul(z)).mul(gamma(one.sub(z)))); } else { z = z.sub(new Complex(1, 0)); let x = new Complex(p[0], 0); for (let i = 1; i < g + 2; i++) { x = x.add(new Complex(p[i], 0).div(z.add(new Complex(i, 0)))); } const t = z.add(new Complex(g + 0.5, 0)); const sqrt2pi = new Complex(Math.sqrt(2 * Math.PI), 0); let term1 = pow(t, z.add(new Complex(0.5, 0))); let term2 = exp(t.mul(new Complex(-1, 0))); return sqrt2pi.mul(term1).mul(term2).mul(x); } }
        function zeta(s) { if (Math.abs(s.re - 1) < 1e-9 && Math.abs(s.im) < 1e-9) return new Complex(Infinity, Infinity); if (s.re < 0) { const one = new Complex(1, 0); const two = new Complex(2, 0); const pi = new Complex(Math.PI, 0); const reflected_s = one.sub(s); const term1 = pow(two, s); const term2 = pow(pi, s.sub(one)); const term3 = sin(pi.mul(s).div(two)); const term4 = gamma(one.sub(s)); const term5 = zeta(reflected_s); return term1.mul(term2).mul(term3).mul(term4).mul(term5); } const one = new Complex(1, 0); const two = new Complex(2, 0); const prefactor = one.div(one.sub(pow(two, one.sub(s)))); let eta_sum = new Complex(0, 0); for (let i = 1; i <= 1000; i++) { const term = pow(new Complex(i, 0), s.mul(new Complex(-1,0))); if (i % 2 === 1) { eta_sum = eta_sum.add(term); } else { eta_sum = eta_sum.sub(term); } } return prefactor.mul(eta_sum); }
        function pow(base, exp) { if (base.magnitude() === 0) return new Complex(0,0); const logBase = new Complex(Math.log(base.magnitude()), base.phase()); const z = logBase.mul(exp); return Complex.fromPolar(Math.exp(z.re), z.im); }
        function exp(c) { return Complex.fromPolar(Math.exp(c.re), c.im); }
        function sin(c) { const ez = exp(new Complex(-c.im, c.re)); const e_iz = exp(new Complex(c.im, -c.re)); return ez.sub(e_iz).div(new Complex(0, 2)); }

        // --- Slider Log Scale Helpers ---
        const MIN_STRIP_WIDTH = 0.1;
        const MAX_STRIP_WIDTH = 10000.0;
        function linearToLog(value, min, max, sliderMax) {
            if (value <= 0) return min;
            if (value >= sliderMax) return max;
            return min * Math.pow(max / min, value / sliderMax);
        }
        function logToLinear(value, min, max, sliderMax) {
            if (value <= min) return 0;
            if (value >= max) return sliderMax;
            return sliderMax * Math.log(value / min) / Math.log(max / min);
        }

        // --- THREE.js Scene Setup ---
        function makeTextSprite(message, options = {}) {
            const { fontsize = 32, scale = [1.8, 0.9, 1.0] } = options;
            const canvas = document.createElement('canvas'); const context = canvas.getContext('2d');
            canvas.width = 128; canvas.height = 64;
            context.font = `Bold ${fontsize}px Arial`; context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.textAlign = 'center'; context.textBaseline = 'middle';
            context.fillText(message, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.CanvasTexture(canvas); const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial); sprite.scale.set(...scale);
            sprite.position.copy(options.position || new THREE.Vector3()); return sprite;
        }

        function createPlane(width, height, segmentsW, segmentsH, stripWidth, stripStart) {
            const geometry = new THREE.PlaneGeometry(width, height, segmentsW, segmentsH);
            const boundaries = new Float32Array(geometry.attributes.position.count);
            const positions = geometry.attributes.position.array;
            const epsilon = (width / segmentsW) * 0.5;
            for (let i = 0; i < positions.length / 3; i++) {
                const x = positions[i * 3];
                if (Math.abs(x - stripStart) < epsilon || Math.abs(x - (stripStart + stripWidth)) < epsilon) { boundaries[i] = 1.0; } 
                else { boundaries[i] = 0.0; }
            }
            geometry.setAttribute('isBoundary', new THREE.BufferAttribute(boundaries, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    stripOnly: { value: 0.0 }, baseColor: { value: new THREE.Color(0xffffff) },
                    stripColor: { value: new THREE.Color(0xffd700) }, boundaryColor: { value: new THREE.Color(0xff00ff) },
                    stripWidth: { value: 1.0 },
                    stripStart: { value: 0.0 }
                },
                vertexShader: `
                    attribute float isBoundary; varying vec3 vColor; varying float vIsBoundary;
                    uniform float stripOnly; uniform vec3 baseColor; uniform vec3 stripColor;
                    uniform float stripWidth;
                    uniform float stripStart;
                    vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }
                    void main() {
                        vIsBoundary = isBoundary;
                        float isStrip = step(stripStart, position.x) * (1.0 - step(stripStart + stripWidth, position.x));
                        if (stripOnly > 0.5) { vColor = mix(baseColor, stripColor, isStrip); } 
                        else { float angle = atan(position.y, position.x); float hue = (angle + 3.14159) / (2.0 * 3.14159); float saturation = 0.7 + 0.3 * isStrip; float value = 0.9 + 0.1 * isStrip; vColor = hsv2rgb(vec3(hue, saturation, value)); }
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }`,
                fragmentShader: `
                    varying vec3 vColor; varying float vIsBoundary; uniform vec3 boundaryColor;
                    void main() { 
                        if (vIsBoundary > 0.5) { gl_FragColor = vec4(boundaryColor, 1.0); } 
                        else { gl_FragColor = vec4(vColor, 1.0); }
                    }`,
                side: THREE.DoubleSide, wireframe: true
            });
            const newPlane = new THREE.Mesh(geometry, material); newPlane.rotation.x = -Math.PI / 2; return newPlane;
        }

        function calculateTransformedPositions(positions, isContinuation, useZDisplacement) {
            const newPositions = new Float32Array(positions.length);
            const transformBoundary = 0.5;
            for (let i = 0; i < positions.length; i += 3) {
                const re = positions[i];
                const im = positions[i + 1];

                if (isContinuation || re > transformBoundary) {
                    let s = new Complex(re, im);
                    let z_s = zeta(s); let u = z_s.re; let v = z_s.im;
                    const clampValue = 40;
                    if (isFinite(u) && isFinite(v)) { 
                        newPositions[i] = Math.max(-clampValue, Math.min(clampValue, u)); 
                        newPositions[i+1] = Math.max(-clampValue, Math.min(clampValue, v)); 
                    } else { 
                        newPositions[i] = clampValue * Math.sign(u || 0); 
                        newPositions[i+1] = clampValue * Math.sign(v || 0); 
                    }
                    if (useZDisplacement) {
                        const dx = newPositions[i] - re;
                        const dy = newPositions[i + 1] - im;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        newPositions[i + 2] = distance * 0.2;
                    } else {
                         newPositions[i + 2] = 0;
                    }

                } else {
                    newPositions[i] = re;
                    newPositions[i+1] = im;
                    newPositions[i+2] = positions[i+2];
                }
            }
            return newPositions;
        }

        function animateTransformation(startPos, endPos, duration) {
            if (currentAnimation) cancelAnimationFrame(currentAnimation);
            const startTime = performance.now();
            const positions = plane.geometry.attributes.position.array;
            function animate() {
                const elapsed = performance.now() - startTime; let progress = Math.min(elapsed / duration, 1.0);
                progress = progress * progress * (3 - 2 * progress);
                for (let i = 0; i < positions.length; i++) { positions[i] = startPos[i] + (endPos[i] - startPos[i]) * progress; }
                plane.geometry.attributes.position.needsUpdate = true;
                if (progress < 1) { currentAnimation = requestAnimationFrame(animate); }
            }
            currentAnimation = requestAnimationFrame(animate);
        }

        function regenerateGrid() {
            const size = parseInt(document.getElementById('gridSize').value);
            const density = parseInt(document.getElementById('gridDensity').value);
            const stripWidth = parseFloat(document.getElementById('stripWidthValue').textContent);
            const stripStart = parseFloat(document.getElementById('stripStart').value);
            const useZDisplacement = document.getElementById('zDisplacementToggle').checked;
            
            if (plane) { scene.remove(plane); plane.geometry.dispose(); plane.material.dispose(); }
            
            plane = createPlane(size, size, density, density, stripWidth, stripStart);
            
            updateColors();
            scene.add(plane);
            originalPositions = new Float32Array(plane.geometry.attributes.position.array);
            
            let targetState;
            if (isContinued) {
                targetState = calculateTransformedPositions(originalPositions, true, useZDisplacement);
            } else if (isTransformed) {
                targetState = calculateTransformedPositions(originalPositions, false, useZDisplacement);
            } else {
                targetState = originalPositions;
            }
             plane.geometry.attributes.position.copyArray(targetState);
             plane.geometry.attributes.position.needsUpdate = true;
            
            regenerateAxesAndLabels();
            regenerateAllZeros();
        }

        function regenerateAxesAndLabels() {
            const size = parseInt(document.getElementById('gridSize').value);
            if (customAxes) scene.remove(customAxes);
            customAxes = createCustomAxes(size, size);
            scene.add(customAxes); updateColors();
            
            axesLabels.forEach(label => scene.remove(label)); axesLabels = [];
            axesLabels.push(makeTextSprite("Re", { position: new THREE.Vector3(size/2 + 3, 0, 0) }));
            axesLabels.push(makeTextSprite("Im", { position: new THREE.Vector3(0, 0, size/2 + 3) }));

            const labelLimit = Math.min(40, Math.floor(size / 2));
            for (let i = -labelLimit; i <= labelLimit; i++) {
                const commonOptions = { fontsize: 28, scale: [1.5, 0.75, 1.0] };
                if (i !== 0) {
                    axesLabels.push(makeTextSprite(`${i}i`, { ...commonOptions, position: new THREE.Vector3(0, 0, i) }));
                    axesLabels.push(makeTextSprite(`${i}`, { ...commonOptions, position: new THREE.Vector3(i, 0, 0) }));
                } else {
                    axesLabels.push(makeTextSprite("0", { ...commonOptions, position: new THREE.Vector3(-0.5, 0, -0.5) }));
                }
            }
            axesLabels.forEach(label => scene.add(label));
        }
        
        function createCustomAxes(width, height) {
            const group = new THREE.Group();
            const halfWidth = width / 2;
            const halfHeight = height / 2;
            const tickSize = 0.2;
            const labelLimit = Math.min(40, Math.floor(width / 2));

            const realMaterial = new THREE.LineBasicMaterial();
            const imagMaterial = new THREE.LineBasicMaterial();

            const realPoints = [new THREE.Vector3(-halfWidth, 0, 0), new THREE.Vector3(halfWidth, 0, 0)];
            const realGeometry = new THREE.BufferGeometry().setFromPoints(realPoints);
            const realAxis = new THREE.Line(realGeometry, realMaterial);
            realAxis.name = 'realAxis';
            group.add(realAxis);

            const imagPoints = [new THREE.Vector3(0, 0, -halfHeight), new THREE.Vector3(0, 0, halfHeight)];
            const imagGeometry = new THREE.BufferGeometry().setFromPoints(imagPoints);
            const imagAxis = new THREE.Line(imagGeometry, imagMaterial);
            imagAxis.name = 'imagAxis';
            group.add(imagAxis);
            
            for (let i = -labelLimit; i <= labelLimit; i++) {
                if (i === 0) continue;
                const realTickPoints = [new THREE.Vector3(i, 0, -tickSize), new THREE.Vector3(i, 0, tickSize)];
                const realTickGeom = new THREE.BufferGeometry().setFromPoints(realTickPoints);
                group.add(new THREE.Line(realTickGeom, realMaterial));

                const imagTickPoints = [new THREE.Vector3(-tickSize, 0, i), new THREE.Vector3(tickSize, 0, i)];
                const imagTickGeom = new THREE.BufferGeometry().setFromPoints(imagTickPoints);
                group.add(new THREE.Line(imagTickGeom, imagMaterial));
            }
            
            const halfTickSize = tickSize / 2;
            for (let i = -labelLimit + 0.5; i < labelLimit; i++) {
                const realTickPoints = [new THREE.Vector3(i, 0, -halfTickSize), new THREE.Vector3(i, 0, halfTickSize)];
                const realTickGeom = new THREE.BufferGeometry().setFromPoints(realTickPoints);
                group.add(new THREE.Line(realTickGeom, realMaterial));

                const imagTickPoints = [new THREE.Vector3(-halfTickSize, 0, i), new THREE.Vector3(halfTickSize, 0, i)];
                const imagTickGeom = new THREE.BufferGeometry().setFromPoints(imagTickPoints);
                group.add(new THREE.Line(imagTickGeom, imagMaterial));
            }

            return group;
        }

        function regenerateAllZeros() {
            regenerateNonTrivialZeros();
            regenerateTrivialZeros();
        }

        function regenerateNonTrivialZeros() {
            if (nonTrivialZerosGroup) {
                scene.remove(nonTrivialZerosGroup);
                nonTrivialZeroMeshes.forEach(mesh => {
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                });
            }
            
            if (!document.getElementById('showZerosToggle').checked) return;

            nonTrivialZerosGroup = new THREE.Group();
            nonTrivialZeroMeshes = [];
            originalNonTrivialZeroPositions = [];
            
            const zeroSize = parseFloat(document.getElementById('zeroSizeSlider').value);
            const zeroMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const zeroGeometry = new THREE.SphereGeometry(zeroSize, 16, 16);
            const size = parseInt(document.getElementById('gridSize').value);
            const halfSize = size / 2;

            const allZeroTs = [];
            knownZeros.forEach(t => {
                if (t < halfSize) allZeroTs.push(t);
                if (-t > -halfSize) allZeroTs.push(-t);
            });

            allZeroTs.forEach(t => {
                const mesh = new THREE.Mesh(zeroGeometry.clone(), zeroMaterial.clone());
                const startPos = new THREE.Vector3(0.5, 0, t);
                mesh.position.copy(startPos);
                
                nonTrivialZerosGroup.add(mesh);
                nonTrivialZeroMeshes.push(mesh);
                originalNonTrivialZeroPositions.push(startPos);
            });
            scene.add(nonTrivialZerosGroup);

            if (isTransformed || isContinued) {
                const useZ = document.getElementById('zDisplacementToggle').checked;
                const targetPositions = calculateZeroTargetPositions(originalNonTrivialZeroPositions, useZ);
                nonTrivialZeroMeshes.forEach((mesh, i) => mesh.position.copy(targetPositions[i]));
            }
        }

        function regenerateTrivialZeros() {
            if (trivialZerosGroup) {
                scene.remove(trivialZerosGroup);
                trivialZeroMeshes.forEach(mesh => {
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                });
            }
            
            if (!document.getElementById('showTrivialZerosToggle').checked) return;

            trivialZerosGroup = new THREE.Group();
            trivialZeroMeshes = [];
            originalTrivialZeroPositions = [];
            
            const zeroSize = parseFloat(document.getElementById('trivialZeroSizeSlider').value);
            const zeroMaterial = new THREE.MeshBasicMaterial({ color: 0x4444ff });
            const zeroGeometry = new THREE.SphereGeometry(zeroSize, 16, 16);
            const size = parseInt(document.getElementById('gridSize').value);
            const halfSize = size / 2;

            for (let i = -2; i >= -halfSize; i -= 2) {
                 const mesh = new THREE.Mesh(zeroGeometry.clone(), zeroMaterial.clone());
                 const startPos = new THREE.Vector3(i, 0, 0);
                 mesh.position.copy(startPos);
                 trivialZerosGroup.add(mesh);
                 trivialZeroMeshes.push(mesh);
                 originalTrivialZeroPositions.push(startPos);
            }
            scene.add(trivialZerosGroup);

            if (isTransformed || isContinued) {
                const useZ = document.getElementById('zDisplacementToggle').checked;
                const targetPositions = calculateZeroTargetPositions(originalTrivialZeroPositions, useZ);
                trivialZeroMeshes.forEach((mesh, i) => mesh.position.copy(targetPositions[i]));
            }
        }

        function calculateZeroTargetPositions(originalPositions, useZDisplacement) {
            return originalPositions.map(startPos => {
                if (useZDisplacement) {
                    const re = startPos.x;
                    const im = startPos.z;
                    const distance = Math.sqrt(Math.pow(0 - re, 2) + Math.pow(0 - im, 2));
                    return new THREE.Vector3(0, distance * 0.2, 0); 
                } else {
                    return new THREE.Vector3(0, 0, 0);
                }
            });
        }

        function animateAllZeros(targets, duration) {
            const startTime = performance.now();
            const startNonTrivial = nonTrivialZeroMeshes.map(mesh => mesh.position.clone());
            const startTrivial = trivialZeroMeshes.map(mesh => mesh.position.clone());

            function animate() {
                const elapsed = performance.now() - startTime;
                let progress = Math.min(elapsed / duration, 1.0);
                progress = progress * progress * (3 - 2 * progress);

                if(targets.nonTrivial) nonTrivialZeroMeshes.forEach((mesh, i) => mesh.position.lerpVectors(startNonTrivial[i], targets.nonTrivial[i], progress));
                if(targets.trivial) trivialZeroMeshes.forEach((mesh, i) => mesh.position.lerpVectors(startTrivial[i], targets.trivial[i], progress));

                if (progress < 1) requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
        }

        function updateColors() {
            if (!plane || !customAxes) return;
            const stripOnly = document.getElementById('stripOnlyColor').checked;
            plane.material.uniforms.stripOnly.value = stripOnly ? 1.0 : 0.0;
            plane.material.uniforms.baseColor.value.set(document.getElementById('baseColor').value);
            plane.material.uniforms.stripColor.value.set(document.getElementById('stripColor').value);
            plane.material.uniforms.boundaryColor.value.set(document.getElementById('boundaryColor').value);
            plane.material.uniforms.stripWidth.value = parseFloat(document.getElementById('stripWidthValue').textContent);
            plane.material.uniforms.stripStart.value = parseFloat(document.getElementById('stripStart').value);
            
            const realAxisMaterial = customAxes.getObjectByName('realAxis').material;
            const imagAxisMaterial = customAxes.getObjectByName('imagAxis').material;
            realAxisMaterial.color.set(document.getElementById('realAxisColor').value);
            imagAxisMaterial.color.set(document.getElementById('imagAxisColor').value);
        }

        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.insertBefore(renderer.domElement, document.body.firstChild);
            
            const bhGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const bhMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            blackHole = new THREE.Mesh(bhGeometry, bhMaterial);
            scene.add(blackHole);

            controls = new OrbitControls(camera, renderer.domElement);
            camera.position.set(0, 25, 35);
            regenerateGrid(); 
            calculateAndDisplayZeta();
            animate3D();
        }
        
        function animate3D() { requestAnimationFrame(animate3D); controls.update(); renderer.render(scene, camera); }
        
        function drawZerosPlot(t_offset = 0) { plotContainer.style.display = 'flex'; if (renderer) renderer.domElement.style.display = 'none'; const width = Math.min(window.innerWidth * 0.95, 1000); const height = Math.min(window.innerHeight * 0.8, 600); plotCanvas.width = width; plotCanvas.height = height; const tMin = t_offset, tMax = t_offset + tRange; const yMin = -4, yMax = 4; const padding = 60; const plotWidth = width - 2 * padding; const plotHeight = height - 2 * padding; function toScreenX(t) { return padding + (t - tMin) / (tMax - tMin) * plotWidth; } function toScreenY(y) { return height - padding - (y - yMin) / (yMax - yMin) * plotHeight; } plotCtx.fillStyle = '#1a1a1a'; plotCtx.fillRect(0, 0, width, height); plotCtx.strokeStyle = '#888'; plotCtx.lineWidth = 1; plotCtx.beginPath(); plotCtx.moveTo(padding, toScreenY(0)); plotCtx.lineTo(width - padding, toScreenY(0)); plotCtx.moveTo(toScreenX(tMin), padding); plotCtx.lineTo(toScreenX(tMin), height - padding); plotCtx.stroke(); plotCtx.fillStyle = '#ccc'; plotCtx.font = '12px Arial'; plotCtx.textAlign = 'center'; plotCtx.textBaseline = 'top'; for (let t = Math.ceil(tMin / 5) * 5; t <= tMax; t += 5) { plotCtx.fillText(t, toScreenX(t), toScreenY(0) + 5); } plotCtx.fillText("t (imaginary component of s = 0.5 + it)", width/2, height - 25); plotCtx.textAlign = 'right'; plotCtx.textBaseline = 'middle'; for (let y = yMin; y <= yMax; y += 1) { if(y!==0) plotCtx.fillText(y, padding - 10, toScreenY(y)); } plotCtx.lineWidth = 2; ['#4a90e2', '#f5a623'].forEach((color, index) => { plotCtx.strokeStyle = color; plotCtx.beginPath(); let first = true; for (let t = tMin; t < tMax; t += 0.1) { const s = new Complex(0.5, t); const z = zeta(s); const val = (index === 0) ? z.re : z.im; if (isFinite(val)) { if (first) { plotCtx.moveTo(toScreenX(t), toScreenY(val)); first = false; } else { plotCtx.lineTo(toScreenX(t), toScreenY(val)); } } } plotCtx.stroke(); }); plotCtx.fillStyle = 'red'; plotCtx.font = 'bold 12px Arial'; knownZeros.filter(t => t >= tMin && t <= tMax).forEach(t => { const x = toScreenX(t); plotCtx.beginPath(); plotCtx.arc(x, toScreenY(0), 5, 0, 2 * Math.PI); plotCtx.fill(); plotCtx.fillText(t.toFixed(2), x, toScreenY(0) - 15); }); plotCtx.fillStyle = '#4a90e2'; plotCtx.fillRect(width - padding - 100, padding, 10, 10); plotCtx.fillStyle = '#ccc'; plotCtx.textAlign = 'left'; plotCtx.fillText('Re(ζ(0.5 + it))', width - padding - 85, padding + 5); plotCtx.fillStyle = '#f5a623'; plotCtx.fillRect(width - padding - 100, padding + 20, 10, 10); plotCtx.fillText('Im(ζ(0.5 + it))', width - padding - 85, padding + 25); }

        function setInitialSliderValues() {
            document.getElementById('gridSizeValue').textContent = document.getElementById('gridSize').value;
            document.getElementById('gridDensityValue').textContent = document.getElementById('gridDensity').value;
            document.getElementById('animationSpeedValue').textContent = document.getElementById('animationSpeed').value;
            document.getElementById('stripStartValue').textContent = parseFloat(document.getElementById('stripStart').value).toFixed(1);
            document.getElementById('zeroSizeValue').textContent = parseFloat(document.getElementById('zeroSizeSlider').value).toFixed(2);
            document.getElementById('trivialZeroSizeValue').textContent = parseFloat(document.getElementById('trivialZeroSizeSlider').value).toFixed(2);

            const stripWidthSlider = document.getElementById('stripWidth');
            const stripWidthValueSpan = document.getElementById('stripWidthValue');
            const initialStripWidth = 1.0;
            stripWidthSlider.value = logToLinear(initialStripWidth, MIN_STRIP_WIDTH, MAX_STRIP_WIDTH, 100);
            stripWidthValueSpan.textContent = parseFloat(initialStripWidth.toPrecision(4));
        }

        document.getElementById('transformViewBtn').addEventListener('click', () => {
            plotContainer.style.display = 'none';
            renderer.domElement.style.display = 'block';
            view3dControls.style.display = 'flex';
            info3D.classList.remove('hidden');
            infoZeros.classList.add('hidden');
        });
        document.getElementById('zerosViewBtn').addEventListener('click', () => {
            plotContainer.style.display = 'flex';
            renderer.domElement.style.display = 'none';
            view3dControls.style.display = 'none';
            info3D.classList.add('hidden');
            infoZeros.classList.remove('hidden');
            drawZerosPlot(tOffset);
        });
        
        const transformBtn = document.getElementById('transformBtn');
        const continueBtn = document.getElementById('continueBtn');
        const resetBtn = document.getElementById('resetBtn');

        transformBtn.addEventListener('click', () => {
            const speed = parseInt(document.getElementById('animationSpeed').value);
            const useZ = document.getElementById('zDisplacementToggle').checked;
            const targetPositions = calculateTransformedPositions(originalPositions, false, useZ);
            animateTransformation(originalPositions, targetPositions, speed);
            
            const nonTrivialTargets = calculateZeroTargetPositions(originalNonTrivialZeroPositions, useZ);
            const trivialTargets = calculateZeroTargetPositions(originalTrivialZeroPositions, useZ);
            animateAllZeros({ nonTrivial: nonTrivialTargets, trivial: trivialTargets }, speed);

            isTransformed = true;
            transformBtn.classList.add('hidden');
            continueBtn.classList.remove('hidden');
            resetBtn.classList.remove('hidden');
        });
        
        continueBtn.addEventListener('click', () => {
            const speed = parseInt(document.getElementById('animationSpeed').value);
            const useZ = document.getElementById('zDisplacementToggle').checked;
            const currentPositions = new Float32Array(plane.geometry.attributes.position.array);
            const continuedPositions = calculateTransformedPositions(originalPositions, true, useZ);
            animateTransformation(currentPositions, continuedPositions, speed);
            
            const nonTrivialTargets = calculateZeroTargetPositions(originalNonTrivialZeroPositions, useZ);
            const trivialTargets = calculateZeroTargetPositions(originalTrivialZeroPositions, useZ);
            animateAllZeros({ nonTrivial: nonTrivialTargets, trivial: trivialTargets }, speed);

            continueBtn.classList.add('hidden');
            isContinued = true;
        });

        resetBtn.addEventListener('click', () => {
            const speed = parseInt(document.getElementById('animationSpeed').value);
            const currentPositions = new Float32Array(plane.geometry.attributes.position.array);
            animateTransformation(currentPositions, originalPositions, speed);

            animateAllZeros({ nonTrivial: originalNonTrivialZeroPositions, trivial: originalTrivialZeroPositions }, speed);

            isTransformed = false;
            isContinued = false;
            transformBtn.classList.remove('hidden');
            continueBtn.classList.add('hidden');
            resetBtn.classList.add('hidden');
        });
        
        function calculateAndDisplayZeta() {
            const re = parseFloat(document.getElementById('zetaRealInput').value) || 0;
            const im = parseFloat(document.getElementById('zetaImagInput').value) || 0;
            const s = new Complex(re, im);
            const result = zeta(s);
            const resultDiv = document.getElementById('zetaResult');

            if (!isFinite(result.re) || !isFinite(result.im)) {
                resultDiv.textContent = "Result is infinite (pole at s=1)";
            } else {
                const realPart = result.re.toFixed(4);
                const imagPart = result.im.toFixed(4);
                resultDiv.textContent = `${realPart} ${imagPart >= 0 ? '+' : '-'} ${Math.abs(imagPart)}i`;
            }
        }

        document.getElementById('calculateZetaBtn').addEventListener('click', calculateAndDisplayZeta);
        document.getElementById('settingsBtn').addEventListener('click', () => document.getElementById('settings-panel').classList.toggle('hidden'));
        document.getElementById('gridSize').addEventListener('input', (e) => { document.getElementById('gridSizeValue').textContent = e.target.value; regenerateGrid(); });
        document.getElementById('gridDensity').addEventListener('input', (e) => { document.getElementById('gridDensityValue').textContent = e.target.value; regenerateGrid(); });
        document.getElementById('animationSpeed').addEventListener('input', (e) => { document.getElementById('animationSpeedValue').textContent = e.target.value; });
        
        document.getElementById('stripWidth').addEventListener('input', (e) => {
            const linearValue = parseFloat(e.target.value);
            const logValue = linearToLog(linearValue, MIN_STRIP_WIDTH, MAX_STRIP_WIDTH, 100);
            document.getElementById('stripWidthValue').textContent = parseFloat(logValue.toPrecision(4));
            regenerateGrid();
        });

        document.getElementById('stripStart').addEventListener('input', (e) => {
            document.getElementById('stripStartValue').textContent = parseFloat(e.target.value).toFixed(1);
            regenerateGrid();
        });
        
        document.getElementById('zDisplacementToggle').addEventListener('input', () => {
            if (!isTransformed && !isContinued) return;
            const currentGridPositions = new Float32Array(plane.geometry.attributes.position.array);
            const useZ = document.getElementById('zDisplacementToggle').checked;
            const speed = parseInt(document.getElementById('animationSpeed').value);
            
            let targetGridPositions;
            if (isContinued) {
                targetGridPositions = calculateTransformedPositions(originalPositions, true, useZ);
            } else { 
                targetGridPositions = calculateTransformedPositions(originalPositions, false, useZ);
            }
            animateTransformation(currentGridPositions, targetGridPositions, speed);
            
            const nonTrivialTargets = calculateZeroTargetPositions(originalNonTrivialZeroPositions, useZ);
            const trivialTargets = calculateZeroTargetPositions(originalTrivialZeroPositions, useZ);
            animateAllZeros({ nonTrivial: nonTrivialTargets, trivial: trivialTargets }, speed);
        });

        document.getElementById('showZerosToggle').addEventListener('input', regenerateAllZeros);
        document.getElementById('zeroSizeSlider').addEventListener('input', (e) => {
             document.getElementById('zeroSizeValue').textContent = parseFloat(e.target.value).toFixed(2);
             regenerateNonTrivialZeros();
        });
        
        document.getElementById('showTrivialZerosToggle').addEventListener('input', regenerateAllZeros);
        document.getElementById('trivialZeroSizeSlider').addEventListener('input', (e) => {
             document.getElementById('trivialZeroSizeValue').textContent = parseFloat(e.target.value).toFixed(2);
             regenerateTrivialZeros();
        });

        ['stripOnlyColor', 'baseColor', 'stripColor', 'boundaryColor', 'realAxisColor', 'imagAxisColor'].forEach(id => { document.getElementById(id).addEventListener('input', updateColors); });
        
        const tOffsetInput = document.getElementById('tOffsetInput');
        tOffsetInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') { document.getElementById('goBtn').click(); } });
        document.getElementById('nextBtn').addEventListener('click', () => { tOffset += tRange; tOffsetInput.value = tOffset; drawZerosPlot(tOffset); });
        document.getElementById('prevBtn').addEventListener('click', () => { tOffset = Math.max(0, tOffset - tRange); tOffsetInput.value = tOffset; drawZerosPlot(tOffset); });
        document.getElementById('goBtn').addEventListener('click', () => { const val = parseFloat(tOffsetInput.value); if (!isNaN(val)) { tOffset = Math.max(0, val); drawZerosPlot(tOffset); } });
        window.addEventListener('resize', () => { if(camera) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); } if(renderer) { renderer.setSize(window.innerWidth, window.innerHeight); } if (plotContainer.style.display !== 'none') { drawZerosPlot(tOffset); } });

        init3D();
        setInitialSliderValues();

    </script>
</body>
</html>

