<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Black Hole Physics Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap');
        :root { --graph-height: 250px; }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #F9FAFB;
            overflow: hidden;
            margin: 0;
        }
        #visualization-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        #side-menu {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: 320px;
            background-color: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(12px);
            border-right: 1px solid rgba(55, 65, 81, 0.5);
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            z-index: 20;
            display: flex;
            flex-direction: column;
        }
        #side-menu.open {
            transform: translateX(0);
        }
        #settings-gear {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 21;
            cursor: pointer;
            background-color: rgba(17, 24, 39, 0.7);
            padding: 0.5rem;
            border-radius: 9999px;
            transition: transform 0.3s;
        }
        #settings-gear:hover { transform: rotate(90deg); }
        .tab-button.active {
            background-color: #3B82F6;
            color: white;
        }
        #graph-panel {
            position: fixed;
            bottom: 40px; /* Adjust for new collapsed menu height */
            left: 0;
            right: 0;
            height: var(--graph-height);
            background-color: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(12px);
            border-top: 1px solid rgba(55, 65, 81, 0.5);
            transform: translateY(calc(100% + 40px));
            transition: transform 0.3s ease-in-out;
            z-index: 10;
            padding: 1rem;
        }
        #graph-panel.open {
            transform: translateY(0);
        }
        #bottom-menu {
            transition: max-height 0.3s ease-in-out;
            max-height: 40px; /* Collapsed height */
            overflow: hidden;
        }
        #bottom-menu.open {
            max-height: 120px; /* Expanded height */
        }
        #menu-toggle-icon {
            transition: transform 0.3s ease-in-out;
        }
        #bottom-menu.open #menu-toggle-icon {
            transform: rotate(180deg);
        }
    </style>
</head>
<body class="antialiased">

    <div id="visualization-container"></div>
    
    <h1 class="fixed top-4 left-1/2 -translate-x-1/2 text-2xl lg:text-3xl font-extrabold text-white pointer-events-none">Black Hole Physics Visualization</h1>

    <div id="settings-gear">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
    </div>

    <div id="side-menu">
        <div class="p-4 flex-grow overflow-y-auto">
            <h2 class="text-xl font-bold mb-4">Controls & Settings</h2>
            <div class="space-y-6">
                <div>
                    <h3 class="font-bold mb-2 text-yellow-400">Parameters</h3>
                    <div id="dynamic-controls" class="space-y-3"></div>
                </div>
                <div>
                    <h3 class="font-bold mb-2 text-yellow-400">Actions</h3>
                    <button id="btn-start-collapse" class="w-full p-2 rounded bg-orange-600 hover:bg-orange-700">Run Collapse Sim</button>
                </div>
                <div>
                    <h3 class="font-bold mb-2 text-yellow-400">Graphics</h3>
                    <div id="graphics-controls" class="space-y-3"></div>
                </div>
                <div>
                    <h3 class="font-bold mb-2 text-yellow-400">Metrics</h3>
                    <div id="metrics-panel-content" class="space-y-2 text-sm"></div>
                </div>
                <div>
                    <h3 class="font-bold mb-2 text-yellow-400">Information</h3>
                    <div id="info-panel-content" class="text-sm text-gray-400"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="graph-panel">
        <div id="plots-panel" class="w-full h-full">
            <h3 id="plot-title" class="text-lg font-bold text-center mb-2"></h3>
            <canvas id="main-chart" class="w-full"></canvas>
        </div>
    </div>

    <div id="bottom-menu" class="fixed bottom-0 left-0 right-0 bg-gray-900/80 backdrop-blur-lg border-t border-gray-700 z-10">
        <div id="menu-toggle" class="h-[40px] flex justify-center items-center cursor-pointer">
            <svg id="menu-toggle-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-400"><polyline points="18 15 12 9 6 15"></polyline></svg>
        </div>
        <div class="h-full max-w-2xl mx-auto flex justify-around items-center px-4 pb-4">
            <button id="btn-black-hole" class="tab-button flex-1 p-2 rounded-lg">Horizon</button>
            <button id="btn-internal-forces" class="tab-button flex-1 p-2 rounded-lg">Dynamics</button>
            <button id="btn-mandelbrot-analogy" class="tab-button flex-1 p-2 rounded-lg">Boundary</button>
            <button id="btn-lifecycle" class="tab-button flex-1 p-2 rounded-lg">Lifecycle</button>
            <button id="btn-toggle-graph" class="flex-1 p-2 rounded-lg bg-gray-700 hover:bg-gray-600">Show Graph</button>
        </div>
    </div>

    <!-- GLSL Shaders -->
    <script id="disk-vertex-shader" type="x-shader/x-vertex"> varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } </script>
    <script id="disk-fragment-shader" type="x-shader/x-fragment"> uniform float uTime; varying vec2 vUv; float noise(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); } void main() { float radius = length(vUv - 0.5) * 2.0; if (radius > 1.0) discard; float angle = atan(vUv.y - 0.5, vUv.x - 0.5); float time = uTime * 0.2; float n = noise(vec2(angle * 5.0, radius * 10.0 + time)); float intensity = pow(1.0 - radius, 2.0) * (1.0 + n * 0.1); vec3 color = mix(vec3(1.0, 0.6, 0.1), vec3(0.8, 0.1, 0.0), radius); gl_FragColor = vec4(color * intensity, intensity * 0.8); } </script>
    <script id="star-vertex-shader" type="x-shader/x-vertex"> varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } </script>
    <script id="star-fragment-shader" type="x-shader/x-fragment"> uniform float uTime; uniform float uIntensity; varying vec2 vUv; float noise(vec3 p) { return fract(sin(dot(p, vec3(12.9898, 78.233, 151.7182))) * 43758.5453); } void main() { vec3 pos = vec3(vUv * 2.0 - 1.0, 0.0); float dist = length(pos); if (dist > 1.0) discard; vec3 turbulentPos = vec3(pos.xy, uTime * 0.1); float n = noise(turbulentPos * 5.0) * 0.5 + noise(turbulentPos * 10.0) * 0.25; float baseColor = pow(1.0 - dist, 1.5); vec3 color = mix(vec3(1.0, 0.8, 0.2), vec3(1.0, 0.2, 0.0), dist + n * 0.1); gl_FragColor = vec4(color * baseColor * uIntensity, 1.0); } </script>

    <script type="importmap"> { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, currentViz;
        let vizObjects = [];
        
        let currentRadius = 3, currentOutwardPressure = 1, currentComplexity = 1, particleCount = 10000;
        const metricsHistory = { radius: [], bhEntropy: [], avgGravity: [], boundaryEntropy: [] };
        let isGraphVisible = false;

        let mainChart;
        let lifecycleStar, isLifecycleRunning = false, lifecycleProgress = 0, lifecycleDuration = 20;
        let collapseScene, collapseCamera, collapseRenderer, star, collapseDisk, isCollapsing = false;
        let internalParticles = []; // FIX: Declared in global scope

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 5, 25);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setClearColor(0x000000, 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('visualization-container').appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            initCharts();
            setupEventListeners();
            
            switchVisualization('black-hole');
            document.getElementById('btn-black-hole').classList.add('active');
            animate();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.getElementById('settings-gear').addEventListener('click', () => {
                document.getElementById('side-menu').classList.toggle('open');
            });
             document.getElementById('menu-toggle').addEventListener('click', () => {
                document.getElementById('bottom-menu').classList.toggle('open');
            });

            document.querySelectorAll('.tab-button').forEach(btn => {
                if(btn.id !== 'btn-toggle-graph') {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                }
            });
            
            document.getElementById('btn-black-hole').addEventListener('click', () => switchVisualization('black-hole'));
            document.getElementById('btn-internal-forces').addEventListener('click', () => switchVisualization('internal-forces'));
            document.getElementById('btn-mandelbrot-analogy').addEventListener('click', () => switchVisualization('mandelbrot-analogy'));
            document.getElementById('btn-lifecycle').addEventListener('click', () => switchVisualization('lifecycle'));

            document.getElementById('btn-toggle-graph').addEventListener('click', toggleGraph);
            document.getElementById('btn-start-collapse').addEventListener('click', () => { /* Logic restored below */ });
        }
        
        function toggleGraph() {
            isGraphVisible = !isGraphVisible;
            const panel = document.getElementById('graph-panel');
            panel.classList.toggle('open');
            const menuOpen = document.getElementById('bottom-menu').classList.contains('open');
            panel.style.bottom = menuOpen ? '120px' : '40px';
            const btn = document.getElementById('btn-toggle-graph');
            btn.textContent = isGraphVisible ? 'Hide Graph' : 'Show Graph';
            btn.classList.toggle('bg-red-600', isGraphVisible);
        }

        function switchVisualization(vizType) {
            clearScene();
            currentViz = vizType;
            isLifecycleRunning = vizType === 'lifecycle';
            setupDynamicControls(vizType);
            camera.position.set(10, 5, 25);
            controls.target.set(0, 0, 0);

            switch (vizType) {
                case 'black-hole': setupBlackHole(); break;
                case 'internal-forces': setupInternalForces(); break;
                case 'mandelbrot-analogy': setupMandelbrotAnalogy(); break;
                case 'lifecycle': setupStellarLifecycle(); break;
            }
            updateAll();
        }

        function createSlider(label, min, max, value, step, callback) {
            const el = document.createElement('div');
            el.className = 'flex items-center space-x-2 text-sm';
            el.innerHTML = `<label class="w-28 shrink-0">${label}</label><input type="range" min="${min}" max="${max}" value="${value}" step="${step}" class="w-full"><span class="font-mono w-10 text-right">${parseFloat(value).toFixed(1)}</span>`;
            const slider = el.querySelector('input');
            const span = el.querySelector('span');
            slider.addEventListener('input', (e) => {
                const newValue = parseFloat(e.target.value);
                span.textContent = newValue.toFixed(1);
                callback(newValue);
            });
            return el;
        }

        function setupDynamicControls(vizType) {
            const controlsContainer = document.getElementById('dynamic-controls');
            const graphicsContainer = document.getElementById('graphics-controls');
            controlsContainer.innerHTML = '';
            graphicsContainer.innerHTML = '';

            if (vizType !== 'lifecycle') {
                 controlsContainer.appendChild(createSlider('BH Radius', 2, 10, currentRadius, 0.1, val => {
                    currentRadius = val; updateAll();
                }));
            }
            if (vizType === 'internal-forces') {
                controlsContainer.appendChild(createSlider('Outward Pressure', 0.1, 5, currentOutwardPressure, 0.1, val => { currentOutwardPressure = val; updateAll(); }));
            }
            if (vizType === 'mandelbrot-analogy') {
                controlsContainer.appendChild(createSlider('Boundary Complexity', 0, 5, currentComplexity, 0.1, val => { currentComplexity = val; updateAll(); }));
            }
            if (['black-hole', 'mandelbrot-analogy'].includes(vizType)) {
                graphicsContainer.appendChild(createSlider('Particle Count', 1000, 20000, particleCount, 100, val => {
                    particleCount = val; switchVisualization(currentViz);
                }));
            }
        }

        function updateAll() {
            update3DObjects();
            updateMetricsPanel();
            updateMainPlot();
        }

        function update3DObjects() {
            if(currentViz === 'black-hole') updateBlackHole(currentRadius);
            if(currentViz === 'internal-forces') updateInternalForcesVisuals(currentOutwardPressure);
            if(currentViz === 'mandelbrot-analogy') updateMandelbrotAnalogy(currentComplexity);
        }

        function updateMetricsPanel() {
            const metricsContainer = document.getElementById('metrics-panel-content');
            const infoContainer = document.getElementById('info-panel-content');
            const area = 4 * Math.PI * currentRadius * currentRadius;
            const bhEntropy = area / 10;
            const boundaryEntropy = Math.sqrt(currentComplexity);
            let metricsHTML = '', infoHTML = '';
            const infoContent = {
                'black-hole': `<h4 class="font-bold text-blue-400">Bekenstein-Hawking Entropy</h4><p>A black hole's entropy is proportional to the area of its event horizon (S ‚àù A).</p>`,
                'internal-forces': `<h4 class="font-bold text-red-400">Internal Dynamics</h4><p>Conceptual opposing forces within an event horizon.</p>`,
                'mandelbrot-analogy': `<h4 class="font-bold text-purple-400">Boundary Analogy</h4><p>Boundary complexity is modeled as an inverse function of the black hole's radius.</p>`,
                'lifecycle': `<h4 class="font-bold text-green-400">Stellar Lifecycle</h4><p>The animated evolution of a massive star from main sequence to its final state as a black hole.</p>`
            };
            switch(currentViz) {
                case 'black-hole': metricsHTML = `<p class="flex justify-between"><span>Surface Area:</span> <span class="font-mono">${area.toFixed(2)}</span></p><p class="flex justify-between"><span>BH Entropy:</span> <span class="font-mono text-blue-400">${bhEntropy.toFixed(2)}</span></p>`; break;
                case 'internal-forces': metricsHTML = `<p class="flex justify-between"><span>Outward Pressure:</span> <span class="font-mono">${currentOutwardPressure.toFixed(2)}</span></p>`; break;
                case 'mandelbrot-analogy': metricsHTML = `<p class="flex justify-between"><span>Complexity:</span> <span class="font-mono">${currentComplexity.toFixed(2)}</span></p><p class="flex justify-between"><span>Boundary Entropy:</span> <span class="font-mono text-purple-400">${boundaryEntropy.toFixed(4)}</span></p>`; break;
                case 'lifecycle': metricsHTML = `<p class="text-center">See graph for detailed metrics.</p>`; break;
            }
            metricsContainer.innerHTML = metricsHTML;
            infoContainer.innerHTML = infoContent[currentViz] || '';
        }
        
        function updateMainPlot() {
            if (!mainChart) return;
            let metricKey, plotTitle, color, chartData;
            if (currentViz === 'lifecycle') { /* ... */ } else {
                switch(currentViz) {
                    case 'black-hole': metricKey = 'bhEntropy'; plotTitle = 'BH Entropy vs. Radius'; color = '#3B82F6'; break;
                    case 'internal-forces': metricKey = 'avgGravity'; plotTitle = 'Avg. Gravity vs. Radius'; color = '#EF4444'; break;
                    case 'mandelbrot-analogy': metricKey = 'boundaryEntropy'; plotTitle = 'Boundary Entropy vs. Radius'; color = '#A855F7'; break;
                }
                const validData = metricsHistory.radius.map((r, i) => ({x: r, y: metricsHistory[metricKey][i]})).filter(p => p.y !== null && !isNaN(p.y));
                chartData = {
                    labels: validData.map(p => p.x.toFixed(1)),
                    datasets: [{ label: plotTitle, data: validData.map(p => p.y), borderColor: color, tension: 0.1 }]
                }
            }
            document.getElementById('plot-title').textContent = plotTitle;
            mainChart.data = chartData;
            mainChart.update();
        }

        let blackHole, accretionDisk, stars, hawkingParticles;
        function setupBlackHole() {
            controls.autoRotate = true; controls.autoRotateSpeed = 0.2;
            const diskMaterial = new THREE.ShaderMaterial({uniforms: { uTime: { value: 0 }},vertexShader: document.getElementById('disk-vertex-shader').textContent,fragmentShader: document.getElementById('disk-fragment-shader').textContent,transparent: true, side: THREE.DoubleSide});
            blackHole = new THREE.Mesh(new THREE.SphereGeometry(1, 64, 64), new THREE.MeshBasicMaterial({color: 0x000000}));
            accretionDisk = new THREE.Mesh(new THREE.RingGeometry(1.2, 3.5, 64), diskMaterial);
            accretionDisk.rotation.x = Math.PI * 0.5;
            stars = new THREE.Points(new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(Array.from({length: particleCount * 3}, () => THREE.MathUtils.randFloatSpread(400)), 3)), new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 }));
            const RAD_PARTICLE_COUNT = Math.floor(particleCount / 50);
            hawkingParticles = new THREE.Points(new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(RAD_PARTICLE_COUNT * 3), 3)), new THREE.PointsMaterial({ color: 0xaaccff, size: 0.05, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending }));
            hawkingParticles.userData.velocities = Array.from({length: RAD_PARTICLE_COUNT}, () => new THREE.Vector3().randomDirection().multiplyScalar(0.02));
            vizObjects.push(blackHole, accretionDisk, stars, hawkingParticles);
            scene.add(blackHole, accretionDisk, stars, hawkingParticles);
        }
        function updateBlackHole(radius) {
            if (!blackHole) return;
            blackHole.scale.setScalar(radius);
            accretionDisk.scale.setScalar(radius);
        }
        function animateHawkingRadiation() {
            if (!hawkingParticles || currentViz !== 'black-hole') return;
            const positions = hawkingParticles.geometry.attributes.position.array;
            const velocities = hawkingParticles.userData.velocities;
            const maxDist = currentRadius + 2;
            for (let i = 0; i < velocities.length; i++) {
                const i3 = i * 3;
                let p = new THREE.Vector3().fromArray(positions, i3);
                if (p.lengthSq() === 0 || p.length() > maxDist) {
                    p.setFromSphericalCoords(currentRadius, Math.acos(2 * Math.random() - 1), 2 * Math.PI * Math.random());
                } else {
                    p.add(velocities[i]);
                }
                p.toArray(positions, i3);
            }
            hawkingParticles.geometry.attributes.position.needsUpdate = true;
        }

        function setupInternalForces() {
            controls.autoRotate = false; camera.position.set(0, 0, 20);
            const boundarySphere = new THREE.Mesh(new THREE.SphereGeometry(15, 32, 32), new THREE.MeshBasicMaterial({ color: 0x374151, wireframe: true, transparent: true, opacity: 0.1, side: THREE.BackSide }));
            vizObjects.push(boundarySphere); scene.add(boundarySphere);
            for (let i = 0; i < 150; i++) {
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                mesh.position.setFromSphericalCoords(Math.random()*14+1, Math.acos(2*Math.random()-1), 2*Math.random()*Math.PI);
                const arrows = { g: new THREE.ArrowHelper(new THREE.Vector3(0,0,-1), mesh.position, 1, 0xff3333), p: new THREE.ArrowHelper(new THREE.Vector3(0,0,1), mesh.position, 1, 0x3333ff) };
                scene.add(mesh, arrows.g, arrows.p);
                vizObjects.push(mesh, arrows.g, arrows.p);
                internalParticles.push({ mesh, v: new THREE.Vector3().randomDirection().multiplyScalar(0.03), arrows });
            }
        }
        function updateInternalForcesVisuals(pressure) {
            internalParticles.forEach(p => p.arrows.p.setLength(pressure));
        }
        function animateInternalForces() {
            if(currentViz !== 'internal-forces') return;
            const origin = new THREE.Vector3(0, 0, 0);
            internalParticles.forEach(p => {
                p.mesh.position.add(p.v);
                if (p.mesh.position.length() > 15) p.v.reflect(p.mesh.position.clone().normalize());
                const gForce = Math.min(20 / (p.mesh.position.lengthSq() + 0.1), 5);
                p.arrows.g.position.copy(p.mesh.position);
                p.arrows.g.setDirection(origin.clone().sub(p.mesh.position).normalize());
                p.arrows.g.setLength(gForce);
                p.arrows.p.position.copy(p.mesh.position);
                p.arrows.p.setDirection(p.mesh.position.clone().normalize());
            });
        }
        
        function setupMandelbrotAnalogy() {
            controls.autoRotate = true; controls.autoRotateSpeed = 0.4;
            unitBall = new THREE.Mesh(new THREE.SphereGeometry(8, 64, 64), new THREE.MeshStandardMaterial({ color: 0x9333ea, metalness: 0.3, roughness: 0.4, }));
            fractalBoundary = new THREE.Points(new THREE.BufferGeometry(), new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.7 }));
            vizObjects.push(unitBall, fractalBoundary);
            scene.add(unitBall, fractalBoundary);
        }
        function updateMandelbrotAnalogy(complexity) {
            if (!fractalBoundary) return;
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const r = (8 + 0.5) + (Math.random() - 0.5) * 2 * complexity;
                new THREE.Vector3().setFromSphericalCoords(r, Math.acos(2 * Math.random() - 1), 2 * Math.PI * Math.random()).toArray(positions, i*3);
            }
            fractalBoundary.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        }
        
        function setupStellarLifecycle() {
            clearScene();
            lifecycleStar = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), new THREE.MeshBasicMaterial({ color: 0xFFFF00 }));
            scene.add(lifecycleStar);
            vizObjects.push(lifecycleStar);
            camera.position.z = 40;
        }
        function animateStellarLifecycle(deltaTime) {
            if (!isLifecycleRunning) return;
            lifecycleProgress = (lifecycleProgress + deltaTime / lifecycleDuration) % 1;
        }

        function initCharts() {
             mainChart = new Chart(document.getElementById('main-chart').getContext('2d'), {
                type: 'line',
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { ticks: { color: '#9CA3AF' }, grid: { color: 'rgba(255,255,255,0.1)' } }, y: { ticks: { color: '#9CA3AF' }, grid: { color: 'rgba(255,255,255,0.1)' } } }
                }
            });
        }
        
        function clearScene() {
            vizObjects.forEach(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                     if(Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                     else if (obj.material.dispose) obj.material.dispose();
                }
                scene.remove(obj);
            });
            vizObjects = [];
            internalParticles = [];
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = clock.getDelta();
            
            animateHawkingRadiation();
            animateInternalForces();
            animateStellarLifecycle(deltaTime);
            
            if(accretionDisk) accretionDisk.material.uniforms.uTime.value = elapsedTime;
            
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>

