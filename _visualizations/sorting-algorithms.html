<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Sorting Algorithm Race</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js",
                "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #settings-panel {
            transition: transform 0.3s ease-in-out;
        }
        .algo-checkbox:checked + label {
            background-color: #4f46e5;
            border-color: #6366f1;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div id="container"></div>

    <header class="absolute top-0 left-0 right-0 bg-gray-900/50 backdrop-blur-sm z-20">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <h1 class="text-xl md:text-2xl font-bold text-white tracking-tight">3D Sorting Algorithm Race</h1>
            <div class="flex items-center gap-2">
                 <button id="race-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 disabled:bg-gray-500 disabled:cursor-not-allowed text-sm sm:text-base">
                    Start Race
                </button>
                <button id="settings-button" class="p-2 rounded-md hover:bg-gray-700 transition-colors">
                     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line></svg>
                </button>
            </div>
        </div>
    </header>

    <div id="settings-panel" class="fixed top-0 right-0 h-full bg-gray-800 border-l border-gray-700 shadow-lg z-30 w-80 max-w-full transform translate-x-full p-6 overflow-y-auto">
        <div class="flex justify-between items-center mb-6 sticky top-0 bg-gray-800 py-2">
            <h2 class="text-2xl font-semibold text-indigo-400">Settings</h2>
            <button id="close-settings-button" class="p-2 rounded-full hover:bg-gray-700 text-2xl leading-none">&times;</button>
        </div>
        <div class="space-y-6">
            <div class="bg-gray-900/50 p-4 rounded-lg">
                <h3 class="text-xl font-semibold mb-4 text-gray-300">Controls</h3>
                <div class="space-y-5">
                    <div>
                        <label for="size-slider" class="text-sm font-medium flex justify-between">Array Size <span id="size-value" class="font-semibold text-indigo-300">50</span></label>
                        <input id="size-slider" type="range" min="10" max="150" value="50" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label for="speed-slider" class="text-sm font-medium flex justify-between">Animation Delay <span id="speed-value" class="font-semibold text-indigo-300">10ms</span></label>
                        <input id="speed-slider" type="range" min="0" max="100" value="10" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <button id="generate-array" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">
                        Generate New Array
                    </button>
                </div>
            </div>
            <div class="bg-gray-900/50 p-4 rounded-lg">
                 <h3 class="text-xl font-semibold mb-4 text-gray-300">Select Racers</h3>
                 <div id="algorithm-selection" class="grid grid-cols-2 gap-3">
                 </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        // --- Basic Setup ---
        let scene, camera, renderer, controls;
        const container = document.getElementById('container');

        // --- DOM Elements ---
        const raceBtn = document.getElementById('race-button');
        const generateArrayBtn = document.getElementById('generate-array');
        const sizeSlider = document.getElementById('size-slider');
        const speedSlider = document.getElementById('speed-slider');
        const sizeValue = document.getElementById('size-value');
        const speedValue = document.getElementById('speed-value');
        const algoSelectionContainer = document.getElementById('algorithm-selection');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsButton = document.getElementById('settings-button');
        const closeSettingsButton = document.getElementById('close-settings-button');

        // --- State ---
        let masterArray = [];
        let racers = [];
        let arraySize = 50;
        let speed = 10;
        let isRacing = false;
        const BAR_WIDTH = 0.8;
        const BAR_DEPTH = 2.0;
        const LANE_SPACING = 8;

        const algorithms = {
            bubbleSort: { name: 'Bubble Sort', func: bubbleSort, color: 0x3b82f6 },
            selectionSort: { name: 'Selection Sort', func: selectionSort, color: 0x16a34a },
            insertionSort: { name: 'Insertion Sort', func: insertionSort, color: 0xc026d3 },
            mergeSort: { name: 'Merge Sort', func: mergeSort, color: 0xea580c },
            quickSort: { name: 'Quick Sort', func: quickSort, color: 0xdc2626 },
        };
        
        let selectedAlgorithms = ['bubbleSort', 'quickSort', 'mergeSort'];

        // --- Colors ---
        const COLORS = {
            comparing: new THREE.Color(0xf59e0b),
            swapping: new THREE.Color(0xef4444),
            sorted: new THREE.Color(0x22c55e),
            pivot: new THREE.Color(0xec4899)
        };
        
        // --- Main Functions ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(arraySize / 2, 60, arraySize + 20);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            scene.add(directionalLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            const barFieldWidth = arraySize * (BAR_WIDTH + 0.1);
            controls.target.set(barFieldWidth / 2, 0, 0);

            setupUI();
            generateMasterArray();
            createRaceLanes();
            animate();
        }
        
        function setupUI() {
            for (const key in algorithms) {
                const div = document.createElement('div');
                div.className = "relative";
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.id = `algo-${key}`;
                input.dataset.algo = key;
                input.className = 'algo-checkbox absolute opacity-0 w-full h-full cursor-pointer';
                if (selectedAlgorithms.includes(key)) {
                    input.checked = true;
                }
                const label = document.createElement('label');
                label.htmlFor = `algo-${key}`;
                label.textContent = algorithms[key].name;
                label.className = 'block text-center py-2 px-1 text-sm border-2 border-gray-600 rounded-md hover:bg-gray-700 transition-all cursor-pointer';
                div.appendChild(input);
                div.appendChild(label);
                algoSelectionContainer.appendChild(div);
            }

            settingsButton.addEventListener('click', () => settingsPanel.classList.remove('translate-x-full'));
            closeSettingsButton.addEventListener('click', () => settingsPanel.classList.add('translate-x-full'));
            
            raceBtn.addEventListener('click', () => {
                if (isRacing) {
                    isRacing = false;
                    setUIState(false);
                } else {
                    startRace();
                }
            });

            generateArrayBtn.addEventListener('click', () => {
                if (isRacing) return;
                generateMasterArray();
                createRaceLanes();
            });

            sizeSlider.addEventListener('input', e => {
                if (isRacing) return;
                arraySize = parseInt(e.target.value);
                sizeValue.textContent = arraySize;
                generateMasterArray();
                createRaceLanes();
                camera.position.set(arraySize / 2, 60, arraySize + 20);
                controls.target.set(arraySize * (BAR_WIDTH + 0.1) / 2, 0, 0);
            });

            speedSlider.addEventListener('input', e => {
                speed = parseInt(e.target.value);
                speedValue.textContent = `${speed}ms`;
            });
            
            algoSelectionContainer.addEventListener('change', e => {
                if (isRacing) { e.target.checked = !e.target.checked; return; };
                const algoKey = e.target.dataset.algo;
                if (e.target.checked) {
                    if (!selectedAlgorithms.includes(algoKey)) selectedAlgorithms.push(algoKey);
                } else {
                    selectedAlgorithms = selectedAlgorithms.filter(key => key !== algoKey);
                }
                createRaceLanes();
            });
        }

        function generateMasterArray() {
            masterArray = [];
            for (let i = 0; i < arraySize; i++) {
                masterArray.push(Math.floor(Math.random() * 100) + 5);
            }
        }
        
        function createTextLabel(text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 48;
            context.font = `Bold ${fontSize}px Inter, Arial, sans-serif`;

            const metrics = context.measureText(text);
            const textWidth = metrics.width;
            canvas.width = textWidth;
            canvas.height = fontSize * 1.2;

            context.font = `Bold ${fontSize}px Inter, Arial, sans-serif`;
            const textColor = new THREE.Color(color).getStyle();
            context.fillStyle = textColor;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            
            const spriteHeight = 6;
            const spriteWidth = (spriteHeight / canvas.height) * canvas.width;
            sprite.scale.set(spriteWidth, spriteHeight, 1);

            return sprite;
        }

        function createRaceLanes() {
            racers.forEach(racer => {
                racer.group.children.forEach(child => {
                    if (child instanceof THREE.Sprite) {
                        child.material.map.dispose();
                        child.material.dispose();
                    }
                });
                scene.remove(racer.group);
            });
            racers = [];

            const totalWidth = (selectedAlgorithms.length - 1) * LANE_SPACING;
            const startZ = -totalWidth / 2;

            selectedAlgorithms.forEach((key, laneIndex) => {
                const algo = algorithms[key];
                const racerGroup = new THREE.Group();
                const barMeshes = [];
                const initialArray = [...masterArray];

                const textLabel = createTextLabel(algo.name, algo.color);
                const barFieldWidth = arraySize * (BAR_WIDTH + 0.1);
                const labelX = barFieldWidth + 25; 
                
                const baseHeight = 90;
                const heightOffset = 20;
                const labelY = baseHeight - (laneIndex % 3) * heightOffset; 
                
                const labelZ = 0;
                textLabel.position.set(labelX, labelY, labelZ);
                racerGroup.add(textLabel);

                for (let i = 0; i < arraySize; i++) {
                    const height = initialArray[i];
                    const geometry = new THREE.BoxGeometry(BAR_WIDTH, height, BAR_DEPTH);
                    // Use the algorithm's specific color for the initial state of the bars
                    const material = new THREE.MeshStandardMaterial({ color: algo.color });
                    const bar = new THREE.Mesh(geometry, material);
                    bar.position.set(i * (BAR_WIDTH + 0.1), height / 2, 0);
                    barMeshes.push(bar);
                    racerGroup.add(bar);
                }
                
                racerGroup.position.z = startZ + laneIndex * LANE_SPACING;
                scene.add(racerGroup);

                racers.push({
                    key: key,
                    name: algo.name,
                    color: algo.color, // Store the color for the algorithm to use
                    group: racerGroup,
                    bars: barMeshes,
                    array: initialArray,
                    isSorted: false
                });
            });
        }
        
        async function startRace() {
            isRacing = true;
            setUIState(true);
            
            generateMasterArray();
            createRaceLanes();
            
            const racePromises = racers.map(racer => {
                const algoFunc = algorithms[racer.key].func;
                return algoFunc(racer);
            });
            
            await Promise.all(racePromises);

            if(isRacing) {
                isRacing = false;
                setUIState(false);
            }
        }

        function setUIState(racing) {
            raceBtn.disabled = false;
            raceBtn.textContent = racing ? "Stop Race" : "Start Race";
            raceBtn.classList.toggle('bg-green-600', !racing);
            raceBtn.classList.toggle('hover:bg-green-700', !racing);
            raceBtn.classList.toggle('bg-red-600', racing);
            raceBtn.classList.toggle('hover:bg-red-700', racing);

            generateArrayBtn.disabled = racing;
            sizeSlider.disabled = racing;
            document.querySelectorAll('.algo-checkbox').forEach(cb => cb.disabled = racing);
        }
        
        function updateBar(bar, value, color) {
             if (!bar) return;
             bar.scale.y = value / (bar.geometry.parameters.height || 1);
             bar.position.y = value / 2;
             bar.material.color.set(color);
        }

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        // --- Sorting Algorithms ---
        async function bubbleSort(racer) {
            let arr = racer.array;
            let n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    if (!isRacing) return;
                    updateBar(racer.bars[j], arr[j], COLORS.comparing);
                    updateBar(racer.bars[j + 1], arr[j+1], COLORS.comparing);
                    await sleep(speed);
                    
                    if (arr[j] > arr[j + 1]) {
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        updateBar(racer.bars[j], arr[j], COLORS.swapping);
                        updateBar(racer.bars[j + 1], arr[j+1], COLORS.swapping);
                        await sleep(speed);
                    }
                    updateBar(racer.bars[j], arr[j], racer.color);
                    updateBar(racer.bars[j + 1], arr[j+1], racer.color);
                }
                 updateBar(racer.bars[n - 1 - i], arr[n - 1 - i], COLORS.sorted);
            }
             updateBar(racer.bars[0], arr[0], COLORS.sorted);
            if (isRacing) racer.isSorted = true;
        }

        async function selectionSort(racer) {
            let arr = racer.array;
            let n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                updateBar(racer.bars[minIdx], arr[minIdx], COLORS.pivot);
                for (let j = i + 1; j < n; j++) {
                    if (!isRacing) return;
                    updateBar(racer.bars[j], arr[j], COLORS.comparing);
                    await sleep(speed);
                    if (arr[j] < arr[minIdx]) {
                         updateBar(racer.bars[minIdx], arr[minIdx], racer.color);
                         minIdx = j;
                         updateBar(racer.bars[minIdx], arr[minIdx], COLORS.pivot);
                    } else {
                         updateBar(racer.bars[j], arr[j], racer.color);
                    }
                }
                
                if (minIdx !== i) {
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                    updateBar(racer.bars[i], arr[i], COLORS.swapping);
                    updateBar(racer.bars[minIdx], arr[minIdx], COLORS.swapping);
                    await sleep(speed);
                }
                updateBar(racer.bars[minIdx], arr[minIdx], racer.color);
                updateBar(racer.bars[i], arr[i], COLORS.sorted);
            }
             updateBar(racer.bars[n - 1], arr[n - 1], COLORS.sorted);
            if (isRacing) racer.isSorted = true;
        }

        async function insertionSort(racer) {
            let arr = racer.array;
            let n = arr.length;
            updateBar(racer.bars[0], arr[0], COLORS.sorted);
            for (let i = 1; i < n; i++) {
                let key = arr[i];
                let j = i - 1;
                updateBar(racer.bars[i], arr[i], COLORS.pivot);
                await sleep(speed);
                
                while (j >= 0 && arr[j] > key) {
                    if (!isRacing) return;
                    arr[j + 1] = arr[j];
                    updateBar(racer.bars[j + 1], arr[j+1], COLORS.swapping);
                    await sleep(speed);
                    updateBar(racer.bars[j + 1], arr[j+1], COLORS.sorted);
                    j--;
                }
                arr[j + 1] = key;
                updateBar(racer.bars[j + 1], arr[j + 1], COLORS.sorted);
                if (isRacing) updateBar(racer.bars[i], arr[i], racer.color); 
                await sleep(speed);
            }
            if (isRacing) {
                for(let i = 0; i < n; i++) updateBar(racer.bars[i], arr[i], COLORS.sorted);
                racer.isSorted = true;
            }
        }

       async function mergeSort(racer) {
            let arr = racer.array;
            async function merge(l, m, r) {
                let n1 = m - l + 1;
                let n2 = r - m;
                let L = arr.slice(l, m + 1);
                let R = arr.slice(m + 1, r + 1);
                let i = 0, j = 0, k = l;
                while (i < n1 && j < n2) {
                    if (!isRacing) return;
                    updateBar(racer.bars[l+i], L[i], COLORS.comparing);
                    updateBar(racer.bars[m+1+j], R[j], COLORS.comparing);
                    await sleep(speed);
                    
                    if (L[i] <= R[j]) {
                        arr[k] = L[i]; 
                        updateBar(racer.bars[k], arr[k], COLORS.swapping);
                        await sleep(speed);
                        updateBar(racer.bars[l+i], L[i], racer.color);
                        updateBar(racer.bars[k], arr[k], racer.color);
                        i++;
                    } else {
                        arr[k] = R[j];
                        updateBar(racer.bars[k], arr[k], COLORS.swapping);
                        await sleep(speed);
                        updateBar(racer.bars[m+1+j], R[j], racer.color);
                        updateBar(racer.bars[k], arr[k], racer.color);
                        j++;
                    }
                    k++;
                }
                while (i < n1) { if (!isRacing) return; arr[k] = L[i]; updateBar(racer.bars[k], arr[k], COLORS.swapping); await sleep(speed); updateBar(racer.bars[k], arr[k], racer.color); i++; k++; }
                while (j < n2) { if (!isRacing) return; arr[k] = R[j]; updateBar(racer.bars[k], arr[k], COLORS.swapping); await sleep(speed); updateBar(racer.bars[k], arr[k], racer.color); j++; k++; }
            }
            async function sort(l, r) {
                if (l >= r) return;
                if (!isRacing) return;
                let m = l + Math.floor((r - l) / 2);
                await sort(l, m);
                if (!isRacing) return;
                await sort(m + 1, r);
                if (!isRacing) return;
                await merge(l, m, r);
            }
            await sort(0, arr.length - 1);
            if (isRacing) {
                for(let i = 0; i < arr.length; i++) updateBar(racer.bars[i], arr[i], COLORS.sorted);
                racer.isSorted = true;
            }
        }

       async function quickSort(racer) {
            let arr = racer.array;
            async function partition(low, high) {
                let pivot = arr[high];
                let i = low - 1;
                updateBar(racer.bars[high], arr[high], COLORS.pivot);

                for (let j = low; j < high; j++) {
                    if (!isRacing) return i + 1;
                    updateBar(racer.bars[j], arr[j], COLORS.comparing);
                    await sleep(speed);
                    if (arr[j] < pivot) {
                        i++;
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                        updateBar(racer.bars[i], arr[i], COLORS.swapping);
                        updateBar(racer.bars[j], arr[j], COLORS.swapping);
                        await sleep(speed);
                        updateBar(racer.bars[i], arr[i], racer.color);
                    }
                    updateBar(racer.bars[j], arr[j], racer.color);
                }
                [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                updateBar(racer.bars[i + 1], arr[i+1], COLORS.swapping);
                updateBar(racer.bars[high], arr[high], COLORS.swapping);
                await sleep(speed);
                updateBar(racer.bars[i + 1], arr[i+1], COLORS.sorted);
                updateBar(racer.bars[high], arr[high], racer.color);
                return i + 1;
            }

            async function sort(low, high) {
                if (low < high) {
                    if (!isRacing) return;
                    let pi = await partition(low, high);
                    if (!isRacing) return;
                    await sort(low, pi - 1);
                    if (!isRacing) return;
                    await sort(pi + 1, high);
                } else if (low >= 0 && low < arr.length && low === high) {
                    updateBar(racer.bars[low], arr[low], COLORS.sorted);
                }
            }
            await sort(0, arr.length - 1);
            if (isRacing) racer.isSorted = true;
        }
        
        init();
    </script>
</body>
</html>

