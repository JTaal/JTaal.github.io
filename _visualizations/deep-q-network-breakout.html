<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep Q-Network (DQN) for Atari Breakout</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #d1d5db; /* text-gray-300 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
        }
        #main-container {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            justify-content: center;
            align-items: flex-start;
        }
        #game-container {
            border: 2px solid #374151; /* border-gray-700 */
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.4), 0 4px 6px -2px rgba(0,0,0,0.2);
        }
        canvas {
            display: block;
            background-color: #000;
            border-radius: 0.5rem;
        }
        #ui-panel {
            background-color: #1f2937; /* bg-gray-800 */
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid #374151; /* border-gray-700 */
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }
        .stat-card {
            background-color: #374151; /* bg-gray-700 */
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
        }
        .stat-card-label {
            font-size: 0.875rem;
            color: #9ca3af; /* text-gray-400 */
        }
        .stat-card-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: #f9fafb; /* text-gray-50 */
        }
        .control-button {
            background-color: #4f46e5; /* bg-indigo-600 */
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .control-button:hover {
            background-color: #4338ca; /* bg-indigo-700 */
        }
        .control-button:disabled {
            background-color: #4b5563; /* bg-gray-600 */
            cursor: not-allowed;
        }
        .chart-container {
            background-color: #374151; /* bg-gray-700 */
            padding: 1rem;
            border-radius: 0.5rem;
            height: 200px;
        }
        h1 {
            font-size: 2.25rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: #f9fafb;
            text-align: center;
        }
        h2 {
           font-size: 1.5rem;
           font-weight: 600;
           margin-bottom: 0.5rem;
           color: #e5e7eb;
        }
    </style>

    {% comment %} --- Jekyll Social Meta Include --- {% endcomment %}
    {%- assign page_title = "Deep Q Network Breakout" -%}
    {%- assign viz_data = site.data.projects | where: "title", page_title | first -%}
    {%- if viz_data -%}
      {% include social-meta.html
          title=viz_data.title
          description=viz_data.description
          thumbnail=viz_data.thumbnail
          full_url=viz_data.full_url
      %}
    {%- endif -%}
    {% comment %} --- End Include --- {% endcomment %}
</head>

<body>
    <h1>DQN learns Atari Breakout</h1>
    <div id="main-container">
        <div id="game-container">
            <canvas id="breakout-canvas" width="400" height="500"></canvas>
        </div>
        <div id="ui-panel">
            <div>
                <h2 class="text-center">Training Metrics</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-card-label">Episode</div>
                        <div id="episode-value" class="stat-card-value">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Total Steps</div>
                        <div id="step-value" class="stat-card-value">0</div>
                    </div>
                     <div class="stat-card">
                        <div class="stat-card-label">Last Score</div>
                        <div id="score-value" class="stat-card-value">0</div>
                    </div>
                     <div class="stat-card">
                        <div class="stat-card-label">Epsilon</div>
                        <div id="epsilon-value" class="stat-card-value">1.00</div>
                    </div>
                </div>
            </div>
            <div>
                <h2>Controls</h2>
                <div class="flex gap-4">
                    <button id="start-btn" class="control-button w-full">Start Training</button>
                    <button id="stop-btn" class="control-button w-full">Stop</button>
                </div>
            </div>
             <div>
                <h2>Score History</h2>
                <div class="chart-container">
                    <canvas id="score-chart"></canvas>
                </div>
            </div>
        </div>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('breakout-canvas');
        const ctx = canvas.getContext('2d');

        // --- Game Components & State ---
        let paddle, ball, bricks, score, lives, isGameOver;
        let isTraining = false;
        let animationFrameId;

        // --- DQN Agent and Hyperparameters ---
        const STATE_SIZE = 5; // [paddleX, ballX, ballY, ballVX, ballVY]
        const ACTION_SIZE = 3; // 0: stay, 1: left, 2: right
        const agent = new DQNAgent(STATE_SIZE, ACTION_SIZE);
        
        let episode = 0;
        let totalSteps = 0;
        const scoreHistory = [];

        // --- UI Elements ---
        const episodeValue = document.getElementById('episode-value');
        const stepValue = document.getElementById('step-value');
        const scoreValue = document.getElementById('score-value');
        const epsilonValue = document.getElementById('epsilon-value');
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        
        // --- Chart.js Setup ---
        const chartCtx = document.getElementById('score-chart').getContext('2d');
        const scoreChart = new Chart(chartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Score per Episode',
                    data: [],
                    borderColor: '#6366f1',
                    backgroundColor: 'rgba(99, 102, 241, 0.2)',
                    borderWidth: 2,
                    tension: 0.1,
                    fill: true,
                }]
            },
            options: {
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: true, ticks: { color: '#9ca3af' }},
                    x: { ticks: { color: '#9ca3af' }}
                },
                plugins: { legend: { display: false } }
            }
        });

        // --- Game Constants ---
        const PADDLE_WIDTH = 80, PADDLE_HEIGHT = 15, PADDLE_SPEED = 8;
        const BALL_RADIUS = 8;
        const BRICK_ROWS = 5, BRICK_COLS = 8;
        const BRICK_HEIGHT = 20, BRICK_GAP = 4;
        const BRICK_WIDTH = (canvas.width - (BRICK_COLS + 1) * BRICK_GAP) / BRICK_COLS;
        
        // --- Game Object Definitions ---
        function createPaddle() {
            return {
                x: (canvas.width - PADDLE_WIDTH) / 2,
                y: canvas.height - PADDLE_HEIGHT - 20,
                width: PADDLE_WIDTH,
                height: PADDLE_HEIGHT,
                speed: PADDLE_SPEED
            };
        }

        function createBall() {
            return {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: BALL_RADIUS,
                vx: 3 * (Math.random() > 0.5 ? 1 : -1),
                vy: -3
            };
        }

        function createBricks() {
            const newBricks = [];
            for (let r = 0; r < BRICK_ROWS; r++) {
                for (let c = 0; c < BRICK_COLS; c++) {
                    newBricks.push({
                        x: BRICK_GAP + c * (BRICK_WIDTH + BRICK_GAP),
                        y: BRICK_GAP + 50 + r * (BRICK_HEIGHT + BRICK_GAP),
                        width: BRICK_WIDTH,
                        height: BRICK_HEIGHT,
                        visible: true
                    });
                }
            }
            return newBricks;
        }

        function resetGame() {
            paddle = createPaddle();
            ball = createBall();
            bricks = createBricks();
            score = 0;
            lives = 3; 
            isGameOver = false;
        }

        // --- Drawing Functions ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw paddle
            ctx.fillStyle = '#a5b4fc'; // indigo-300
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            // Draw ball
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#f87171'; // red-400
            ctx.fill();
            ctx.closePath();
            // Draw bricks
            bricks.forEach(brick => {
                if (brick.visible) {
                    ctx.fillStyle = '#6ee7b7'; // emerald-300
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                }
            });
            // Draw score and lives
            ctx.fillStyle = '#d1d5db';
            ctx.font = '16px Inter';
            ctx.fillText(`Score: ${score}`, 8, 20);
            ctx.fillText(`Lives: ${lives}`, canvas.width - 65, 20);
        }
        
        // --- Game Logic & Physics ---
        function update(action) {
            // Move paddle based on action
            if (action === 1) paddle.x -= paddle.speed; // Left
            if (action === 2) paddle.x += paddle.speed; // Right
            paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));

            // Move ball
            ball.x += ball.vx;
            ball.y += ball.vy;

            let reward = 0;
            let done = false;

            // Wall collision
            if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.vx *= -1;
            if (ball.y - ball.radius < 0) ball.vy *= -1;

            // Paddle collision
            if (ball.y + ball.radius > paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                ball.vy *= -1;
                // Add slight angle change based on where it hits the paddle
                let deltaX = ball.x - (paddle.x + paddle.width / 2);
                ball.vx = deltaX * 0.2;
            }

            // Brick collision
            bricks.forEach(brick => {
                if (brick.visible && ball.x > brick.x && ball.x < brick.x + brick.width && ball.y > brick.y && ball.y < brick.y + brick.height) {
                    ball.vy *= -1;
                    brick.visible = false;
                    score++;
                    reward = 10; // Positive reward for hitting a brick
                }
            });

            // Bottom wall (lose life)
            if (ball.y + ball.radius > canvas.height) {
                lives--;
                reward = -10; // Negative reward for losing a life
                if (lives <= 0) {
                    done = true;
                    isGameOver = true;
                } else {
                    ball.x = canvas.width / 2;
                    ball.y = canvas.height / 2;
                    ball.vx = 3 * (Math.random() > 0.5 ? 1 : -1);
                    ball.vy = -3;
                }
            }
            
            // All bricks cleared
            if (bricks.every(b => !b.visible)) {
                done = true;
                isGameOver = true;
                reward = 50; // Big reward for winning
            }

            return { reward, done };
        }

        // --- State Representation for AI ---
        function getGameState() {
            // Normalize state values to be between ~0 and 1
            const paddleX = paddle.x / canvas.width;
            const ballX = ball.x / canvas.width;
            const ballY = ball.y / canvas.height;
            const ballVX = ball.vx / 10; // Normalize by an arbitrary max speed
            const ballVY = ball.vy / 10;
            return [paddleX, ballX, ballY, ballVX, ballVY];
        }
        
        // --- The AI Training Step ---
        async function trainStep() {
            if (!isTraining) return;

            const state = getGameState();
            const action = agent.act(state);

            const { reward, done } = update(action);
            const nextState = getGameState();

            agent.remember(state, action, reward, nextState, done);
            
            if(agent.replayBuffer.length > agent.batchSize) {
               agent.replay();
            }

            totalSteps++;
            stepValue.textContent = totalSteps;

            if (done) {
                agent.updateTargetNetwork();
                scoreHistory.push(score);
                updateUI();
                resetGame();
                episode++;
            }
            
            draw();
            animationFrameId = requestAnimationFrame(trainStep);
        }

        function updateUI() {
            episodeValue.textContent = episode;
            scoreValue.textContent = score;
            epsilonValue.textContent = agent.epsilon.toFixed(2);
            
            // Update chart
            if (scoreHistory.length > 0) {
                scoreChart.data.labels = scoreHistory.map((_, i) => i + 1);
                scoreChart.data.datasets[0].data = scoreHistory;
                scoreChart.update();
            }
        }
        
        // --- Control Functions ---
        function startTraining() {
            if (isTraining) return;
            isTraining = true;
            startBtn.disabled = true;
            stopBtn.disabled = false;
            resetGame();
            trainStep();
        }

        function stopTraining() {
            if (!isTraining) return;
            isTraining = false;
            startBtn.disabled = false;
            stopBtn.disabled = true;
            cancelAnimationFrame(animationFrameId);
        }
        
        // --- Event Listeners ---
        startBtn.addEventListener('click', startTraining);
        stopBtn.addEventListener('click', stopTraining);

        // --- Initial Setup ---
        resetGame();
        draw();
        stopBtn.disabled = true;
    });

    // --- Simple Matrix Library ---
    class Matrix {
        constructor(rows, cols) {
            this.rows = rows;
            this.cols = cols;
            this.data = Array(rows).fill().map(() => Array(cols).fill(0));
        }
        
        clone() {
            let m = new Matrix(this.rows, this.cols);
            m.data = JSON.parse(JSON.stringify(this.data));
            return m;
        }

        static fromArray(arr) {
            let m = new Matrix(arr.length, 1);
            m.data = arr.map(val => [val]);
            return m;
        }

        static subtract(a, b) {
            const result = new Matrix(a.rows, a.cols);
            for(let i=0; i<a.rows; i++) {
                for(let j=0; j<a.cols; j++) {
                    result.data[i][j] = a.data[i][j] - b.data[i][j];
                }
            }
            return result;
        }

        toArray() { return this.data.flat(); }
        randomize() { this.data = this.data.map(row => row.map(() => Math.random() * 2 - 1)); }

        add(n) {
            if (n instanceof Matrix) {
                if (this.rows !== n.rows || this.cols !== n.cols) {
                    throw new Error("Matrix dimensions must match for addition");
                }
                this.data = this.data.map((row, i) => row.map((val, j) => val + n.data[i][j]));
            } else { // scalar addition
                this.data = this.data.map(row => row.map(val => val + n));
            }
        }

        multiply(n) {
            if (n instanceof Matrix) { // Element-wise (Hadamard)
                if (this.rows !== n.rows || this.cols !== n.cols) throw new Error("Matrix dimensions must match for element-wise multiplication");
                this.data = this.data.map((row, i) => row.map((val, j) => val * n.data[i][j]));
            } else { // Scalar
                this.data = this.data.map(row => row.map(val => val * n));
            }
        }

        map(fn) { this.data = this.data.map((row, i) => row.map((val, j) => fn(val, i, j)));}
        
        static multiply(a, b) {
            if (a.cols !== b.rows) throw new Error("Matrix dimensions mismatch for multiplication");
            const result = new Matrix(a.rows, b.cols);
            for(let i=0; i<result.rows; i++) {
                for(let j=0; j<result.cols; j++) {
                    let sum = 0;
                    for(let k=0; k<a.cols; k++) sum += a.data[i][k] * b.data[k][j];
                    result.data[i][j] = sum;
                }
            }
            return result;
        }

        static transpose(matrix) {
            const result = new Matrix(matrix.cols, matrix.rows);
            for(let i=0; i<matrix.rows; i++) {
                for(let j=0; j<matrix.cols; j++) {
                    result.data[j][i] = matrix.data[i][j];
                }
            }
            return result;
        }
    }
    
    // --- Minimal Neural Network Implementation ---
    class NeuralNetwork {
        constructor(inputNodes, hiddenNodes, outputNodes) {
            this.inputNodes = inputNodes;
            this.hiddenNodes = hiddenNodes;
            this.outputNodes = outputNodes;

            this.weights_ih = new Matrix(this.hiddenNodes, this.inputNodes);
            this.weights_ho = new Matrix(this.outputNodes, this.hiddenNodes);
            this.weights_ih.randomize();
            this.weights_ho.randomize();

            this.bias_h = new Matrix(this.hiddenNodes, 1);
            this.bias_o = new Matrix(this.outputNodes, 1);
            this.bias_h.randomize();
            this.bias_o.randomize();
            
            this.learningRate = 0.001;
        }
        
        relu(x) { return Math.max(0, x); }
        relu_derivative(x) { return x > 0 ? 1 : 0; }

        predict(inputArray) {
            // --- Feedforward ---
            const inputs = Matrix.fromArray(inputArray);
            let hidden = Matrix.multiply(this.weights_ih, inputs);
            hidden.add(this.bias_h);
            hidden.map(this.relu);

            let output = Matrix.multiply(this.weights_ho, hidden);
            output.add(this.bias_o);
            // No activation on final output for Q-values
            
            return output.toArray();
        }

        train(inputArray, targetArray) {
            // --- Feedforward (same as predict) ---
            const inputs = Matrix.fromArray(inputArray);
            let hidden = Matrix.multiply(this.weights_ih, inputs);
            hidden.add(this.bias_h);
            hidden.map(this.relu);

            let outputs = Matrix.multiply(this.weights_ho, hidden);
            outputs.add(this.bias_o);
            
            // --- Backpropagation ---
            const targets = Matrix.fromArray(targetArray);
            const output_errors = Matrix.subtract(targets, outputs);

            // Calculate gradient for weights_ho
            let gradients = Matrix.multiply(output_errors, Matrix.transpose(hidden));
            gradients.multiply(this.learningRate);
            
            // Adjust weights and biases for ho layer
            this.weights_ho.add(gradients);
            const bias_o_deltas = output_errors.clone();
            bias_o_deltas.multiply(this.learningRate);
            this.bias_o.add(bias_o_deltas);
            
            // Calculate hidden layer errors
            const who_t = Matrix.transpose(this.weights_ho);
            const hidden_errors = Matrix.multiply(who_t, output_errors);

            // Calculate hidden gradient
            let hidden_gradient = hidden.clone();
            hidden_gradient.map(this.relu_derivative);
            hidden_gradient.multiply(hidden_errors); // Element-wise multiply
            hidden_gradient.multiply(this.learningRate);

            // Adjust weights and biases for ih layer
            const inputs_t = Matrix.transpose(inputs);
            const weight_ih_deltas = Matrix.multiply(hidden_gradient, inputs_t);
            this.weights_ih.add(weight_ih_deltas);
            this.bias_h.add(hidden_gradient);
        }
        
        clone() {
            const newNN = new NeuralNetwork(this.inputNodes, this.hiddenNodes, this.outputNodes);
            newNN.weights_ih.data = JSON.parse(JSON.stringify(this.weights_ih.data));
            newNN.weights_ho.data = JSON.parse(JSON.stringify(this.weights_ho.data));
            newNN.bias_h.data = JSON.parse(JSON.stringify(this.bias_h.data));
            newNN.bias_o.data = JSON.parse(JSON.stringify(this.bias_o.data));
            return newNN;
        }
    }

    // --- DQN Agent Implementation ---
    class DQNAgent {
        constructor(stateSize, actionSize) {
            this.stateSize = stateSize;
            this.actionSize = actionSize;
            
            this.replayBuffer = [];
            this.replayBufferSize = 10000;
            
            this.gamma = 0.95;    // discount rate
            this.epsilon = 1.0;   // exploration rate
            this.epsilonMin = 0.01;
            this.epsilonDecay = 0.9995;
            this.batchSize = 32;

            this.model = new NeuralNetwork(stateSize, 24, actionSize);
            this.targetModel = this.model.clone();
        }

        remember(state, action, reward, nextState, done) {
            if (this.replayBuffer.length > this.replayBufferSize) {
                this.replayBuffer.shift(); // Remove oldest experience
            }
            this.replayBuffer.push({ state, action, reward, nextState, done });
        }

        act(state) {
            if (Math.random() <= this.epsilon) {
                return Math.floor(Math.random() * this.actionSize);
            }
            const qValues = this.model.predict(state);
            return qValues.indexOf(Math.max(...qValues));
        }

        replay() {
            const batch = [];
            for (let i = 0; i < this.batchSize; i++) {
                const index = Math.floor(Math.random() * this.replayBuffer.length);
                batch.push(this.replayBuffer[index]);
            }
            
            for(const experience of batch) {
                const { state, action, reward, nextState, done } = experience;
                
                let target = reward;
                if (!done) {
                    const nextQ = this.targetModel.predict(nextState);
                    target = reward + this.gamma * Math.max(...nextQ);
                }
                
                const qValues = this.model.predict(state);
                const targetQValues = [...qValues];
                targetQValues[action] = target;

                this.model.train(state, targetQValues);
            }

            if (this.epsilon > this.epsilonMin) {
                this.epsilon *= this.epsilonDecay;
            }
        }
        
        updateTargetNetwork() {
            this.targetModel = this.model.clone();
        }
    }
</script>
</body>
</html>

