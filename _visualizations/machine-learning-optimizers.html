<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Learning Optimisers</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0KOVEMMZMZNkJHNEUIM+yBIAnFCeFnEEiAdma8Mvl/ttJBYcvfGLA" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        :root {
            /* Default Theme: Cyber Purple */
            --theme-bg-color: #000000;
            --theme-title-color: rgba(255, 255, 255, 0.9);
            --theme-title-shadow: rgba(196, 138, 245, 0.4);
            --theme-info-bg: rgba(26, 22, 46, 0.7);
            --theme-info-border: rgba(155, 89, 182, 0.3);
            --theme-info-shadow: rgba(0,0,0,0.2);
            --theme-info-border-top: rgba(155, 89, 182, 0.2);

            --lil-gui-bg-color: #1a162e;
            --lil-gui-text-color: #dcd0ff;
            --lil-gui-title-background-color: #2c254a;
            --lil-gui-title-text-color: #f0eaff;
            --lil-gui-widget-color: #4a407c;
            --lil-gui-hover-color: #594d94;
            --lil-gui-focus-color: #8e44ad;
            --lil-gui-number-color: #c4a7f5;
            --lil-gui-string-color: #c4a7f5;
            --lil-gui-border-color: rgba(155, 89, 182, 0.2);
            --lil-gui-separator-color: #2c254a;
        }
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: var(--theme-bg-color);
            color: #ffffff;
        }
        #render-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: pointer;
        }
        #title {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--theme-title-color);
            text-shadow: 0 0 15px var(--theme-title-shadow);
            white-space: nowrap; /* Ensures title stays on one line */
        }
        #info-panel {
            position: absolute;
            top: 7rem;
            left: 2rem;
            z-index: 10;
            background: var(--theme-info-bg);
            padding: 1rem;
            border-radius: 0.75rem;
            max-width: 320px;
            backdrop-filter: blur(8px);
            border: 1px solid var(--theme-info-border);
            transition: opacity 0.3s;
            box-shadow: 0 4px 30px var(--theme-info-shadow);
        }
        #gradient-display {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--theme-info-border-top);
        }

        .lil-gui.root {
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            border: 1px solid var(--lil-gui-border-color);
            border-radius: 10px;
        }
        .lil-gui .title {
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .lil-gui.root > .children {
             border-radius: 0 0 10px 10px;
        }
        .lil-gui .controller:not(:last-child) {
            border-bottom: 1px solid var(--lil-gui-separator-color);
        }
        .lil-gui .controller > .name {
            color: var(--lil-gui-text-color);
        }
        .lil-gui .slider {
            background-color: var(--lil-gui-title-background-color);
            border-radius: 4px;
        }
        .lil-gui .slider .fill {
            background-color: var(--lil-gui-focus-color);
        }
        .lil-gui .button, .lil-gui select {
            background-color: var(--lil-gui-widget-color);
            color: var(--lil-gui-text-color);
            border-radius: 4px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .lil-gui .button:hover, .lil-gui select:hover {
            background-color: var(--lil-gui-hover-color);
        }
        .lil-gui .button:active {
            background-color: var(--lil-gui-focus-color);
        }
        
        @media (max-width: 768px) {
            #title { font-size: 1.5rem; top: 1rem; }
            #info-panel { display: none; }
            .lil-gui.root { bottom: 0; top: auto; left: 0; right: auto; width: 100%; max-height: 45vh; overflow-y: auto; border-radius: 10px 10px 0 0; }
        }
    </style>
</head>
<body>
    <h1 id="title">Machine Learning Optimisers</h1>
    <div id="info-panel">
        <h2 class="text-lg font-bold mb-2">Function Landscape</h2>
        <div id="katex-formula"></div>
        <div id="gradient-display" style="display: none;"></div>
    </div>
    <div id="render-container"></div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import { GUI } from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/dist/lil-gui.esm.js';

        let scene, camera, renderer, controls, raycaster, mouse;
        let surfaceMesh, optimizerSphere, pathLine, tangentLine;
        let cameraOffset = new THREE.Vector3(); // For follow cam logic

        const container = document.getElementById('render-container');
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(20, 20, 20);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        const colorSchemes = {
            'Cyber Purple': { wireframe: 0x9b59b6, css: { '--lil-gui-bg-color': '#1a162e', '--lil-gui-text-color': '#dcd0ff', '--lil-gui-title-background-color': '#2c254a', '--lil-gui-title-text-color': '#f0eaff', '--lil-gui-widget-color': '#4a407c', '--lil-gui-hover-color': '#594d94', '--lil-gui-focus-color': '#8e44ad', '--lil-gui-number-color': '#c4a7f5', '--lil-gui-string-color': '#c4a7f5', '--lil-gui-border-color': 'rgba(155, 89, 182, 0.2)', '--lil-gui-separator-color': '#2c254a', '--theme-title-shadow': 'rgba(196, 138, 245, 0.4)', '--theme-info-bg': 'rgba(26, 22, 46, 0.7)', '--theme-info-border': 'rgba(155, 89, 182, 0.3)', '--theme-info-border-top': 'rgba(155, 89, 182, 0.2)' } },
            'Ocean Blue': { wireframe: 0x3498db, css: { '--lil-gui-bg-color': '#1a2a3a', '--lil-gui-text-color': '#d0e8ff', '--lil-gui-title-background-color': '#25374a', '--lil-gui-title-text-color': '#eaf5ff', '--lil-gui-widget-color': '#3f6b9c', '--lil-gui-hover-color': '#4a7db8', '--lil-gui-focus-color': '#2980b9', '--lil-gui-number-color': '#a7d0f5', '--lil-gui-string-color': '#a7d0f5', '--lil-gui-border-color': 'rgba(89, 155, 182, 0.2)', '--lil-gui-separator-color': '#25374a', '--theme-title-shadow': 'rgba(138, 201, 245, 0.4)', '--theme-info-bg': 'rgba(22, 36, 46, 0.7)', '--theme-info-border': 'rgba(89, 155, 182, 0.3)', '--theme-info-border-top': 'rgba(89, 155, 182, 0.2)' } },
            'Forest Green': { wireframe: 0x27ae60, css: { '--lil-gui-bg-color': '#1a2e2a', '--lil-gui-text-color': '#d0ffeb', '--lil-gui-title-background-color': '#254a37', '--lil-gui-title-text-color': '#eafff5', '--lil-gui-widget-color': '#3f9c6b', '--lil-gui-hover-color': '#4ab87d', '--lil-gui-focus-color': '#2ecc71', '--lil-gui-number-color': '#a7f5d0', '--lil-gui-string-color': '#a7f5d0', '--lil-gui-border-color': 'rgba(89, 182, 119, 0.2)', '--lil-gui-separator-color': '#254a37', '--theme-title-shadow': 'rgba(138, 245, 173, 0.4)', '--theme-info-bg': 'rgba(22, 46, 36, 0.7)', '--theme-info-border': 'rgba(89, 182, 119, 0.3)', '--theme-info-border-top': 'rgba(89, 182, 119, 0.2)' } },
            'Solar Flare': { wireframe: 0xf1c40f, css: { '--lil-gui-bg-color': '#2e2216', '--lil-gui-text-color': '#ffe8d0', '--lil-gui-title-background-color': '#4a3725', '--lil-gui-title-text-color': '#fff5ea', '--lil-gui-widget-color': '#9c6b3f', '--lil-gui-hover-color': '#b87d4a', '--lil-gui-focus-color': '#e67e22', '--lil-gui-number-color': '#f5d0a7', '--lil-gui-string-color': '#f5d0a7', '--lil-gui-border-color': 'rgba(182, 119, 89, 0.2)', '--lil-gui-separator-color': '#4a3725', '--theme-title-shadow': 'rgba(245, 173, 138, 0.4)', '--theme-info-bg': 'rgba(46, 36, 22, 0.7)', '--theme-info-border': 'rgba(182, 119, 89, 0.3)', '--theme-info-border-top': 'rgba(182, 119, 89, 0.2)' } },
            'Monochrome Matrix': { wireframe: 0xffffff, css: { '--lil-gui-bg-color': '#1c1c1c', '--lil-gui-text-color': '#e0e0e0', '--lil-gui-title-background-color': '#333333', '--lil-gui-title-text-color': '#ffffff', '--lil-gui-widget-color': '#555555', '--lil-gui-hover-color': '#6b6b6b', '--lil-gui-focus-color': '#00ff7f', '--lil-gui-number-color': '#ffffff', '--lil-gui-string-color': '#ffffff', '--lil-gui-border-color': 'rgba(136, 136, 136, 0.2)', '--lil-gui-separator-color': '#333333', '--theme-title-shadow': 'rgba(221, 221, 221, 0.4)', '--theme-info-bg': 'rgba(28, 28, 28, 0.7)', '--theme-info-border': 'rgba(136, 136, 136, 0.3)', '--theme-info-border-top': 'rgba(136, 136, 136, 0.2)' } },
            'Sakura Pink': { wireframe: 0xffa7b5, css: { '--lil-gui-bg-color': '#2e1621', '--lil-gui-text-color': '#ffd0d9', '--lil-gui-title-background-color': '#4a2533', '--lil-gui-title-text-color': '#ffeaf0', '--lil-gui-widget-color': '#9c3f61', '--lil-gui-hover-color': '#b84a72', '--lil-gui-focus-color': '#e62261', '--lil-gui-number-color': '#f5a7b5', '--lil-gui-string-color': '#f5a7b5', '--lil-gui-border-color': 'rgba(182, 89, 119, 0.2)', '--lil-gui-separator-color': '#4a2533', '--theme-title-shadow': 'rgba(245, 138, 173, 0.4)', '--theme-info-bg': 'rgba(46, 22, 33, 0.7)', '--theme-info-border': 'rgba(182, 89, 119, 0.3)', '--theme-info-border-top': 'rgba(182, 89, 119, 0.2)' } }
        };

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3); scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(50, 100, 75); scene.add(directionalLight);

        const landscapes = {
            'ðŸŸ¢ Simple Valley': { func: (x, z) => 0.01 * (x * x + z * z), gradient: (x, z) => new THREE.Vector2(0.02 * x, 0.02 * z), formula: 'f(x,z)=0.01(x^2+z^2)' },
            'ðŸŸ¢ Booth': { func: (x, z) => (x + 2*z - 7)**2 + (2*x + z - 5)**2, gradient: (x, z) => new THREE.Vector2(10*x + 8*z - 34, 8*x + 10*z - 38), formula: 'f(x,z)=(x+2z-7)^2+(2x+z-5)^2' },
            'ðŸŸ¢ Matyas': { func: (x, z) => 0.26 * (x**2 + z**2) - 0.48 * x * z, gradient: (x, z) => new THREE.Vector2(0.52*x - 0.48*z, 0.52*z - 0.48*x), formula: 'f(x,z)=0.26(x^2+z^2)-0.48xz' },
            'ðŸŸ¡ Multimodal Landscape': { func: (x, z) => Math.sin(x) * Math.cos(z) + 0.01 * (x*x + z*z), gradient: (x, z) => new THREE.Vector2(Math.cos(x) * Math.cos(z) + 0.02 * x, -Math.sin(x) * Math.sin(z) + 0.02 * z), formula: 'f(x,z)=\\sin(x)\\cos(z)+0.01(x^2+z^2)' },
            'ðŸŸ¡ Three-Hump Camel': { func: (x, z) => 2*x**2 - 1.05*x**4 + (x**6)/6 + x*z + z**2, gradient: (x,z) => new THREE.Vector2(4*x-4.2*x**3+x**5+z, x+2*z), formula: 'f(x,z)=2x^2-1.05x^4+x^6/6+xz+z^2' },
            'ðŸŸ¡ Himmelblau': { func: (x, z) => (x**2+z-11)**2 + (x+z**2-7)**2, gradient: (x,z) => new THREE.Vector2(4*x*(x**2+z-11)+2*(x+z**2-7), 2*(x**2+z-11)+4*z*(x+z**2-7)), formula: 'f(x,z)=(x^2+z-11)^2+(x+z^2-7)^2' },
            'ðŸŸ¡ LÃ©vi N.13': { func: (x, z) => Math.sin(3*Math.PI*x)**2 + (x-1)**2*(1+Math.sin(3*Math.PI*z)**2) + (z-1)**2*(1+Math.sin(2*Math.PI*z)**2), gradient: (x,z) => { const dx=3*Math.PI*Math.sin(6*Math.PI*x)+2*(x-1)*(1+Math.sin(3*Math.PI*z)**2); const dz=3*Math.PI*(x-1)**2*Math.sin(6*Math.PI*z)+2*(z-1)*(1+Math.sin(2*Math.PI*z)**2)+2*Math.PI*(z-1)**2*Math.sin(4*Math.PI*z); return new THREE.Vector2(dx, dz); }, formula: 'f(x,z)=\\sin^2(3\\pi x)+(..)^2+(..)^2' },
            'ðŸŸ¡ Easom': { func: (x, z) => -Math.cos(x)*Math.cos(z)*Math.exp(-((x-Math.PI)**2+(z-Math.PI)**2)), gradient: (x,z) => { const E=Math.exp(-((x-Math.PI)**2+(z-Math.PI)**2)); const dx=E*(Math.sin(x)*Math.cos(z)+2*(x-Math.PI)*Math.cos(x)*Math.cos(z)); const dz=E*(Math.cos(x)*Math.sin(z)+2*(z-Math.PI)*Math.cos(x)*Math.cos(z)); return new THREE.Vector2(dx, dz); }, formula: 'f(x,z)=-\\cos(x)\\cos(z)e^{-((..)^2)}' },
            'ðŸ”´ Rastrigin': { func: (x, z) => 20+(x*x-10*Math.cos(2*Math.PI*x))+(z*z-10*Math.cos(2*Math.PI*z)), gradient: (x, z) => new THREE.Vector2(2*x+20*Math.PI*Math.sin(2*Math.PI*x), 2*z+20*Math.PI*Math.sin(2*Math.PI*z)), formula: 'f(x,z)=20+\\sum(x_i^2-10\\cos(2\\pi x_i))' },
            'ðŸ”´ Ackley': { func: (x, z) => -20*Math.exp(-0.2*Math.sqrt(0.5*(x**2+z**2)))-Math.exp(0.5*(Math.cos(2*Math.PI*x)+Math.cos(2*Math.PI*z)))+20+Math.E, gradient: (x,z) => { const t=Math.sqrt(0.5*(x**2+z**2)); if(t===0) return new THREE.Vector2(0,0); const ex1=Math.exp(-0.2*t); const ex2=Math.exp(0.5*(Math.cos(2*Math.PI*x)+Math.cos(2*Math.PI*z))); const dx=(2*x*ex1/t)+Math.PI*ex2*Math.sin(2*Math.PI*x); const dz=(2*z*ex1/t)+Math.PI*ex2*Math.sin(2*Math.PI*z); return new THREE.Vector2(dx, dz); }, formula: 'f(x,z)=-20e^{-0.2\\sqrt{..}}-e^{0.5(\\cos(..))}+20+e' },
            'ðŸ”´ Beale': { func: (x,z)=>(1.5-x+x*z)**2+(2.25-x+x*z**2)**2+(2.625-x+x*z**3)**2, gradient: (x,z)=>{ const t1=1.5-x+x*z; const t2=2.25-x+x*z**2; const t3=2.625-x+x*z**3; const dx=2*t1*(-1+z)+2*t2*(-1+z**2)+2*t3*(-1+z**3); const dz=2*t1*x+2*t2*(2*x*z)+2*t3*(3*x*z**2); return new THREE.Vector2(dx,dz);}, formula: 'f(x,z)=(1.5-x+xz)^2+...'},
            'ðŸ”´ Goldstein-Price': { func: (x, z)=>(1+(x+z+1)**2*(19-14*x+3*x**2-14*z+6*x*z+3*z**2))*(30+(2*x-3*z)**2*(18-32*x+12*x**2+48*z-36*x*z+27*z**2)), gradient: (x,z)=>{ const h=1e-5; const f_b=landscapes['ðŸ”´ Goldstein-Price'].func(x,z); return new THREE.Vector2((landscapes['ðŸ”´ Goldstein-Price'].func(x+h,z)-f_b)/h, (landscapes['ðŸ”´ Goldstein-Price'].func(x,z+h)-f_b)/h);}, formula: 'f(x,z)=[1+(...)^2][30+(...)^2]'},
            'ðŸ”´ Rosenbrock': { func: (x, z)=>(1-x)**2+100*(z-x**2)**2, gradient: (x,z)=>new THREE.Vector2(-2*(1-x)-400*x*(z-x**2), 200*(z-x**2)), formula: 'f(x,z)=(1-x)^2+100(z-x^2)^2' },
        };
        
        class GradientDescent { constructor(lr) { this.lr=lr; } step(pos, grad) { return new THREE.Vector2(pos.x-this.lr*grad.x, pos.y-this.lr*grad.y); } reset(){} }
        class Momentum { constructor(lr, beta=0.9) { this.lr=lr; this.beta=beta; this.velocity=new THREE.Vector2(0,0); } step(pos, grad) { this.velocity.x=this.beta*this.velocity.x+(1-this.beta)*grad.x; this.velocity.y=this.beta*this.velocity.y+(1-this.beta)*grad.y; return new THREE.Vector2(pos.x-this.lr*this.velocity.x, pos.y-this.lr*this.velocity.y); } reset() { this.velocity.set(0,0); } }
        class NAG { constructor(lr, beta=0.9) { this.lr=lr; this.beta=beta; this.velocity=new THREE.Vector2(0,0); } step(pos, grad) { const lookahead_pos = new THREE.Vector2(pos.x - this.beta * this.velocity.x, pos.y - this.beta * this.velocity.y); const lookahead_grad = currentLandscape.gradient(lookahead_pos.x, lookahead_pos.y); this.velocity.x = this.beta * this.velocity.x + this.lr * lookahead_grad.x; this.velocity.y = this.beta * this.velocity.y + this.lr * lookahead_grad.y; return new THREE.Vector2(pos.x - this.velocity.x, pos.y - this.velocity.y); } reset() { this.velocity.set(0,0); } }
        class Adagrad { constructor(lr, epsilon=1e-8) { this.lr=lr; this.epsilon=epsilon; this.G=new THREE.Vector2(0,0); } step(pos, grad) { this.G.x+=grad.x**2; this.G.y+=grad.y**2; const ad_lr_x=this.lr/(Math.sqrt(this.G.x)+this.epsilon); const ad_lr_y=this.lr/(Math.sqrt(this.G.y)+this.epsilon); return new THREE.Vector2(pos.x-ad_lr_x*grad.x, pos.y-ad_lr_y*grad.y); } reset() { this.G.set(0,0); } }
        class RMSprop { constructor(lr, beta=0.9, epsilon=1e-8) { this.lr=lr; this.beta=beta; this.epsilon=epsilon; this.Eg=new THREE.Vector2(0,0); } step(pos, grad) { this.Eg.x=this.beta*this.Eg.x+(1-this.beta)*(grad.x**2); this.Eg.y=this.beta*this.Eg.y+(1-this.beta)*(grad.y**2); const ad_lr_x=this.lr/(Math.sqrt(this.Eg.x)+this.epsilon); const ad_lr_y=this.lr/(Math.sqrt(this.Eg.y)+this.epsilon); return new THREE.Vector2(pos.x-ad_lr_x*grad.x, pos.y-ad_lr_y*grad.y); } reset() { this.Eg.set(0,0); } }
        class Adam { constructor(lr, beta1=0.9, beta2=0.999, epsilon=1e-8) { this.lr=lr; this.beta1=beta1; this.beta2=beta2; this.epsilon=epsilon; this.m=new THREE.Vector2(0,0); this.v=new THREE.Vector2(0,0); this.t=0; } step(pos, grad) { this.t++; this.m.x=this.beta1*this.m.x+(1-this.beta1)*grad.x; this.m.y=this.beta1*this.m.y+(1-this.beta1)*grad.y; this.v.x=this.beta2*this.v.x+(1-this.beta2)*(grad.x**2); this.v.y=this.beta2*this.v.y+(1-this.beta2)*(grad.y**2); const m_h_x=this.m.x/(1-this.beta1**this.t); const m_h_y=this.m.y/(1-this.beta1**this.t); const v_h_x=this.v.x/(1-this.beta2**this.t); const v_h_y=this.v.y/(1-this.beta2**this.t); return new THREE.Vector2(pos.x-(this.lr*m_h_x)/(Math.sqrt(v_h_x)+this.epsilon), pos.y-(this.lr*m_h_y)/(Math.sqrt(v_h_y)+this.epsilon)); } reset() { this.m.set(0,0); this.v.set(0,0); this.t=0; } }
        
        const params = {
            landscape: 'ðŸ”´ Rosenbrock', optimizer: 'Adam', learningRate: 0.1, 
            start_x: 0.0, start_z: 0.0, running: false, speed: 5, showGradient: false,
            colorScheme: 'Cyber Purple',
            followBall: false, landscapeScale: 50.0, gridResolution: 400,
            randomSpawn: () => {
                const halfScale = params.landscapeScale / 2;
                params.start_x = Math.random() * params.landscapeScale - halfScale;
                params.start_z = Math.random() * params.landscapeScale - halfScale;
                resetSimulation(true); // Pass true to focus camera

                if (!params.running) {
                    params.running = true;
                    gui.controllers.find(c => c.property === 'startStop').name('Stop');
                }
            },
            toggleGradient: () => { params.showGradient = !params.showGradient; document.getElementById('gradient-display').style.display = params.showGradient ? 'block' : 'none'; updateOptimizerPosition(); },
            reset: () => resetSimulation(false),
            startStop: () => { params.running = !params.running; gui.controllers.find(c => c.property === 'startStop').name(params.running ? 'Stop' : 'Start'); }
        };

        let currentOptimizer, currentLandscape, currentPosition2D;
        const pathPoints = [];
        let frameCount = 0;
        
        const gui = new GUI();
        gui.title("Controls");
        gui.add(params, 'landscape', Object.keys(landscapes)).name('Landscape').onChange(() => resetSimulation(false));
        gui.add(params, 'optimizer', ['GradientDescent', 'Momentum', 'NAG', 'Adagrad', 'RMSprop', 'Adam']).name('Optimizer').onChange(() => resetSimulation(false));
        gui.add(params, 'learningRate', 0.0001, 1.0, 0.0001).name('Learning Rate').onChange(v => {if(currentOptimizer) currentOptimizer.lr = v});
        gui.add(params, 'speed', 1, 10, 1).name('Animation Speed');
        gui.add(params, 'toggleGradient').name('Show/Hide Gradient');
        gui.add(params, 'randomSpawn').name('âœ¨ Random Spawn');
        gui.add(params, 'reset').name('Reset');
        gui.add(params, 'startStop').name('Start');

        const vizFolder = gui.addFolder('âš™ï¸ Visualisation Options');
        vizFolder.add(params, 'followBall').name('Follow Ball');
        vizFolder.add(params, 'landscapeScale', 10, 200, 5).name('Landscape Scale').onChange(() => resetSimulation(false));
        vizFolder.add(params, 'gridResolution', 100, 10000, 100).name('Grid Resolution').onChange(() => resetSimulation(false));
        vizFolder.add(params, 'colorScheme', Object.keys(colorSchemes)).name('Color Scheme').onChange(applyColorScheme);

        function applyColorScheme(schemeName) { const scheme = colorSchemes[schemeName]; if (!scheme) return; for (const [key, value] of Object.entries(scheme.css)) { document.documentElement.style.setProperty(key, value); } if (surfaceMesh) { surfaceMesh.material.color.set(scheme.wireframe); } }
        function createSurface() { if (surfaceMesh) scene.remove(surfaceMesh); const range = params.landscapeScale; const segments = params.gridResolution; const geometry = new THREE.PlaneGeometry(range, range, segments, segments); const landscapeFunc = landscapes[params.landscape].func; for (let i = 0; i < geometry.attributes.position.count; i++) { const x = geometry.attributes.position.getX(i); const z = geometry.attributes.position.getY(i); geometry.attributes.position.setZ(i, landscapeFunc(x, z)); } geometry.computeVertexNormals(); const material = new THREE.MeshStandardMaterial({ color: colorSchemes[params.colorScheme].wireframe, wireframe: true, transparent: true, opacity: 0.4 }); surfaceMesh = new THREE.Mesh(geometry, material); surfaceMesh.rotation.x = -Math.PI / 2; scene.add(surfaceMesh); }
        function createOptimizerSphere() { if (optimizerSphere) scene.remove(optimizerSphere); const geometry = new THREE.SphereGeometry(params.landscapeScale/100, 16, 16); const material = new THREE.MeshBasicMaterial({ color: 0xffeb3b }); optimizerSphere = new THREE.Mesh(geometry, material); scene.add(optimizerSphere); }
        function createPathLine() { if (pathLine) scene.remove(pathLine); const material = new THREE.LineBasicMaterial({ color: 0xffeb3b }); const geometry = new THREE.BufferGeometry().setFromPoints(pathPoints); pathLine = new THREE.Line(geometry, material); scene.add(pathLine); }
        function createTangentLine() { if(tangentLine) scene.remove(tangentLine); const material = new THREE.LineBasicMaterial({ color: 0xf44336, linewidth: 2 }); const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]); tangentLine = new THREE.Line(geometry, material); scene.add(tangentLine); }
        function updateKatex() { const formula = landscapes[params.landscape].formula; katex.render(formula, document.getElementById('katex-formula'), { throwOnError: false, displayMode: true }); }
        
        function resetSimulation(focusCamera = false) {
            if (params.running) { params.running = false; gui.controllers.find(c => c.property === 'startStop').name('Start'); }
            createSurface(); updateKatex();
            switch (params.optimizer) { case 'Momentum': currentOptimizer = new Momentum(params.learningRate); break; case 'NAG': currentOptimizer = new NAG(params.learningRate); break; case 'Adagrad': currentOptimizer = new Adagrad(params.learningRate); break; case 'RMSprop': currentOptimizer = new RMSprop(params.learningRate); break; case 'Adam': currentOptimizer = new Adam(params.learningRate); break; default: currentOptimizer = new GradientDescent(params.learningRate); }
            if (currentOptimizer.reset) currentOptimizer.reset();
            currentPosition2D = new THREE.Vector2(params.start_x, params.start_z);
            currentLandscape = landscapes[params.landscape];
            pathPoints.length = 0;
            const startY = currentLandscape.func(currentPosition2D.x, currentPosition2D.y);
            pathPoints.push(new THREE.Vector3(currentPosition2D.x, startY, currentPosition2D.y));
            if(!optimizerSphere) createOptimizerSphere(); 
            if(!pathLine) createPathLine(); 
            if(!tangentLine) createTangentLine();
            updateOptimizerPosition();

            if (focusCamera) {
                const y = landscapes[params.landscape].func(params.start_x, params.start_z);
                const camDist = params.landscapeScale * 0.2;
                const targetPos = new THREE.Vector3(params.start_x, y, params.start_z);
                const cameraPos = new THREE.Vector3(params.start_x + camDist, y + camDist, params.start_z + camDist);
                camera.position.copy(cameraPos);
                controls.target.copy(targetPos);
            }
        }

        function updateOptimizerPosition() { const y = currentLandscape.func(currentPosition2D.x, currentPosition2D.y); optimizerSphere.position.set(currentPosition2D.x, y, currentPosition2D.y); const grad = currentLandscape.gradient(currentPosition2D.x, currentPosition2D.y); const p1 = new THREE.Vector3(currentPosition2D.x, y, currentPosition2D.y); const p2 = new THREE.Vector3(p1.x - grad.x, y, p1.z - grad.y); const y_at_grad_end = currentLandscape.func(p2.x, p2.z); p2.y = y_at_grad_end; tangentLine.geometry.setFromPoints([p1, p2]); tangentLine.geometry.attributes.position.needsUpdate = true; if (params.showGradient) { const gradString = `\\nabla f = \\begin{bmatrix} \\frac{\\partial f}{\\partial x} \\\\ \\frac{\\partial f}{\\partial z} \\end{bmatrix} = \\begin{bmatrix} ${grad.x.toFixed(3)} \\\\ ${grad.y.toFixed(3)} \\end{bmatrix}`; katex.render(gradString, document.getElementById('gradient-display'), { throwOnError: false, displayMode: true }); } }
        function step() { const grad = currentLandscape.gradient(currentPosition2D.x, currentPosition2D.y); currentPosition2D = currentOptimizer.step(currentPosition2D, grad); const newY = currentLandscape.func(currentPosition2D.x, currentPosition2D.y); const newPoint = new THREE.Vector3(currentPosition2D.x, newY, currentPosition2D.y); pathPoints.push(newPoint); pathLine.geometry.setFromPoints(pathPoints); pathLine.geometry.attributes.position.needsUpdate = true; updateOptimizerPosition(); }
        
        function animate() { 
            requestAnimationFrame(animate); 
            if (params.followBall && optimizerSphere) {
                if(!controls.autoRotate) { // Store the initial offset when we start following
                    cameraOffset.copy(camera.position).sub(controls.target);
                }
                controls.target.lerp(optimizerSphere.position, 0.05);
                camera.position.copy(controls.target).add(cameraOffset);
            }
            controls.update(); 
            if (params.running && (frameCount % (11 - params.speed) === 0)) { step(); } 
            frameCount++; 
            renderer.render(scene, camera); 
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function onCanvasClick(event) { event.preventDefault(); mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObject(surfaceMesh); if (intersects.length > 0) { const point = intersects[0].point; params.start_x = point.x; params.start_z = point.z; resetSimulation(false); } }

        window.addEventListener('resize', onWindowResize);
        container.addEventListener('mousedown', onCanvasClick);

        applyColorScheme(params.colorScheme);
        resetSimulation();
        animate();
    </script>
</body>
</html>

