<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Double Pendulum Map</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #030712; /* bg-gray-950 */
            color: #e5e7eb;
        }
        .ui-panel {
            position: absolute;
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(8px);
            padding: 1.25rem;
            border: 1px solid rgba(55, 65, 81, 0.7);
            transition: all 0.5s ease-in-out;
            z-index: 10;
        }
        #info-panel {
            top: 80px;
            left: 20px;
            max-width: 420px;
            cursor: pointer;
            overflow: hidden;
            border-radius: 12px;
            max-height: 58px; /* Collapsed */
        }
        #info-panel.expanded {
            max-height: 90vh;
            cursor: default;
            overflow-y: auto;
            z-index: 11;
        }
        #info-header { display: flex; justify-content: space-between; align-items: center; }
        #toggle-icon { transition: transform 0.3s ease-in-out; }
        #info-panel.expanded #toggle-icon { transform: rotate(180deg); }
        .formula-placeholder {
            font-family: 'monospace', serif;
            background-color: #1f2937;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: left;
            font-size: 0.9rem;
            margin-top: 1rem;
            color: #d1d5db;
            border: 1px solid #374151;
            white-space: pre-wrap;
            word-break: break-all;
        }
        #controls-panel {
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            border-radius: 12px 12px 0 0;
            padding: 1rem 2rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
        }
        header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background-color: rgba(3, 7, 18, 0.5);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(55, 65, 81, 0.7);
        }
        .menu-button, .preset-button, .toggle-button {
            background-color: rgba(55, 65, 81, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(75, 85, 99, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            font-weight: 500;
            font-size: 0.875rem;
        }
        .menu-button:hover, .preset-button:hover, .toggle-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px);
        }
        .menu-button.active, .preset-button.active, .toggle-button.active {
            background-color: #4f46e5;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: #4b5563;
            border-radius: 2px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #818cf8;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="number"] {
            -moz-appearance: textfield;
            background-color: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 6px;
            color: white;
            text-align: right;
            padding: 0.25rem 0.5rem;
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none; margin: 0;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .control-group label {
            width: 200px;
            text-align: center;
        }
        .hidden { display: none !important; }
        canvas { display: block; }
        .button-group { display: flex; gap: 0.5rem; }

        #settings-button, #fullscreen-button {
            position: absolute;
            background-color: rgba(55, 65, 81, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(75, 85, 99, 0.9);
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }
        #settings-button {
            top: 80px;
            right: 20px;
            z-index: 11;
        }
        #fullscreen-button {
            bottom: 120px;
            right: 20px;
            z-index: 11;
        }
        #settings-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px) rotate(45deg);
        }
        #fullscreen-button:hover {
             background-color: #4338ca;
            transform: translateY(-2px) scale(1.1);
        }
        #settings-panel {
            top: 80px;
            right: 0;
            width: 300px;
            max-width: 90vw;
            border-radius: 12px 0 0 12px;
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            padding-right: 2rem;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            z-index: 12;
        }
        #settings-panel.open {
            transform: translateX(0);
        }
        #close-settings {
            font-size: 2.5rem;
            line-height: 1;
            padding: 0;
            background: none;
            border: none;
            cursor: pointer;
        }
         body.fullscreen-active header,
        body.fullscreen-active #info-panel {
            display: none !important;
        }
        body.fullscreen-active #controls-panel,
        body.fullscreen-active #settings-button,
        body.fullscreen-active #fullscreen-button {
            opacity: 0;
            pointer-events: none;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }
        .chart-container {
            background-color: #111827;
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
        }

        @media (max-width: 768px) {
            header { padding: 0.75rem 1rem; }
            header h1 { font-size: 1.125rem; }
            #info-panel { top: 70px; left: 10px; right: 10px; max-width: none; width: auto; }
            #settings-button { top: 70px; right: 10px; }
            #fullscreen-button { bottom: 100px; right: 10px; }
            #settings-panel { top: 70px; width: 280px; max-height: calc(100vh - 80px);}
            #controls-panel { padding: 0.75rem; gap: 0.75rem; flex-direction: column; }
            .control-group { width: 100%; }
             .control-group label { width: 100%; }
            input[type="range"]::-webkit-slider-thumb { width: 24px; height: 24px; }
        }
    </style>
</head>
<body>
    <header>
        <h1 class="text-xl font-bold text-gray-200 tracking-wider opacity-90">The Double Pendulum Map</h1>
    </header>

    <div id="info-panel" class="ui-panel">
        <div id="info-header">
            <h2 id="info-title" class="text-xl font-bold text-indigo-400">About This Simulation</h2>
            <div id="toggle-icon" class="text-indigo-400">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
            </div>
        </div>
        <div id="info-content" class="pt-4 space-y-3">
            <p id="info-description" class="text-gray-300"></p>
            <div id="pendulum-preview-container" class="hidden mt-4">
                 <h3 class="font-bold text-lg text-indigo-400">Pendulum Presets</h3>
                <select id="preset-select" class="w-full bg-gray-700 border border-gray-600 rounded-md p-2 mt-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    <option value="custom">Custom</option>
                    <option value="heart">The Heart</option>
                    <option value="pretzel">The Pretzel</option>
                    <option value="shoelace">The Shoelace</option>
                </select>
                <div class="flex justify-between items-center mt-4">
                    <h3 class="font-bold text-lg text-indigo-400">Live Pendulum Preview</h3>
                    <button id="live-preview-btn" class="toggle-button text-sm py-1 px-3">Live</button>
                </div>
                <div class="chart-container p-2 flex justify-center items-center">
                    <canvas id="pendulum-preview-canvas" width="350" height="350" class="bg-gray-800 rounded-md"></canvas>
                </div>
            </div>
             <div id="info-placeholder" class="formula-placeholder">Î¸1 âˆˆ [0.00, 0.00]
Î¸2 âˆˆ [0.00, 0.00]</div>

        </div>
    </div>

    <div id="controls-panel" class="ui-panel"></div>

    <button id="fullscreen-button" title="Toggle Fullscreen">
        <svg id="fullscreen-enter-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
        <svg id="fullscreen-exit-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
    </button>

    <button id="settings-button" title="Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0 2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
    </button>

    <div id="settings-panel" class="ui-panel hidden">
        <div class="flex justify-between items-center mb-6 sticky top-0 bg-inherit z-10 py-2">
            <h3 class="text-xl font-bold text-gray-200">Settings</h3>
            <button id="close-settings" class="text-gray-400 hover:text-white transition-colors">&times;</button>
        </div>
        <div class="space-y-6">
             <div class="control-group text-left w-full">
                <label for="resolution-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Resolution:</span>
                    <span id="resolution-value">512x512</span>
                </label>
                <input id="resolution-slider" type="range" min="128" max="2048" step="128" value="512" class="w-full">
                <span class="text-xs text-gray-500 self-start w-full">High values may be unstable on some devices.</span>
            </div>
            <hr class="border-gray-600">
             <div class="control-group text-left w-full">
                <label for="transparency-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>3D Slice Transparency:</span>
                    <span id="transparency-value">1.0x</span>
                </label>
                <input id="transparency-slider" type="range" min="0.1" max="5" step="0.1" value="1.0" class="w-full">
            </div>
             <div class="control-group text-left w-full">
                <label for="marker-size-slider" class="text-sm font-medium self-start w-full flex justify-between">
                    <span>Marker Size:</span>
                     <span id="marker-size-value">0.10</span>
                </label>
                <input id="marker-size-slider" type="range" min="0.05" max="0.5" step="0.01" value="0.1" class="w-full">
            </div>
             <div class="control-group text-left w-full">
                 <label class="text-sm font-medium self-start w-full flex justify-between items-center">
                    <span>Gravity Strength:</span> <input id="gravity-input" type="number" value="9.8" step="0.1" class="w-24">
                </label>
             </div>
            <hr class="border-gray-600">
            <h4 class="text-lg font-bold text-gray-300 text-left w-full">Map View Controls</h4>
            <div class="control-group text-left w-full">
                <label class="text-sm font-medium self-start w-full flex justify-between items-center">
                    <span>Center Î¸1 (rad):</span> <input id="view-center-t1" type="number" value="0.0000" step="0.1" class="w-24">
                </label>
            </div>
             <div class="control-group text-left w-full">
                <label class="text-sm font-medium self-start w-full flex justify-between items-center">
                    <span>Center Î¸2 (rad):</span> <input id="view-center-t2" type="number" value="0.0000" step="0.1" class="w-24">
                </label>
            </div>
            <div class="control-group text-left w-full">
                <label class="text-sm font-medium self-start w-full flex justify-between items-center">
                    <span>Zoom Level:</span> <input id="view-zoom" type="number" value="1.0000" step="0.1" min="1" class="w-24">
                </label>
            </div>
            <button id="apply-view-btn" class="toggle-button w-full">Apply View</button>
            <hr class="border-gray-600">
            <h4 class="text-lg font-bold text-gray-300 text-left w-full">Pendulum Preview Controls</h4>
            <div class="control-group text-left w-full">
                <label class="text-sm font-medium self-start w-full flex justify-between items-center">
                    <span>Trace Length:</span> <input id="preview-trace-length" type="number" value="200" step="10" min="0" class="w-24">
                </label>
            </div>
            <div class="control-group text-left w-full">
                <label class="text-sm font-medium self-start w-full flex justify-between items-center">
                    <span>Initial Î¸1:</span> <input id="preview-theta1" type="number" value="0" step="0.1" class="w-24">
                </label>
            </div>
            <div class="control-group text-left w-full">
                 <label class="text-sm font-medium self-start w-full flex justify-between items-center">
                    <span>Initial Î¸2:</span> <input id="preview-theta2" type="number" value="0" step="0.1" class="w-24">
                </label>
            </div>
            <div class="control-group text-left w-full">
                 <label class="text-sm font-medium self-start w-full flex justify-between items-center">
                    <span>Initial Ï‰1:</span> <input id="preview-omega1" type="number" value="0" step="0.1" class="w-24">
                </label>
            </div>
            <div class="control-group text-left w-full">
                 <label class="text-sm font-medium self-start w-full flex justify-between items-center">
                    <span>Initial Ï‰2:</span> <input id="preview-omega2" type="number" value="0" step="0.1" class="w-24">
                </label>
            </div>
            <button id="start-preview-btn" class="toggle-button w-full active">Start/Reset Preview</button>
        </div>
    </div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // --- Core Three.js Components ---
    let scene, camera, renderer, controls, clock;
    let activeSceneObjects = new THREE.Group();
    let currentUpdate = () => {};
    let currentCleanup = () => {};

    // --- Simulation State ---
    let SIM_RESOLUTION = 512;
    const NUM_SLICES = 32;
    const atlasGrid = new THREE.Vector2(8, 4); // 8x4 grid for 32 slices
    let timeStep = 0.016;
    let initialOmega1 = 0.0;
    let initialOmega2 = 0.0;
    let gravity = 9.8;
    let needsRestart = true;
    let isPaused = false;
    let zoomState = { x: 0, y: 0, scale: new THREE.Vector2(1.0, 1.0) };
    let isDragging = false;
    let dragStart = new THREE.Vector2();

    // --- View State ---
    let viewMode = '2D_SLICE'; // '2D_SLICE' or '3D_VOLUME'
    let threeDAxis = 'OMEGA1'; // 'OMEGA1' or 'OMEGA2'
    let slicePosition = 0.5; // Normalized 0-1

    // --- GPGPU Components ---
    let state_read_atlas, state_write_atlas; // Atlas render targets
    let updateMaterial, drawMaterial, instancedDrawMaterial;
    let mapMesh, instancedMapMesh;

    // --- Interactivity ---
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let markerMesh;
    let isMarkerPlaced = false;
    
    // --- 2D Pendulum Preview ---
    let previewCanvasCtx;
    let previewPendulumState = { t1: 0, t2: 0, w1: 0, w2: 0 };
    let isPreviewRunning = false;
    let isLivePreviewActive = false;
    let tracePoints = [];
    let traceLength = 200;

    const scenes = {
        double_pendulum: {
            title: 'The Double Pendulum Map',
            description: `This visualization computes and visualizes the angle of the first (x-axis) and second (y-axis) arms of all compound double pendulums starting with the specified velocities. This amounts to a two-dimensional slice of the four-dimensional phase space. Adjust the initial velocities and zoom in on regions below and observe the pretty colors! ðŸŒˆ`,
            init: initDoublePendulum,
        },
    };

    // --- Main Initialization ---
    function init() {
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 0, 4);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(5, 5, 5);
        scene.add(dirLight);

        scene.add(activeSceneObjects);
        
        setupInfoPanel();
        setupFullscreen();
        setupSettingsPanel();
        
        switchScene('double_pendulum');

        window.addEventListener('resize', onWindowResize, false);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('dblclick', onDoubleClick);
        renderer.setAnimationLoop(animate);
    }
    
    function switchScene(key) {
        if(currentCleanup) currentCleanup();
        
        const sceneData = scenes[key];
        document.getElementById('info-title').textContent = sceneData.title;
        document.getElementById('info-description').textContent = sceneData.description;
        
        const result = sceneData.init();
        currentUpdate = result.update;
        currentCleanup = result.cleanup;
    }

    // --- Scene Setup ---
    function initDoublePendulum() {
        // GPGPU setup for atlas texture
        state_read_atlas = new THREE.WebGLRenderTarget(SIM_RESOLUTION * atlasGrid.x, SIM_RESOLUTION * atlasGrid.y, {
            type: THREE.FloatType, minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter,
        });
        state_write_atlas = state_read_atlas.clone();

        const gpgpuVertexShader = getGPGPUVertexShader();
        const sceneVertexShader = getSceneVertexShader();
        const initializeShader = getInitializeShader();
        const updateShader = getUpdateShader();
        const drawShader = getDrawShader();
        const instancedDrawShader = getInstancedDrawShader();

        updateMaterial = new THREE.ShaderMaterial({
            uniforms: {
                textureState: { value: state_read_atlas.texture },
                timeStep: { value: timeStep },
                uGravity: { value: gravity },
            },
            vertexShader: gpgpuVertexShader,
            fragmentShader: updateShader,
            glslVersion: THREE.GLSL3
        });

        // For 2D Slice view
        drawMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uAtlasTexture: { value: state_read_atlas.texture },
                uSliceIndex: { value: 0.0 },
                uAtlasGrid: { value: atlasGrid },
            },
            vertexShader: sceneVertexShader,
            fragmentShader: drawShader,
            glslVersion: THREE.GLSL3
        });

        const mapGeometry = new THREE.PlaneGeometry(5, 5);
        mapMesh = new THREE.Mesh(mapGeometry, drawMaterial);
        activeSceneObjects.add(mapMesh);

        // For 3D Volume view
        instancedDrawMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uAtlasTexture: { value: state_read_atlas.texture },
                uNumSlices: { value: NUM_SLICES },
                uTransparency: { value: 1.0 },
                uAtlasGrid: { value: atlasGrid },
            },
            vertexShader: getInstancedVertexShader(),
            fragmentShader: instancedDrawShader,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide,
            glslVersion: THREE.GLSL3
        });
        
        const instancedGeometry = new THREE.PlaneGeometry(5, 5);
        instancedMapMesh = new THREE.InstancedMesh(instancedGeometry, instancedDrawMaterial, NUM_SLICES);
        activeSceneObjects.add(instancedMapMesh);

        // Marker mesh
        const markerGeometry = new THREE.CircleGeometry(0.05, 32);
        const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00, side: THREE.DoubleSide });
        markerMesh = new THREE.Mesh(markerGeometry, markerMaterial);
        markerMesh.visible = false;
        activeSceneObjects.add(markerMesh);
        
        const gpgpuScene = new THREE.Scene();
        const gpgpuCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const gpgpuQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null);
        gpgpuScene.add(gpgpuQuad);
        
        const gpgpu = {
            run: (material) => {
                gpgpuQuad.material = material;
                renderer.setRenderTarget(state_write_atlas);
                renderer.render(gpgpuScene, gpgpuCamera);
                renderer.setRenderTarget(null);
                [state_read_atlas, state_write_atlas] = [state_write_atlas, state_read_atlas]; // Swap
            }
        };

        const initMaterial = new THREE.ShaderMaterial({
            uniforms: {
                omega1: { value: initialOmega1 },
                omega2: { value: initialOmega2 },
                zoomCenter: { value: new THREE.Vector2(zoomState.x, zoomState.y) },
                zoomScale: { value: zoomState.scale },
                uNumSlices: { value: NUM_SLICES },
                uThreeDAxis: { value: threeDAxis === 'OMEGA1' ? 1.0 : 0.0 },
                uAtlasGrid: { value: atlasGrid },
            },
            vertexShader: gpgpuVertexShader,
            fragmentShader: initializeShader,
            glslVersion: THREE.GLSL3
        });
        
        createControls();
        toggleViewMode(); // Set initial visibility

        function update(delta) {
            if (needsRestart) {
                initMaterial.uniforms.omega1.value = initialOmega1;
                initMaterial.uniforms.omega2.value = initialOmega2;
                initMaterial.uniforms.zoomCenter.value.set(zoomState.x, zoomState.y);
                initMaterial.uniforms.zoomScale.value = zoomState.scale;
                initMaterial.uniforms.uThreeDAxis.value = threeDAxis === 'OMEGA1' ? 1.0 : 0.0;
                gpgpu.run(initMaterial);
                needsRestart = false;
            }

            if (!isPaused) {
                updateMaterial.uniforms.textureState.value = state_read_atlas.texture;
                updateMaterial.uniforms.timeStep.value = timeStep;
                gpgpu.run(updateMaterial);
                drawMaterial.uniforms.uAtlasTexture.value = state_read_atlas.texture;
                instancedDrawMaterial.uniforms.uAtlasTexture.value = state_read_atlas.texture;
            }
        }

        function cleanup() {
             activeSceneObjects.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                     if (Array.isArray(object.material)) {
                        object.material.forEach(m => m.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
            while(activeSceneObjects.children.length > 0){
                activeSceneObjects.remove(activeSceneObjects.children[0]);
            }
            if (state_read_atlas) state_read_atlas.dispose();
            if (state_write_atlas) state_write_atlas.dispose();
        }

        return { update, cleanup };
    }

    // --- UI & Controls ---
    function createControls() {
        const controlsDiv = document.getElementById('controls-panel');
        controlsDiv.innerHTML = `
            <div class="control-group">
                <label class="text-sm font-medium">View Mode</label>
                <button id="view-mode-btn" class="toggle-button">2D Slice</button>
            </div>
            <div class="control-group">
                <label class="text-sm font-medium">Variable Axis (Z)</label>
                <div class="button-group">
                    <button id="3d-axis-w1" class="toggle-button active">Ï‰1</button>
                    <button id="3d-axis-w2" class="toggle-button">Ï‰2</button>
                </div>
            </div>
            <div id="2d-slice-controls" class="control-group">
                <label for="slice-slider" class="text-sm font-medium">Slice Position (<span id="slice-axis-label">Ï‰1</span>): <span id="slice-value">0.00</span></label>
                <input id="slice-slider" type="range" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="control-group">
                <label for="fixed-omega-input" class="text-sm font-medium">Fixed Value (<span id="fixed-axis-label">Ï‰2</span>): <span id="fixed-omega-value">0.00</span></label>
                <input id="fixed-omega-input" type="range" min="-200.0" max="200.0" step="0.05" value="0.0">
            </div>
            <div class="control-group">
                <label for="dt-slider" class="text-sm font-medium">Time Step: <span id="dt-value">0.016</span></label>
                <input id="dt-slider" type="range" min="0.001" max="0.35" step="0.001" value="0.016">
            </div>
            <button id="restart-btn" class="toggle-button active">Restart</button>
        `;
        
        document.getElementById('view-mode-btn').addEventListener('click', () => {
             viewMode = viewMode === '2D_SLICE' ? '3D_VOLUME' : '2D_SLICE';
             toggleViewMode();
        });

        const axisW1Btn = document.getElementById('3d-axis-w1');
        const axisW2Btn = document.getElementById('3d-axis-w2');
        axisW1Btn.addEventListener('click', () => {
            threeDAxis = 'OMEGA1';
            axisW1Btn.classList.add('active');
            axisW2Btn.classList.remove('active');
            updateLabels();
            needsRestart = true;
        });
        axisW2Btn.addEventListener('click', () => {
            threeDAxis = 'OMEGA2';
            axisW1Btn.classList.remove('active');
            axisW2Btn.classList.add('active');
            updateLabels();
            needsRestart = true;
        });
        
        const sliceSlider = document.getElementById('slice-slider');
        const sliceValue = document.getElementById('slice-value');
        sliceSlider.addEventListener('input', (e) => {
            slicePosition = parseFloat(e.target.value);
            const omegaRange = 4.0;
            const currentOmega = (slicePosition - 0.5) * omegaRange;
            sliceValue.textContent = currentOmega.toFixed(2);
            drawMaterial.uniforms.uSliceIndex.value = Math.floor(slicePosition * (NUM_SLICES - 1));
        });

        const fixedOmegaSlider = document.getElementById('fixed-omega-input');
        const fixedOmegaValue = document.getElementById('fixed-omega-value');
        fixedOmegaSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            fixedOmegaValue.textContent = value.toFixed(2);
            if (threeDAxis === 'OMEGA1') {
                initialOmega2 = value;
            } else {
                initialOmega1 = value;
            }
            needsRestart = true;
        });

        const dtSlider = document.getElementById('dt-slider');
        const dtValue = document.getElementById('dt-value');
        dtSlider.addEventListener('input', (e) => {
            timeStep = parseFloat(e.target.value);
            dtValue.textContent = timeStep.toFixed(3);
        });

        document.getElementById('restart-btn').addEventListener('click', () => { needsRestart = true; });
        
        function updateLabels() {
            const variableAxis = threeDAxis === 'OMEGA1' ? 'Ï‰1' : 'Ï‰2';
            const fixedAxis = threeDAxis === 'OMEGA1' ? 'Ï‰2' : 'Ï‰1';
            document.getElementById('slice-axis-label').textContent = variableAxis;
            document.getElementById('fixed-axis-label').textContent = fixedAxis;
        }

        updateLabels();
        sliceSlider.dispatchEvent(new Event('input'));
        fixedOmegaSlider.dispatchEvent(new Event('input'));
    }
    
    function toggleViewMode() {
        const is2D = viewMode === '2D_SLICE';
        document.getElementById('view-mode-btn').textContent = is2D ? '2D Slice' : '3D Volume';
        document.getElementById('2d-slice-controls').classList.toggle('hidden', !is2D);
        mapMesh.visible = is2D;
        if(markerMesh) markerMesh.visible = is2D && isMarkerPlaced;
        instancedMapMesh.visible = !is2D;
        controls.enableRotate = !is2D;
        if(is2D) {
            camera.position.set(0,0,4);
            controls.target.set(0,0,0);
        }
    }
    
    function setupInfoPanel() {
        const panel = document.getElementById('info-panel');
        const previewContainer = document.getElementById('pendulum-preview-container');
        panel.addEventListener('click', (e) => {
            if (e.target.closest('canvas') || e.target.closest('a') || e.target.closest('select') || e.target.closest('button')) return;
            panel.classList.toggle('expanded');
            previewContainer.classList.toggle('hidden', !panel.classList.contains('expanded'));
        });
        const canvas = document.getElementById('pendulum-preview-canvas');
        previewCanvasCtx = canvas.getContext('2d');

        const presets = {
            heart: { t1: 2.453, t2: -2.7727 },
            pretzel: { t1: 2.49, t2: 0.25 },
            shoelace: { t1: 2.658, t2: -2.19 }
        };

        const presetSelect = document.getElementById('preset-select');
        presetSelect.addEventListener('change', (e) => {
            isLivePreviewActive = false; // Turn off live preview when selecting a preset
            document.getElementById('live-preview-btn').classList.remove('active');

            if (e.target.value === 'custom') {
                const infoDiv = document.getElementById('info-placeholder');
                if (infoDiv.textContent.startsWith('ðŸ“Œ')) {
                    try {
                        const parts = infoDiv.textContent.replace('ðŸ“Œ', '').split(',');
                        const t1 = parseFloat(parts[0].split(':')[1].trim());
                        const t2 = parseFloat(parts[1].split(':')[1].trim());
                        document.getElementById('preview-theta1').value = t1.toFixed(4);
                        document.getElementById('preview-theta2').value = t2.toFixed(4);
                    } catch (err) {
                        console.error("Could not parse pinned coordinates.", err);
                    }
                }
                document.getElementById('start-preview-btn').click();
                return;
            }
            const selectedPreset = presets[e.target.value];
            if (selectedPreset) {
                document.getElementById('preview-theta1').value = selectedPreset.t1;
                document.getElementById('preview-theta2').value = selectedPreset.t2;
                document.getElementById('preview-omega1').value = 0;
                document.getElementById('preview-omega2').value = 0;
                document.getElementById('start-preview-btn').click();
            }
        });

        // Live Preview Button
        const livePreviewBtn = document.getElementById('live-preview-btn');
        livePreviewBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent info panel from toggling
            isLivePreviewActive = !isLivePreviewActive;
            livePreviewBtn.classList.toggle('active', isLivePreviewActive);
            if (!isLivePreviewActive) {
                isPreviewRunning = false;
            }
        });


        // Initialize with the heart preset
        presetSelect.value = 'heart';
        presetSelect.dispatchEvent(new Event('change'));
    }

    function setupFullscreen() {
        const fullscreenButton = document.getElementById('fullscreen-button');
        const enterIcon = document.getElementById('fullscreen-enter-icon');
        const exitIcon = document.getElementById('fullscreen-exit-icon');
        if (!document.fullscreenEnabled) { fullscreenButton.style.display = 'none'; return; }
        fullscreenButton.addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        });
        document.addEventListener('fullscreenchange', () => {
            const isFullscreen = !!document.fullscreenElement;
            enterIcon.classList.toggle('hidden', isFullscreen);
            exitIcon.classList.toggle('hidden', !isFullscreen);
            document.body.classList.toggle('fullscreen-active', isFullscreen);
            setTimeout(onWindowResize, 100);
        });
    }

    function updateViewInputs() {
        if (!document.getElementById('view-center-t1')) return;
        const PI2 = Math.PI * 2.0;
        document.getElementById('view-center-t1').value = (zoomState.x * PI2).toFixed(4);
        document.getElementById('view-center-t2').value = (zoomState.y * PI2).toFixed(4);
        document.getElementById('view-zoom').value = zoomState.scale.x.toFixed(4);
    }

    function setupSettingsPanel() {
        const settingsPanel = document.getElementById('settings-panel');
        const settingsButton = document.getElementById('settings-button');
        const closeSettingsButton = document.getElementById('close-settings');
        
        function toggleSettingsPanel() {
            if (settingsPanel.classList.contains('open')) settingsPanel.classList.remove('open');
            else { settingsPanel.classList.remove('hidden'); requestAnimationFrame(() => settingsPanel.classList.add('open')); }
        }
        settingsButton.addEventListener('click', toggleSettingsPanel);
        closeSettingsButton.addEventListener('click', () => settingsPanel.classList.remove('open'));
        settingsPanel.addEventListener('transitionend', (e) => {
            if (e.propertyName === 'transform' && !settingsPanel.classList.contains('open')) settingsPanel.classList.add('hidden');
        });

        const resolutionSlider = document.getElementById('resolution-slider');
        const resolutionValue = document.getElementById('resolution-value');
        resolutionSlider.addEventListener('input', e => {
            resolutionValue.textContent = `${e.target.value}x${e.target.value}`;
        });
        resolutionSlider.addEventListener('change', e => {
            SIM_RESOLUTION = parseInt(e.target.value, 10);
            switchScene('double_pendulum');
            needsRestart = true;
        });

        const transparencySlider = document.getElementById('transparency-slider');
        const transparencyValue = document.getElementById('transparency-value');
        transparencySlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            if(instancedDrawMaterial) instancedDrawMaterial.uniforms.uTransparency.value = value;
            transparencyValue.textContent = `${value.toFixed(1)}x`;
        });
        
        const markerSizeSlider = document.getElementById('marker-size-slider');
        const markerSizeValue = document.getElementById('marker-size-value');
        markerSizeSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            if(markerMesh) {
                const scale = value / 0.05; // Base radius is 0.05
                markerMesh.scale.set(scale, scale, 1);
            }
            markerSizeValue.textContent = value.toFixed(2);
        });
        
        const gravityInput = document.getElementById('gravity-input');
        gravityInput.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            if(!isNaN(value)) {
                gravity = value;
                if(updateMaterial) updateMaterial.uniforms.uGravity.value = gravity;
                needsRestart = true;
            }
        });


        document.getElementById('apply-view-btn').addEventListener('click', () => {
            const PI2 = Math.PI * 2.0;
            const t1 = parseFloat(document.getElementById('view-center-t1').value);
            const t2 = parseFloat(document.getElementById('view-center-t2').value);
            const scale = parseFloat(document.getElementById('view-zoom').value);
            
            zoomState.x = t1 / PI2; 
            zoomState.y = t2 / PI2;
            zoomState.scale.set(scale, scale);
            needsRestart = true;
            updateViewInputs();
        });

        document.getElementById('start-preview-btn').addEventListener('click', () => {
            const t1 = parseFloat(document.getElementById('preview-theta1').value);
            const t2 = parseFloat(document.getElementById('preview-theta2').value);
            const w1 = parseFloat(document.getElementById('preview-omega1').value);
            const w2 = parseFloat(document.getElementById('preview-omega2').value);
            previewPendulumState = { t1, t2, w1, w2 };
            isPreviewRunning = true;
            tracePoints = []; // Clear trace on reset
        });

        const traceLengthInput = document.getElementById('preview-trace-length');
        traceLengthInput.addEventListener('input', (e) => {
            traceLength = parseInt(e.target.value, 10);
            if (traceLength < 0) traceLength = 0;
        });
    }

    // --- Interactivity ---

    function getMomentumFromControls() {
        const omegaRange = 4.0;
        const sliceOmega = (slicePosition - 0.5) * omegaRange;
        const fixedOmega = parseFloat(document.getElementById('fixed-omega-input').value);

        let w1, w2;
        if (threeDAxis === 'OMEGA1') {
            w1 = sliceOmega;
            w2 = fixedOmega;
        } else {
            w1 = fixedOmega;
            w2 = sliceOmega;
        }
        return { w1, w2 };
    }
    
    function getCoordsFromUV(uv) {
        const PI2 = Math.PI * 2.0;
        const fullRangeX = PI2 / zoomState.scale.x;
        const minTheta1 = (zoomState.x * PI2) - fullRangeX / 2.0;
        const theta1 = minTheta1 + uv.x * fullRangeX;

        const fullRangeY = PI2 / zoomState.scale.y;
        const minTheta2 = (zoomState.y * PI2) - fullRangeY / 2.0;
        const theta2 = minTheta2 + uv.y * fullRangeY;

        return { theta1, theta2 };
    }

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        const infoDiv = document.getElementById('info-placeholder');
        if (viewMode !== '2D_SLICE') {
             infoDiv.textContent = 'Hover disabled in 3D mode.';
             return;
        }

        if (isMarkerPlaced) {
            return; // Do not update text if a marker is placed
        }

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(mapMesh);

        if (intersects.length > 0) {
            const uv = intersects[0].uv;
            const { theta1, theta2 } = getCoordsFromUV(uv);
            
            infoDiv.textContent = `Î¸1: ${theta1.toFixed(4)}, Î¸2: ${theta2.toFixed(4)}`;

            if (isLivePreviewActive) {
                const { w1, w2 } = getMomentumFromControls();
                document.getElementById('preview-theta1').value = theta1.toFixed(4);
                document.getElementById('preview-theta2').value = theta2.toFixed(4);
                document.getElementById('preview-omega1').value = w1.toFixed(4);
                document.getElementById('preview-omega2').value = w2.toFixed(4);
                
                previewPendulumState = { t1: theta1, t2: theta2, w1, w2 };
                isPreviewRunning = true;
                tracePoints = [];
            }
        } else {
            // If mouse is off the map, show range
            const PI2 = Math.PI * 2.0;
            const fullRangeX = PI2 / zoomState.scale.x;
            const minTheta1 = (zoomState.x * PI2) - fullRangeX / 2.0;
            const maxTheta1 = minTheta1 + fullRangeX;
            const fullRangeY = PI2 / zoomState.scale.y;
            const minTheta2 = (zoomState.y * PI2) - fullRangeY / 2.0;
            const maxTheta2 = minTheta2 + fullRangeY;
            infoDiv.textContent = `Î¸1 âˆˆ [${minTheta1.toFixed(4)}, ${maxTheta1.toFixed(4)}]
Î¸2 âˆˆ [${minTheta2.toFixed(4)}, ${maxTheta2.toFixed(4)}]`;
        }
    }
    
    function onMouseDown(event) {
         if (event.button === 0) { isDragging = true; dragStart.set(event.clientX, event.clientY); }
    }
    
    function onMouseUp(event) {
        if (event.button === 0 && isDragging) {
            isDragging = false;
            const dragEnd = new THREE.Vector2(event.clientX, event.clientY);
            const dragDist = dragStart.distanceTo(dragEnd);

            if (dragDist > 5) { // DRAG (ZOOM)
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(mapMesh);
                if (intersects.length > 0) {
                    const uv = intersects[0].uv;
                    const zoomFactor = dragDist / Math.min(window.innerWidth, window.innerHeight);
                    zoomState.x += (uv.x - 0.5) / zoomState.scale.x;
                    zoomState.y += (uv.y - 0.5) / zoomState.scale.y;
                    const scaleFactor = (1.0 - Math.max(0, Math.min(0.9, zoomFactor * 2.0)));
                    zoomState.scale.multiplyScalar(1.0 / scaleFactor);
                    needsRestart = true;
                    updateViewInputs();
                }
            } else if (viewMode === '2D_SLICE') { // CLICK (PLACE/REMOVE MARKER)
                 const infoDiv = document.getElementById('info-placeholder');
                 raycaster.setFromCamera(mouse, camera);
                 const intersects = raycaster.intersectObject(mapMesh);

                 if (isMarkerPlaced) {
                    // Remove marker
                    markerMesh.visible = false;
                    isMarkerPlaced = false;
                    // Immediately update text to current hover/range
                    onMouseMove({clientX: event.clientX, clientY: event.clientY}); 
                 } else {
                    // Place marker
                    if (intersects.length > 0) {
                        isLivePreviewActive = false;
                        document.getElementById('live-preview-btn').classList.remove('active');

                        const uv = intersects[0].uv;
                        const point = intersects[0].point;
                        const { theta1, theta2 } = getCoordsFromUV(uv);
                        const { w1, w2 } = getMomentumFromControls();

                        markerMesh.position.set(point.x, point.y, 0.01);
                        markerMesh.visible = true;
                        isMarkerPlaced = true;

                        document.getElementById('preview-theta1').value = theta1.toFixed(4);
                        document.getElementById('preview-theta2').value = theta2.toFixed(4);
                        document.getElementById('preview-omega1').value = w1.toFixed(4);
                        document.getElementById('preview-omega2').value = w2.toFixed(4);
                        
                        infoDiv.textContent = `ðŸ“Œ Î¸1: ${theta1.toFixed(4)}, Î¸2: ${theta2.toFixed(4)}`;
                        document.getElementById('preset-select').value = 'custom';

                        document.getElementById('start-preview-btn').click();

                        const panel = document.getElementById('info-panel');
                        if (!panel.classList.contains('expanded')) {
                            panel.classList.add('expanded');
                            document.getElementById('pendulum-preview-container').classList.remove('hidden');
                        }
                    }
                 }
            }
        }
    }
    
    function onDoubleClick() {
        zoomState = { x: 0, y: 0, scale: new THREE.Vector2(1.0, 1.0) };
        needsRestart = true;
        updateViewInputs();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animatePreviewPendulum() {
        if (!isPreviewRunning || !previewCanvasCtx) return;

        const L1 = 1.0, L2 = 1.0, M1 = 1.0, M2 = 1.0;
        const dt = timeStep; // Use global timeStep

        let { t1, t2, w1, w2 } = previewPendulumState;
        
        const numSubSteps = 2;
        const subDt = dt / numSubSteps;

        for (let i = 0; i < numSubSteps; i++) {
            let diff_t = t2 - t1;
            const den1 = (M1 + M2) * L1 - M2 * L1 * Math.cos(diff_t) * Math.cos(diff_t);
            const den2 = (L2 / L1) * den1;

            if (Math.abs(den1) < 1e-6 || Math.abs(den2) < 1e-6) continue;

            const dw1 = (M2*L1*w1*w1*Math.sin(diff_t)*Math.cos(diff_t) + M2*gravity*Math.sin(t2)*Math.cos(diff_t) + M2*L2*w2*w2*Math.sin(diff_t) - (M1+M2)*gravity*Math.sin(t1)) / den1;
            const dw2 = (-M2*L2*w2*w2*Math.sin(diff_t)*Math.cos(diff_t) + (M1+M2)*gravity*Math.sin(t1)*Math.cos(diff_t) - (M1+M2)*L1*w1*w1*Math.sin(diff_t) - (M1+M2)*gravity*Math.sin(t2)) / den2;
            
            w1 += dw1 * subDt;
            w2 += dw2 * subDt;
            t1 += w1 * subDt;
            t2 += w2 * subDt;
        }

        previewPendulumState = { t1, t2, w1, w2 };

        // Drawing
        const canvas = previewCanvasCtx.canvas;
        previewCanvasCtx.clearRect(0, 0, canvas.width, canvas.height);
        const scale = 80, originX = canvas.width / 2, originY = canvas.height / 2;
        const x1 = originX + L1 * scale * Math.sin(t1);
        const y1 = originY + L1 * scale * Math.cos(t1);
        const x2 = x1 + L2 * scale * Math.sin(t2);
        const y2 = y1 + L2 * scale * Math.cos(t2);

        if (traceLength > 0) {
            tracePoints.push({x: x2, y: y2});
            if(tracePoints.length > traceLength) {
                tracePoints.shift();
            }
        }
        
        previewCanvasCtx.lineWidth = 2;
        if (tracePoints.length > 1) {
            for(let i = 1; i < tracePoints.length; i++) {
                const alpha = (i / tracePoints.length) * 0.7;
                previewCanvasCtx.strokeStyle = `rgba(199, 210, 254, ${alpha})`;
                previewCanvasCtx.beginPath();
                previewCanvasCtx.moveTo(tracePoints[i-1].x, tracePoints[i-1].y);
                previewCanvasCtx.lineTo(tracePoints[i].x, tracePoints[i].y);
                previewCanvasCtx.stroke();
            }
        }

        previewCanvasCtx.strokeStyle = '#9ca3af';
        previewCanvasCtx.lineWidth = 2;
        previewCanvasCtx.beginPath();
        previewCanvasCtx.moveTo(originX, originY);
        previewCanvasCtx.lineTo(x1, y1);
        previewCanvasCtx.lineTo(x2, y2);
        previewCanvasCtx.stroke();
        
        previewCanvasCtx.fillStyle = '#f9fafb';
        previewCanvasCtx.beginPath();
        previewCanvasCtx.arc(originX, originY, 4, 0, 2 * Math.PI);
        previewCanvasCtx.fill();
        previewCanvasCtx.fillStyle = '#818cf8';
        previewCanvasCtx.beginPath();
        previewCanvasCtx.arc(x1, y1, 6, 0, 2 * Math.PI);
        previewCanvasCtx.fill();
        previewCanvasCtx.fillStyle = '#c7d2fe';
        previewCanvasCtx.beginPath();
        previewCanvasCtx.arc(x2, y2, 6, 0, 2 * Math.PI);
        previewCanvasCtx.fill();
    }

    function animate() {
        const delta = clock.getDelta();
        controls.update();
        if(currentUpdate) currentUpdate(delta);
        animatePreviewPendulum();
        renderer.render(scene, camera);
    }
    
    // --- GLSL Shaders ---
    function getGPGPUVertexShader() { return `
        out vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = vec4(position, 1.0);
        }`;
    }

    function getSceneVertexShader() { return `
        out vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`;
    }

    function getInitializeShader() {
        return `
precision highp float;
in vec2 vUv;
out vec4 outColor;
uniform float omega1, omega2;
uniform vec2 zoomCenter, zoomScale;
uniform float uNumSlices, uThreeDAxis;
uniform vec2 uAtlasGrid;
const float PI = 3.1415926535;
const float TWO_PI = 6.283185307;
const float OMEGA_RANGE = 4.0;
void main() {
    vec2 gridCell = floor(vUv * uAtlasGrid);
    float sliceIndex = gridCell.y * uAtlasGrid.x + gridCell.x;
    vec2 cellUv = fract(vUv * uAtlasGrid);
    float rangeX = TWO_PI / zoomScale.x;
    float minTheta1 = (zoomCenter.x * TWO_PI) - rangeX / 2.0;
    float rangeY = TWO_PI / zoomScale.y;
    float minTheta2 = (zoomCenter.y * TWO_PI) - rangeY / 2.0;
    float theta1 = minTheta1 + cellUv.x * rangeX;
    float theta2 = minTheta2 + cellUv.y * rangeY;
    float w1 = omega1;
    float w2 = omega2;
    float dynamicOmega = (sliceIndex / (uNumSlices - 1.0) - 0.5) * OMEGA_RANGE;
    if (uThreeDAxis > 0.5) w1 = dynamicOmega; else w2 = dynamicOmega;
    outColor = vec4(theta1, theta2, w1, w2);
}`;
    }

    function getUpdateShader() { return `
precision highp float;
in vec2 vUv;
out vec4 outColor;
uniform sampler2D textureState;
uniform float timeStep;
uniform float uGravity;
const float L1 = 1.0, L2 = 1.0, M1 = 1.0, M2 = 1.0;
const float PI = 3.1415926535, TWO_PI = 6.283185307;
float wrap(float a) { return a - TWO_PI * floor((a + PI) / TWO_PI); }
void main() {
    vec4 s = texture(textureState, vUv);
    float t1 = s.x, t2 = s.y, w1 = s.z, w2 = s.w, dt = t2 - t1;
    float den1 = (M1 + M2) * L1 - M2 * L1 * cos(dt) * cos(dt);
    float den2 = (L2 / L1) * den1;
    if (abs(den1) < 0.0001 || abs(den2) < 0.0001) {
        outColor = s;
        return;
    }
    float dw1 = (M2 * L1 * w1 * w1 * sin(dt) * cos(dt) + M2 * uGravity * sin(t2) * cos(dt) + M2 * L2 * w2 * w2 * sin(dt) - (M1 + M2) * uGravity * sin(t1)) / den1;
    float dw2 = (-M2 * L2 * w2 * w2 * sin(dt) * cos(dt) + (M1 + M2) * uGravity * sin(t1) * cos(dt) - (M1 + M2) * L1 * w1 * w1 * sin(dt) - (M1 + M2) * uGravity * sin(t2)) / den2;
    w1 += dw1 * timeStep;
    w2 += dw2 * timeStep;
    t1 += w1 * timeStep;
    t2 += w2 * timeStep;
    outColor = vec4(wrap(t1), wrap(t2), w1, w2);
}`;
    }

    function getDrawShader() { return `
precision highp float;
in vec2 vUv;
out vec4 outColor;
uniform sampler2D uAtlasTexture;
uniform float uSliceIndex;
uniform vec2 uAtlasGrid;
const float PI = 3.1415926535;
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
void main() {
    float gridX = mod(uSliceIndex, uAtlasGrid.x);
    float gridY = floor(uSliceIndex / uAtlasGrid.x);
    vec2 offset = vec2(gridX, gridY) / uAtlasGrid;
    vec2 sliceUv = vUv / uAtlasGrid + offset;
    vec4 state = texture(uAtlasTexture, sliceUv);
    float hue = (state.y + PI) / (2.0 * PI);
    float sat = clamp(length(state.zw) * 0.2, 0.7, 1.0);
    float val = clamp(1.0 - length(state.zw) * 0.1, 0.8, 1.0);
    outColor = vec4(hsv2rgb(vec3(hue, sat, val)), 1.0);
}`;
    }

    function getInstancedVertexShader() { return `
out vec2 vUv;
out float vInstanceID;
void main() {
    vUv = uv;
    vInstanceID = float(gl_InstanceID);
    vec3 pos = position;
    pos.z += (float(gl_InstanceID) / 32.0 - 0.5) * 2.0;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}`;
    }

    function getInstancedDrawShader() { return `
precision highp float;
in vec2 vUv;
in float vInstanceID;
out vec4 outColor;
uniform sampler2D uAtlasTexture;
uniform float uNumSlices, uTransparency;
uniform vec2 uAtlasGrid;
const float PI = 3.1415926535;
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
void main() {
    float gridX = mod(vInstanceID, uAtlasGrid.x);
    float gridY = floor(vInstanceID / uAtlasGrid.x);
    vec2 offset = vec2(gridX, gridY) / uAtlasGrid;
    vec2 sliceUv = vUv / uAtlasGrid + offset;
    vec4 state = texture(uAtlasTexture, sliceUv);
    float hue = (state.y + PI) / (2.0 * PI);
    float sat = clamp(length(state.zw) * 0.2, 0.7, 1.0);
    float val = clamp(1.0 - length(state.zw) * 0.1, 0.8, 1.0);
    outColor = vec4(hsv2rgb(vec3(hue, sat, val)), uTransparency / uNumSlices);
}`;
    }

    init();

</script>
</body>
</html>

