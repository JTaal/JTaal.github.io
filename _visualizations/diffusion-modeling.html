---
date: 2025-08-29
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diffusion Model</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Source+Serif+4:opsz,wght@8..60,400;8..60,700&display=swap');
        :root { 
            --header-height: 140px; /* Increased to fit buttons */
            --footer-height: 80px; 
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #e2e8f0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #top-header {
            position: absolute;
            top: 0; left: 0; width: 100%;
            height: var(--header-height);
            display: flex;
            flex-direction: column; /* Stack title and buttons */
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
            padding-top: 1rem;
        }
        #top-header h1 {
            font-family: 'Source Serif 4', serif;
            font-weight: 700;
            font-size: 2.5rem;
            line-height: 1.1;
            letter-spacing: -0.02em;
        }
        #top-header p {
             font-size: 1rem;
             color: #94a3b8;
             margin-top: 0.25rem;
        }
        #shape-controls {
            margin-top: 1rem;
            display: flex;
            gap: 0.75rem;
        }
        #main-container {
            display: flex;
            flex-grow: 1;
            width: 100vw;
            padding-top: var(--header-height);
        }
        .viz-container {
            position: relative;
            width: 33.33%;
            height: 100%;
            border-left: 1px solid #1e293b;
        }
        .viz-container:first-child { border-left: none; }
        .viz-container.fullscreen {
            position: fixed;
            top: 0; left: 0;
            width: 100vw !important;
            height: calc(100vh - var(--footer-height)) !important;
            z-index: 50;
            border-left: none;
        }
        canvas { display: block; }
        .ui-footer {
            position: relative;
            z-index: 60;
            background-color: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem;
            text-align: center;
            height: var(--footer-height);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .controls-grid {
            display: flex;
            gap: 2.5rem;
            align-items: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .control-group label {
            font-size: 0.8rem; font-weight: 500; color: #cbd5e1;
        }
        .slider {
            -webkit-appearance: none; width: 220px; height: 6px;
            background: #334155; border-radius: 3px; outline: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px; background: #a78bfa;
            cursor: pointer; border-radius: 50%; border: 2px solid #fff;
        }
        .toggle-button, .shape-btn {
            cursor: pointer; padding: 0.35rem 1rem; border-radius: 99px;
            font-size: 0.8rem; background-color: #334155;
            transition: background-color 0.2s; user-select: none;
            color: white; border: none;
        }
        .toggle-button.active, .shape-btn.active { background-color: #a78bfa; }
        .viz-title {
            position: absolute;
            top: 1rem; left: 50%; transform: translateX(-50%);
            z-index: 5; color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem; pointer-events: none;
        }
        .variance-display {
            font-family: monospace; font-size: 0.8rem; color: #a78bfa;
            min-width: 50px; text-align: left;
        }
        .fullscreen-btn {
            position: absolute; bottom: 1rem; right: 1rem;
            z-index: 6; cursor: pointer;
            background-color: rgba(30, 41, 59, 0.5);
            padding: 0.5rem; border-radius: 50%;
            transition: background-color 0.2s;
        }
        .fullscreen-btn:hover { background-color: rgba(51, 65, 85, 0.8); }
        #return-btn {
            position: fixed; bottom: calc(var(--footer-height) + 1rem); right: 1rem;
            z-index: 100;
            background-color: #a78bfa; color: white;
            padding: 0.5rem 1rem; border-radius: 99px;
            font-size: 0.8rem; font-weight: 500;
            cursor: pointer;
        }
        .score-controls {
            display: none;
        }
        .viz-container.fullscreen .score-controls {
            display: flex;
            position: absolute;
            top: 1rem; /* Repositioned relative to its own container */
            left: 50%;
            transform: translateX(-50%);
            z-index: 55;
            gap: 1rem;
            align-items: center;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="top-header">
        <div>
            <h1>Diffusion Model</h1>
            <p>a universal probability distribution approximator</p>
        </div>
        <div id="shape-controls">
            <button class="shape-btn active" data-shape="sphere">Sphere</button>
            <button class="shape-btn" data-shape="torus">Torus</button>
            <button class="shape-btn" data-shape="box">Box</button>
        </div>
    </div>

    <main id="main-container">
        <div id="container1" class="viz-container" data-id="1">
             <div class="viz-title">1. Forward Process</div>
             <div class="fullscreen-btn" data-id="1"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-white" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg></div>
        </div>
        <div id="container2" class="viz-container" data-id="2">
             <div class="viz-title">2. Score Field</div>
             <div class="score-controls">
                <button id="modeToggle" class="toggle-button active">Slice</button>
                <input id="zSlider" type="range" min="-20" max="20" value="0" step="0.1" class="slider w-[150px]">
             </div>
             <div class="fullscreen-btn" data-id="2"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-white" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg></div>
        </div>
        <div id="container3" class="viz-container" data-id="3">
             <div class="viz-title">3. Reverse Process</div>
             <div class="fullscreen-btn" data-id="3"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-white" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg></div>
        </div>
    </main>

    <footer class="ui-footer">
        <div class="controls-grid">
            <div class="control-group">
                <label for="timeStep">Time Step ($t$)</label>
                <div class="flex items-center gap-2">
                    <input id="timeStep" type="range" min="0" max="1" value="0.75" step="0.001" class="slider">
                    <span id="varianceDisplay" class="variance-display">σ²=0.00</span>
                </div>
            </div>
        </div>
    </footer>

    <button id="return-btn" class="hidden">Return</button>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Config & State ---
        let scoreFieldMode = 'slice';
        let zSlicePosition = 0;
        let NUM_WALKERS = 0;
        const MAX_VARIANCE = 25;
        let currentShape = 'sphere';
        const shapeParams = {
            sphere: { radius: 10 },
            torus: { radius: 8, tube: 3 },
            box: { size: 15 }
        };
        const originalSizes = {};

        // --- Viz Objects ---
        let scene1, camera1, renderer1, controls1, particles1, originalPositions1;
        let scene2, camera2, renderer2, controls2, arrows = [], wireframe2;
        let scene3, camera3, renderer3, controls3, walkers = [], wireframe3;
        
        const container1 = document.getElementById('container1');
        const container2 = document.getElementById('container2');
        const container3 = document.getElementById('container3');

        // --- Shape Switching Logic ---
        function switchShape(newShape) {
            currentShape = newShape;
            
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.shape === newShape);
            });

            createShapeParticles(newShape);
            
            if(wireframe2) scene2.remove(wireframe2);
            const wireframeGeom2 = createShapeGeometry(newShape);
            const wireframeMat2 = new THREE.MeshBasicMaterial({ color: 0x2dd4bf, wireframe: true, transparent: true, opacity: 0.2 });
            wireframe2 = new THREE.Mesh(wireframeGeom2, wireframeMat2);
            scene2.add(wireframe2);

            if(wireframe3) scene3.remove(wireframe3);
            const wireframeGeom3 = createShapeGeometry(newShape);
            const wireframeMat3 = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.3 });
            wireframe3 = new THREE.Mesh(wireframeGeom3, wireframeMat3);
            scene3.add(wireframe3);

            regenerateScoreFieldArrows();
            updateAllVisuals();
        }

        function createShapeGeometry(shapeName) {
            switch(shapeName) {
                case 'torus': return new THREE.TorusGeometry(shapeParams.torus.radius, shapeParams.torus.tube, 32, 100);
                case 'box': return new THREE.BoxGeometry(shapeParams.box.size, shapeParams.box.size, shapeParams.box.size, 15, 15, 15);
                case 'sphere':
                default: return new THREE.SphereGeometry(shapeParams.sphere.radius, 48, 48);
            }
        }

        // --- Init Functions ---
        function init1() {
            scene1 = new THREE.Scene();
            camera1 = new THREE.PerspectiveCamera(75, container1.clientWidth / container1.clientHeight, 0.1, 1000);
            camera1.position.z = 45;
            renderer1 = new THREE.WebGLRenderer({ antialias: true });
            renderer1.setSize(container1.clientWidth, container1.clientHeight);
            renderer1.setPixelRatio(window.devicePixelRatio);
            container1.appendChild(renderer1.domElement);
            controls1 = new THREE.OrbitControls(camera1, renderer1.domElement);
            controls1.enableDamping = true;
        }

        function init2() {
            scene2 = new THREE.Scene();
            camera2 = new THREE.PerspectiveCamera(75, container2.clientWidth / container2.clientHeight, 0.1, 1000);
            camera2.position.set(0, 0, 50);
            renderer2 = new THREE.WebGLRenderer({ antialias: true });
            renderer2.setSize(container2.clientWidth, container2.clientHeight);
            renderer2.setPixelRatio(window.devicePixelRatio);
            container2.appendChild(renderer2.domElement);
            controls2 = new THREE.OrbitControls(camera2, renderer2.domElement);
            controls2.enableDamping = true;
        }

        function init3() {
            scene3 = new THREE.Scene();
            camera3 = new THREE.PerspectiveCamera(75, container3.clientWidth / container3.clientHeight, 0.1, 1000);
            camera3.position.set(0, 0, 48);
            renderer3 = new THREE.WebGLRenderer({ antialias: true });
            renderer3.setSize(container3.clientWidth, container3.clientHeight);
            renderer3.setPixelRatio(window.devicePixelRatio);
            container3.appendChild(renderer3.domElement);
            controls3 = new THREE.OrbitControls(camera3, renderer3.domElement);
            controls3.enableDamping = true;
        }
        
        function createShapeParticles(shapeName) {
            if (particles1) scene1.remove(particles1);
            
            const geometry = createShapeGeometry(shapeName);
            const material = new THREE.PointsMaterial({ size: 0.15, vertexColors: true });
            originalPositions1 = geometry.attributes.position.clone().array;
            NUM_WALKERS = geometry.attributes.position.count;
            const colors = new Float32Array(originalPositions1.length).fill(1);
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles1 = new THREE.Points(geometry, material);
            scene1.add(particles1);

            walkers.forEach(w => scene3.remove(w));
            walkers = [];
            for (let i = 0; i < NUM_WALKERS; i++) {
                const walkerGeom = new THREE.SphereGeometry(0.15, 8, 8);
                const walkerMat = new THREE.MeshBasicMaterial({ color: 0xc084fc });
                const walker = new THREE.Mesh(walkerGeom, walkerMat);
                walkers.push(walker);
                scene3.add(walker);
            }
        }

        function updateDiffusion(variance) {
            if(!particles1) return;
            const positions = particles1.geometry.attributes.position.array;
            const colors = particles1.geometry.attributes.color.array;
            const cWhite = new THREE.Color(0xffffff), cBlue = new THREE.Color(0x2563eb), cGreen = new THREE.Color(0x16a34a), cRed = new THREE.Color(0xdc2626);

            for (let i = 0; i < positions.length; i += 3) {
                const randomVec = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2).normalize().multiplyScalar(variance * Math.random());
                positions[i] = originalPositions1[i] + randomVec.x;
                positions[i+1] = originalPositions1[i+1] + randomVec.y;
                positions[i+2] = originalPositions1[i+2] + randomVec.z;

                const dist = randomVec.length();
                const color = new THREE.Color();
                if (dist < 1) color.lerpColors(cWhite, cBlue, dist);
                else if (dist < 8) color.lerpColors(cBlue, cGreen, (dist - 1) / 7);
                else color.lerpColors(cGreen, cRed, Math.min((dist - 8) / (MAX_VARIANCE - 8), 1.0));
                
                color.toArray(colors, i);
            }
            particles1.geometry.attributes.position.needsUpdate = true;
            particles1.geometry.attributes.color.needsUpdate = true;
        }
        
        function regenerateScoreFieldArrows() {
            arrows.forEach(arrow => scene2.remove(arrow));
            arrows = [];
            const radius = shapeParams[currentShape]?.radius || shapeParams.box.size;
            if (scoreFieldMode === 'slice') {
                const gridSize = 20, gridDivs = 15, step = (gridSize*2)/gridDivs;
                for (let x = -gridSize; x <= gridSize; x += step) for (let y = -gridSize; y <= gridSize; y += step) {
                    const pos = new THREE.Vector3(x, y, zSlicePosition);
                    const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), pos, 1, 0x2dd4bf, 1, 0.5);
                    arrows.push(arrow); scene2.add(arrow);
                }
            } else {
                const gridSize = 15, gridDivs = 8, step = (gridSize*2)/gridDivs;
                for (let x = -gridSize; x <= gridSize; x += step) for (let y = -gridSize; y <= gridSize; y += step) for (let z = -gridSize; z <= gridSize; z += step) {
                    const pos = new THREE.Vector3(x, y, z);
                    if (pos.length() < radius + 1) continue;
                    const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), pos, 1, 0x2dd4bf, 1, 0.5);
                    arrows.push(arrow); scene2.add(arrow);
                }
            }
            if (typeof updateAllVisuals === 'function') updateAllVisuals();
        }
        
        function getNearestPointOnManifold(point) {
            const p = point.clone();
            switch(currentShape) {
                case 'box':
                    const s = shapeParams.box.size / 2;
                    return p.clamp(new THREE.Vector3(-s,-s,-s), new THREE.Vector3(s,s,s));
                case 'torus':
                    const R = shapeParams.torus.radius;
                    const p_xy = new THREE.Vector3(p.x, p.y, 0);
                    const nearest_on_ring = p_xy.normalize().multiplyScalar(R);
                    const from_ring_to_p = new THREE.Vector3().subVectors(p, nearest_on_ring);
                    const nearest_on_tube = from_ring_to_p.normalize().multiplyScalar(shapeParams.torus.tube);
                    return nearest_on_ring.add(nearest_on_tube);
                case 'sphere':
                default:
                    return p.normalize().multiplyScalar(shapeParams.sphere.radius);
            }
        }
        
        function updateScoreField(variance) {
            arrows.forEach(arrow => {
                const p = arrow.position;
                const nearest = getNearestPointOnManifold(p);
                const dir = new THREE.Vector3().subVectors(nearest, p);
                const len = dir.length() / (1 + variance * 0.4);
                arrow.setDirection(dir.normalize());
                arrow.setLength(Math.max(0.1, len), 0.8, 0.4);
            });
        }

        function resetWalkers() {
            if (!walkers || walkers.length === 0) return;
            const t = parseFloat(document.getElementById('timeStep').value);
            const variance = t * MAX_VARIANCE;
            walkers.forEach(walker => {
                const originalPoint = getNearestPointOnManifold(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(100));
                const noise = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(variance * (0.8 + Math.random() * 0.4));
                walker.position.copy(originalPoint.add(noise));
            });
        }

        function animateGeneration() {
            if (!walkers || walkers.length === 0) return;
            walkers.forEach((walker) => {
                const p = walker.position;
                const nearest 
